<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeMuのBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-16T11:51:03.725Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YeMu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring</title>
    <link href="http://example.com/2022/08/16/Spring/"/>
    <id>http://example.com/2022/08/16/Spring/</id>
    <published>2022-08-16T11:26:09.187Z</published>
    <updated>2022-08-16T11:51:03.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>框架源自于建筑学，隶属土木工程，后发展到软件工程领域</p><p>软件工程框架：经过验证的，具有一定功能的，半成品软件</p><ul><li><p>经过验证</p></li><li><p>具有一定功能</p></li><li><p>半成品</p></li></ul><p>框架作用：</p><ul><li><p>提高开发效率</p></li><li><p>增强可重用性</p></li><li><p>提供编写规范</p></li><li><p>节约维护成本</p></li><li><p>解耦底层实现原理</p></li></ul><p>参考视频：<a href="https://space.bilibili.com/37974444">https://space.bilibili.com/37974444</a></p><hr><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是分层的 JavaSE&#x2F;EE 应用 full-stack 轻量级开源框架</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.png"></p><p>Spring 优点：</p><ul><li>方便解耦，简化开发</li><li>方便集成各种框架</li><li>方便程序测试</li><li>AOP 编程难过的支持</li><li>声明式事务的支持</li><li>降低 JavaEE API 的使用难度</li></ul><p>体系结构：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><hr><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><ul><li>IoC（Inversion Of Control）控制反转，Spring 反向控制应用程序所需要使用的外部资源</li><li><strong>Spring 控制的资源全部放置在 Spring 容器中，该容器称为 IoC 容器</strong>（存放实例对象）</li><li>官方网站：<a href="https://spring.io/">https://spring.io/</a> → Projects → spring-framework → LEARN → Reference Doc</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E4%BB%8B%E7%BB%8D.png"></p><ul><li>耦合（Coupling）：代码编写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度</li><li>内聚（Cohesion）：代码编写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系</li><li>代码编写的目标：高内聚，低耦合。同一个模块内的各个元素之间要高度紧密，各个模块之间的相互依存度不紧密</li></ul><hr><h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>模拟三层架构中表现层调用业务层功能</p><ul><li><p>表现层：UserApp 模拟 UserServlet（使用 main 方法模拟）</p></li><li><p>业务层：UserService</p></li></ul><p>步骤：</p><ol><li><p>导入 spring 坐标（5.1.9.release）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写业务层与表现层（模拟）接口与实现类 service.UserService，service.impl.UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//业务方法  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建立 Spring 配置文件：resources.<strong>applicationContext</strong>.xml (名字一般使用该格式)</p></li><li><p>配置所需资源（Service）为 Spring 控制的资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.创建spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表现层（App）通过 Spring 获取资源（Service 实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2.加载配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取资源</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E5%AE%9E%E7%8E%B0.png"></p></li></ol><hr><h3 id="XML开发"><a href="#XML开发" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>标签：<bean> 标签，<beans> 的子标签</p><p>作用：定义 Spring 中的资源，受此标签定义的资源将受到 Spring 控制</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性</p><ul><li>id：bean 的名称，通过 id 值获取 bean (首字母小写)</li><li>class：bean 的类型，使用完全限定类名</li><li>name：bean 的名称，可以通过 name 值获取 bean，用于多人配合时给 bean 起别名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanId&quot;</span> <span class="attr">name</span>=<span class="string">&quot;beanName1,beanName2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ClassName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getBean(<span class="string">&quot;beanId&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName1&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName2&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>作用：定义 bean 的作用范围</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取值：</p><ul><li>singleton：设定创建出的对象保存在 Spring 容器中，是一个单例的对象</li><li>prototype：设定创建出的对象保存在 Spring 容器中，是一个非单例（原型）的对象</li><li>request、session、application、 websocket ：设定创建出的对象放置在 web 容器对应的位置</li></ul><p>Spring 容器中 Bean 的<strong>线程安全</strong>问题：</p><ul><li><p>原型 Bean，每次创建一个新对象，线程之间并不存在 Bean 共享，所以不会有线程安全的问题</p></li><li><p>单例 Bean，所有线程共享一个单例实例 Bean，因此是存在资源的竞争，如果单例 Bean是一个<strong>无状态 Bean</strong>，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的</p><p>解决方法：开发人员来进行线程安全的保证，最简单的办法就是把 Bean 的作用域 singleton 改为 protopyte</p></li></ul><hr><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>作用：定义 bean 对象在初始化或销毁时完成的工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&gt;&lt;/bean&gt;</span></span></span><br></pre></td></tr></table></figure><p>取值：bean 对应的类中对应的具体方法名</p><p>实现接口的方式实现初始化，无需配置文件配置 init-method：</p><ul><li>实现 InitializingBean，定义初始化逻辑</li><li>实现 DisposableBean，定义销毁逻辑</li></ul><p>注意事项：</p><ul><li>当 scope&#x3D;“singleton” 时，Spring 容器中有且仅有一个对象，init 方法在创建容器时仅执行一次</li><li>当 scope&#x3D;“prototype” 时，Spring 容器要创建同一类型的多个对象，init 方法在每个对象创建时均执行一次</li><li>当 scope&#x3D;“singleton” 时，关闭容器（<code>.close()</code>）会导致 bean 实例的销毁，调用 destroy 方法一次</li><li>当 scope&#x3D;“prototype” 时，对象的销毁由垃圾回收机制 GC 控制，destroy 方法将不会被执行</li></ul><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--init-method和destroy-method用于控制bean的生命周期--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>业务层实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; constructor is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService3&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul><li><p>静态工厂</p><p>作用：定义 bean 对象创建方式，使用静态工厂的形式创建 bean，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;FactoryClassName&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取值：工厂 bean 中用于获取对象的静态方法名</p><p>注意事项：class 属性必须配置成静态工厂的类名</p><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂创建 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService4&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例工厂</p><p>作用：定义 bean 对象创建方式，使用实例工厂的形式创建 bean，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBeanId&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>使用实例工厂创建 bean 首先需要将实例工厂配置 bean，交由 Spring 进行管理</p></li><li><p>factory-bean 是实例工厂的 Id</p></li></ul><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实例工厂创建 bean，依赖工厂对象对应的 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService5&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; instance factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h5><p>ApplicationContext 子类相关API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String[] getBeanDefinitionNames()</td><td>获取 Spring 容器中定义的所有 JavaBean 的名称</td></tr><tr><td>BeanDefinition getBeanDefinition(String beanName)</td><td>返回给定 bean 名称的 BeanDefinition</td></tr><tr><td>String[] getBeanNamesForType(Class&lt;?&gt; type)</td><td>获取 Spring 容器中指定类型的所有 JavaBean 的名称</td></tr><tr><td>Environment getEnvironment()</td><td>获取与此组件关联的环境</td></tr></tbody></table><hr><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><ul><li><p>IoC（Inversion Of Control）控制翻转，Spring 反向控制应用程序所需要使用的外部资源</p></li><li><p>DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由 Spring 为其提供，资源进入应用程序的方式称为注入，简单说就是利用反射机制为类的属性赋值的操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-DI%E4%BB%8B%E7%BB%8D.png"></p></li></ul><p>IoC 和 DI 的关系：IoC 与 DI 是同一件事站在不同角度看待问题</p><hr><h5 id="set-注入"><a href="#set-注入" class="headerlink" title="set 注入"></a>set 注入</h5><p>标签：<property> 标签，<bean> 的子标签</p><p>作用：使用 set 方法的形式为 bean 提供资源</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>name：对应 bean 中的属性名，要注入的变量名，要求该属性必须提供可访问的 set 方法（严格规范此名称是 set 方法对应名称，首字母必须小写）</li><li>value：设定非引用类型属性对应的值，<strong>不能与 ref 同时使用</strong></li><li>ref：设定引用类型属性对应 bean 的 id ，不能与 value 同时使用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.对需要进行注入的变量添加set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        userDao.save();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.将要注入的资源声明为bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.将要注入的引用类型的变量通过property属性进行注入，--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>标签：<constructor-arg> 标签，<bean> 的子标签</p><p>作用：使用构造方法的形式为 bean 提供资源，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> /&gt;</span></span><br><span class="line">    .....<span class="comment">&lt;!--一个bean可以有多个constructor-arg标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>name：对应bean中的构造方法所携带的参数名</li><li>value：设定非引用类型构造方法参数对应的值，不能与 ref 同时使用</li><li>ref：设定引用类型构造方法参数对应 bean 的 id ，不能与 value 同时使用</li><li>type：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验</li><li>index：设定构造方法参数的位置，用于按位置匹配参数，参数 index 值从 0 开始计数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;argsName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;argsValue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;arg-index&quot;</span> <span class="attr">type</span>=<span class="string">&quot;arg-type&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(String driver,String username, String pwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+username+<span class="string">&quot; &quot;</span>+pwd+<span class="string">&quot; &quot;</span>+driver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层：参考 set 注入</p></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用构造方法进行注入，需要保障注入的属性与bean中定义的属性一致--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一致指顺序一致或类型一致或使用index解决该问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用 UserServiceImpl 的构造方法注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：参考 set 注入</p></li></ul><hr><h5 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h5><p>标签：<array> <list> <set> <map> <props>，<property> 或 <constructor-arg> 标签的子标签</p><p>作用：注入集合数据类型属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList al;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> HashSet hs;</span><br><span class="line">    <span class="keyword">private</span> HashMap hm ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAl</span><span class="params">(ArrayList al)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.al = al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArr</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHs</span><span class="params">(HashSet hs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hs = hs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHm</span><span class="params">(HashMap hm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hm = hm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao running...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList:&quot;</span> + al);</span><br><span class="line">        System.out.println(<span class="string">&quot;Properties:&quot;</span> + properties);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet:&quot;</span> + hs);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap:&quot;</span> + hm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;al&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>seazean666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span>&gt;</span>666666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;seazean66666&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6666666666&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>标签：&lt;p:propertyName&gt;，&lt;p:propertyName-ref&gt;</p><p>作用：为 bean 注入属性值</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">p:propertyName</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">p:propertyName-ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>开启 p 命令空间：开启 Spring 对 p 命令空间的的支持，在 beans 标签中添加对应空间支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:bookDao-ref</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:num</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><p>Spring 提供了对 EL 表达式的支持，统一属性注入格式</p><p>作用：为 bean 注入属性值</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;EL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：所有属性值不区分是否引用类型，统一使用value赋值</p><p>所有格式统一使用  value&#x3D;“#{}”</p><ul><li><p>常量  #{10}  #{3.14}  #{2e5}  #{‘it’}</p></li><li><p>引用 bean  #{beanId}    </p></li><li><p>引用 bean 属性  #{beanId.propertyName}</p></li><li><p>引用 bean 方法  beanId.methodName().method2()</p></li><li><p>引用静态方法  T(java.lang.Math).PI</p></li><li><p>运算符支持  #{3 lt 4 &#x3D;&#x3D; 4 ge 3}</p></li><li><p>正则表达式支持  #{user.name matches‘[a-z]{6,}’}</p></li><li><p>集合支持  #{likes[3]}</p></li></ul><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;userDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;bookDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;666666666&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>Spring 提供了读取外部 properties 文件的机制，使用读取到的数据为 bean 的属性赋值</p><p>操作步骤：</p><ol><li><p>准备外部 properties 文件</p></li><li><p>开启 context 命名空间支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载指定的 properties 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:data.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用加载的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;propertiesName&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：如果需要加载所有的 properties 文件，可以使用 <code>*.properties</code> 表示加载所有的 properties 文件</p></li><li><p>注意：读取数据使用 <strong>${propertiesName}</strong> 格式进行，其中 propertiesName 指 properties 文件中的属性名</p></li></ul><p>代码实现：</p><ul><li><p>data.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>DAO 层：注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+userName+<span class="string">&quot; &quot;</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>标签：<import>，<beans>标签的子标签</p><p>作用：在当前配置文件中导入其他配置文件中的项</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>resource：加载的配置文件名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">“config2.xml</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 容器加载多个配置文件：</p><ul><li><p>applicationContext-book.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext-user.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-user.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-book.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.seazean.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext-user.xml&quot;</span>,<span class="string">&quot;applicationContext-book.xml&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>Spring 容器中的 bean 定义冲突问题</p><ul><li><p>同 id 的 bean，后定义的覆盖先定义的</p></li><li><p>导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置，程序执行选择最下面的配置使用</p></li><li><p>导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同</p></li></ul><hr><h4 id="三方资源"><a href="#三方资源" class="headerlink" title="三方资源"></a>三方资源</h4><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>第三方资源配置</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载druid资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">datasource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;datasource&quot;</span>);</span><br><span class="line">System.out.println(datasource);</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h5><p>Mybatis 核心配置文件消失</p><ul><li><p>环境 environment 转换成数据源对象</p></li><li><p>映射 Mapper 扫描工作交由 Spring 处理</p></li><li><p>类型别名交由 Spring 处理</p></li></ul><p>DAO 接口不需要创建实现类，MyBatis-Spring 提供了一个动态代理的实现 <strong>MapperFactoryBean</strong>，这个类可以让直接注入数据映射器接口到 service 层 bean 中，底层将会动态代理创建类</p><p>整合原理：利用 Spring 框架的 SPI 机制，在 META-INF 目录的 spring.handlers 中给 Spring 容器中导入 NamespaceHandler 类</p><ul><li><p>NamespaceHandler 的 init 方法注册 bean 信息的解析器 MapperScannerBeanDefinitionParser</p></li><li><p>解析器在 Spring 容器创建过程中去<strong>解析 mapperScanner 标签</strong>，解析出的属性填充到 MapperScannerConfigurer 中</p></li><li><p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口，重写 postProcessBeanDefinitionRegistry() 方法，可以扫描到 MyBatis 的 Mapper</p></li></ul><hr><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h4><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>启动注解扫描，加载类中配置的注解项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName1,packageName2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在进行包扫描时，会对配置的包及其子包中所有文件进行扫描，多个包采用<code>,</code>隔开</li><li>扫描过程是以文件夹递归迭代的形式进行的</li><li>扫描过程仅读取合法的 Java 文件</li><li>扫描时仅读取 Spring 可识别的注解</li><li>扫描结束后会将可识别的有效注解转化为 Spring 对应的资源加入 IoC 容器</li><li>从加载效率上来说注解优于 XML 配置文件</li></ul><p>注解：启动时使用注解的形式替代 xml 配置，将 Spring 配置文件从工程中消除，简化书写</p><p>缺点：为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂。XML 中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%A4%BA%E4%BE%8B.png"></p><hr><h5 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解配置类</p><p>名称：@Configuration、@ComponentScan</p><p>类型：类注解</p><p>作用：<strong>设置当前类为 Spring 核心配置加载类</strong></p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;scanPackageName1&quot;,&quot;scanPackageName2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>核心配合类用于替换 Spring 核心配置文件，此类可以设置空的，不设置变量与属性</li><li>bean 扫描工作使用注解 @ComponentScan 替代，多个包用 <code>&#123;&#125; 和 ,</code> 隔开</li></ul><p>加载纯注解格式上下文对象，需要使用 <strong>AnnotationConfigApplicationContext</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">//方式一：名称对应类名</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：名称对应方法名 </span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean1</span> <span class="operator">=</span> (Person) applicationContext.getBean(<span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法三：指定名称@Bean(&quot;person2&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h5><p>组件扫描过滤器</p><p>开发过程中，需要根据需求加载必要的 bean，排除指定 bean</p><p>名称：@ComponentScan</p><p>类型：<strong>类注解</strong></p><p>作用：设置 Spring 配置加载类扫描规则</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,//设置基础扫描路径</span></span><br><span class="line"><span class="meta">    excludeFilters =//设置过滤规则，当前为排除过滤</span></span><br><span class="line"><span class="meta">@ComponentScan.Filter(//设置过滤器</span></span><br><span class="line"><span class="meta">    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤</span></span><br><span class="line"><span class="meta">    classes = Service.class)     //设置具体的过滤项，过滤所有@Service修饰的bean</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>includeFilters：设置包含性过滤器 </li><li>excludeFilters：设置排除性过滤器</li><li>type：设置过滤器类型</li></ul><hr><h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="设置-bean"><a href="#设置-bean" class="headerlink" title="设置 bean"></a>设置 bean</h5><p>名称：@Component、@Controller、@Service、@Repository</p><p>类型：类注解，写在类定义上方</p><p>作用：设置该类为 Spring 管理的 bean</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：@Controller、@Service 、@Repository 是 @Component 的衍生注解，功能同 @Component</p><p>属性：</p><ul><li>value（默认）：定义 bean 的访问 id</li></ul><hr><h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>名称：@Scope</p><p>类型：类注解，写在类定义上方</p><p>作用：设置该类作为 bean 对应的 scope 属性</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>相关属性</p><ul><li>value（默认）：定义 bean 的作用域，默认为 singleton，非单例取值 prototype</li></ul><hr><h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>名称：@PostConstruct、@PreDestroy</p><p>类型：方法注解，写在方法定义上方</p><p>作用：设置该类作为 bean 对应的生命周期方法</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义bean，后面添加bean的id</span></span><br><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//定义bean的作用域</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个对象的执行顺序：Constructor &gt;&gt; @Autowired（注入属性） &gt;&gt; @PostConstruct（初始化逻辑）</p><hr><h5 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h5><p>名称：@Bean</p><p>类型：方法注解</p><p>作用：设置该方法的返回值作为 Spring 管理的 bean</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;    <span class="keyword">return</span> ……;    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>因为第三方 bean 无法在其源码上进行修改，使用 @Bean 解决第三方 bean 的引入问题</p></li><li><p>该注解用于替代 XML 配置中的静态工厂与实例工厂创建 bean，不区分方法是否为静态或非静态</p></li><li><p>@Bean 所在的类必须被 Spring 扫描加载，否则该注解无法生效</p></li></ul><p>相关属性</p><ul><li>value（默认）：定义 bean 的访问 id</li><li>initMethod：声明初始化方法</li><li>destroyMethod：声明销毁方法</li></ul><hr><h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>名称：@Value</p><p>类型：属性注解、方法注解</p><p>作用：设置对应属性的值或对方法进行传参</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>value 值<strong>仅支持非引用类型数据</strong>，赋值时对方法的所有参数全部赋值</p></li><li><p>value 值支持读取 properties 文件中的属性值，通过类属性将 properties 中数据传入类中</p></li><li><p>value 值支持 SpEL</p></li><li><p>@value 注解如果添加在属性上方，可以省略 set 方法（set 方法的目的是为属性赋值）</p></li></ul><p>相关属性：</p><ul><li>value（默认）：定义对应的属性值或参数值</li></ul><hr><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><h6 id="属性注入-1"><a href="#属性注入-1" class="headerlink" title="属性注入"></a>属性注入</h6><p>名称：@Autowired、@Qualifier</p><p>类型：属性注解、方法注解</p><p>作用：设置对应属性的对象、对方法进行引用类型传参</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Autowired 默认按类型装配，指定 @Qualifier 后可以指定自动装配的 bean 的 id</li></ul><p>相关属性：</p><ul><li>required：<strong>为 true （默认）表示注入 bean 时该 bean 必须存在</strong>，不然就会注入失败抛出异常；为 false  表示注入时该 bean 存在就注入，不存在就忽略跳过</li></ul><p>注意：在使用 @Autowired 时，首先在容器中查询对应类型的 bean，如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据，如果查询的结果不止一个，那么 @Autowired 会根据名称来查找，如果查询的结果为空，那么会抛出异常</p><p>解决方法：使用 required &#x3D; false</p><hr><h6 id="优先注入"><a href="#优先注入" class="headerlink" title="优先注入"></a>优先注入</h6><p>名称：@Primary</p><p>类型：类注解</p><p>作用：设置类对应的 bean 按类型装配时优先装配</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Autowired 默认按类型装配，当出现相同类型的 bean，使用 @Primary 提高按类型自动装配的优先级，多个 @Primary 会导致优先级设置无效</li></ul><hr><h6 id="注解对比"><a href="#注解对比" class="headerlink" title="注解对比"></a>注解对比</h6><p>名称：@Inject、@Named、@Resource</p><ul><li>@Inject 与 @Named 是 JSR330 规范中的注解，功能与 @Autowired 和 @Qualifier 完全相同，适用于不同架构场景</li><li>@Resource 是 JSR250 规范中的注解，可以简化书写格式</li></ul><p>@Resource 相关属性</p><ul><li><p>name：设置注入的 bean 的 id</p></li><li><p>type：设置注入的 bean 的类型，接收的参数为 Class 类型</p></li></ul><p>@Autowired 和 @Resource之间的区别：</p><ul><li><p>@Autowired 默认是<strong>按照类型装配</strong>注入，默认情况下它要求依赖对象必须存在（可以设置 required 属性为 false）</p></li><li><p>@Resource 默认<strong>按照名称装配</strong>注入，只有当找不到与名称匹配的 bean 才会按照类型来装配注入</p></li></ul><hr><h5 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h5><p>Spring 容器管理的都是实例对象，**@Autowired 依赖注入的都是容器内的对象实例**，在 Java 中 static 修饰的静态属性（变量和方法）是属于类的，而非属于实例对象</p><p>当类加载器加载静态变量时，Spring 上下文尚未加载，所以类加载器不会在 Bean 中正确注入静态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译正常，但运行时报java.lang.NullPointerException，所以在调用testMethod()方法时，component变量还没被初始化</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li><p>@Autowired 注解到<strong>类的构造函数</strong>上，Spring 扫描到 Component 的 Bean，然后赋给静态变量 component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClass</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        TestClass.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Autowired 注解到<strong>静态属性的 setter 方法</strong>上</p></li><li><p>使用 @PostConstruct 注解一个方法，在方法内为 static 静态成员赋值</p></li><li><p>使用 Spring 框架工具类获取 bean，定义成局部变量使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> SpringApplicationContextUtil.getBean(<span class="string">&quot;component&quot;</span>);</span><br><span class="line">      component.callTestMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="http://jessehzx.top/2018/03/18/spring-autowired-static-field/">http://jessehzx.top/2018/03/18/spring-autowired-static-field/</a></p><hr><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>名称：@PropertySource</p><p>类型：类注解</p><p>作用：加载 properties 文件中的属性值</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:filename.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;propertiesAttributeName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String attributeName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>不支持 * 通配符，加载后，所有 Spring 控制的 bean 中均可使用对应属性值，加载多个需要用 <code>&#123;&#125; 和 ,</code> 隔开</li></ul><p>相关属性</p><ul><li><p>value（默认）：设置加载的 properties 文件名</p></li><li><p>ignoreResourceNotFound：如果资源未找到，是否忽略，默认为 false</p></li></ul><hr><h4 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h4><h5 id="依赖加载"><a href="#依赖加载" class="headerlink" title="依赖加载"></a>依赖加载</h5><p>@DependsOn</p><ul><li><p>名称：@DependsOn</p></li><li><p>类型：类注解、方法注解</p></li><li><p>作用：控制 bean 的加载顺序，使其在指定 bean 加载完毕后再加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;beanId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>配置在方法上，使 @DependsOn 指定的 bean 优先于 @Bean 配置的 bean 进行加载</p></li><li><p>配置在类上，使 @DependsOn 指定的 bean 优先于当前类中所有 @Bean 配置的 bean 进行加载</p></li><li><p>配置在类上，使 @DependsOn 指定的 bean 优先于 @Component 等配置的 bean 进行加载</p></li></ul></li><li><p>相关属性</p><ul><li>value（默认）：设置当前 bean 所依赖的 bean 的 id</li></ul></li></ul><p>@Order</p><ul><li><p>名称：@Order</p></li><li><p>类型：<strong>配置类注解</strong></p></li><li><p>作用：控制配置类的加载顺序，值越小越先加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>@Lazy</p><ul><li><p>名称：@Lazy</p></li><li><p>类型：类注解、方法注解</p></li><li><p>作用：控制 bean 的加载时机，使其延迟加载，获取的时候加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>@DependsOn</p><ul><li><p>微信订阅号，发布消息和订阅消息的 bean 的加载顺序控制（先开订阅，再发布）</p></li><li><p>双 11 活动，零点前是结算策略 A，零点后是结算策略 B，策略 B 操作的数据为促销数据，策略 B 加载顺序与促销数据的加载顺序</p></li></ul><p>@Lazy</p><ul><li>程序灾难出现后对应的应急预案处理是启动容器时加载时机</li></ul><p>@Order</p><ul><li>多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制</li></ul><hr><h4 id="整合资源"><a href="#整合资源" class="headerlink" title="整合资源"></a>整合资源</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>名称：@Import</p><p>类型：类注解</p><p>作用：导入第三方 bean 作为 Spring 控制的资源，这些类都会被 Spring 创建并放入 ioc 容器</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherClassName.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Import 注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定</li><li>在被导入的类中可以继续使用 @Import 导入其他资源</li><li>@Bean 所在的类可以使用导入的形式进入 Spring 容器，无需声明为 bean</li></ul><hr><h5 id="Druid-1"><a href="#Druid-1" class="headerlink" title="Druid"></a>Druid</h5><ul><li><p>加载资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;service&quot;,&quot;dao&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(JDBCConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">System.out.println(dataSource);</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h5><p>Spring 接管 Junit 的运行权，使用 Spring 专用的 Junit 类加载器，为 Junit 测试用例设定对应的 Spring 容器</p><p>注意：</p><ul><li><p>从 Spring5.0 以后，要求 Junit 的版本必须是4.12及以上</p></li><li><p>Junit 仅用于单元测试，不能将 Junit 的测试类配置成 Spring 的 bean，否则该配置将会被打包进入工程中</p></li></ul><p>test &#x2F; java &#x2F; service &#x2F; UserServiceTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定spring专用的类加载器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//设定加载的spring上下文对应的配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Mike&quot;</span>, account.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>ApplicationContext：</p><ol><li><p>ApplicationContext 是一个接口，提供了访问 Spring 容器的 API</p></li><li><p>ClassPathXmlApplicationContext 是一个类，实现了上述功能</p></li><li><p>ApplicationContext 的顶层接口是 BeanFactory</p></li><li><p>BeanFactory 定义了 bean 相关的最基本操作</p></li><li><p>ApplicationContext 在 BeanFactory 基础上追加了若干新功能</p></li></ol><p><strong>ApplicationContext 和 BeanFactory对比：</strong></p><ul><li><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器</p></li><li><p>BeanFactory 是 Spring 里面最底层的接口，是 IoC 的核心，定义了 IoC 的基本功能，包含了各种 Bean 的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext 接口作为 BeanFactory 的子类，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承 MessageSource，因此支持国际化</li><li>资源文件访问，如 URL 和文件（ResourceLoader）。</li><li>载入多个（有继承关系）上下文（即加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li><li>提供在监听器中注册 bean 的事件</li></ul></li><li><p>BeanFactory 创建的 bean 采用延迟加载形式，只有在使用到某个 Bean 时（调用 getBean），才对该 Bean 进行加载实例化（Spring 早期使用该方法获取 bean），这样就不能提前发现一些存在的 Spring 的配置问题；ApplicationContext 是在容器启动时，一次性创建了所有的 Bean，容器启动时，就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入</p></li><li><p>ApplicationContext 启动后预载入所有的单实例 Bean，所以程序启动慢，运行时速度快</p></li><li><p>两者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</p></li></ul><p>FileSystemXmlApplicationContext：加载文件系统中任意位置的配置文件，而 ClassPathXmlAC 只能加载类路径下的配置文件</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>BeanFactory 的成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>区分是 FactoryBean 还是创建的 Bean，加上 &amp; 代表是工厂，getBean 将会返回工厂</li><li>FactoryBean：如果某个 bean 的配置非常复杂，或者想要使用编码的形式去构建它，可以提供一个构建该 bean 实例的工厂，这个工厂就是 FactoryBean 接口实现类，FactoryBean 接口实现类也是需要 Spring 管理<ul><li>这里产生两种对象，一种是 FactoryBean 接口实现类（IOC 管理），另一种是 FactoryBean 接口内部管理的对象</li><li>获取 FactoryBean 接口实现类，使用 getBean 时传的 beanName 需要带 &amp; 开头</li><li>获取 FactoryBean 内部管理的对象，不需要带 &amp; 开头</li></ul></li></ul><p>BeanFactory 的基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(res);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>FactoryBean：对单一的 bean 的初始化过程进行封装，达到简化配置的目的</p><p>FactoryBean与 BeanFactory 区别：</p><ul><li><p>FactoryBean：封装单个 bean 的创建过程，就是工厂的 Bean</p></li><li><p>BeanFactory：Spring 容器顶层接口，定义了 bean 相关的获取操作</p></li></ul><p>代码实现：</p><ul><li><p>FactoryBean，实现类一般是 MapperFactoryBean，创建 DAO 层接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EquipmentDaoImplFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//获取Bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EquipmentDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//获取bean的类型</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//是否单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MapperFactoryBean 继承 SqlSessionDaoSupport，可以获取 SqlSessionTemplate，完成 MyBatis 的整合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"><span class="comment">// 获取 SqlSessionTemplate 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate == <span class="literal">null</span> || </span><br><span class="line">        sqlSessionFactory != <span class="built_in">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><ul><li><p>DAO 层 UserDao、AccountDao、BookDao、EquipmentDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;<span class="comment">//...........BookDao等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h5><p>名称：TypeFilter</p><p>类型：<strong>接口</strong></p><p>作用：自定义类型过滤器</p><p>示例：</p><ul><li><p>config &#x2F; filter &#x2F; MyTypeFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">    * metadataReaderFactory:可以获取到任何其他类的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//加载的类满足要求，匹配成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取当前类注解的信息</span></span><br><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">am</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line"><span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line"><span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过类的元数据获取类的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classMetadata.getClassName();</span><br><span class="line">        <span class="comment">//如果加载的类名满足过滤器要求，返回匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(className.equals(<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>))&#123;</span><br><span class="line">       <span class="comment">//返回true表示匹配成功，返回false表示匹配失败。此处仅确认匹配结果，不会确认是排除还是加入，排除/加入由配置项决定，与此处无关</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//设置排除bean，排除的规则是自定义规则（FilterType.CUSTOM），具体的规则定义为MyTypeFilter</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type= FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">                classes = MyTypeFilter.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="导入器"><a href="#导入器" class="headerlink" title="导入器"></a>导入器</h4><p>bean 只有通过配置才可以进入 Spring 容器，被 Spring 加载并控制</p><ul><li><p>配置 bean 的方式如下：</p><ul><li>XML 文件中使用 <bean/> 标签配置</li><li>使用 @Component 及衍生注解配置</li></ul></li></ul><p>导入器可以快速高效导入大量 bean，替代 @Import({a.class,b.class})，无需在每个类上添加 @Bean</p><p>名称： ImportSelector</p><p>类型：<strong>接口</strong></p><p>作用：自定义bean导入器</p><ul><li><p>selector &#x2F; MyImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">//      1.编程形式加载一个类</span></span><br><span class="line"><span class="comment">//      return new String[]&#123;&quot;dao.impl.BookDaoImpl&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">//      ResourceBundle bundle = ResourceBundle.getBundle(&quot;import&quot;);</span></span><br><span class="line"><span class="comment">//      String className = bundle.getString(&quot;className&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      3.加载import.properties文件中的多个类名</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;import&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> className.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>import.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#3.加载import.properties文件中的多个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl,dao.impl.AccountDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#4.导入包中的所有类</span></span><br><span class="line"><span class="attr">path</span>=<span class="string">dao.impl.*</span></span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;dao&quot;,&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="注册器"><a href="#注册器" class="headerlink" title="注册器"></a>注册器</h4><p>可以取代 ComponentScan 扫描器</p><p>名称：ImportBeanDefinitionRegistrar</p><p>类型：<strong>接口</strong></p><p>作用：自定义 bean 定义注册器</p><ul><li><p>registrar &#x2F; MyImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata:当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类，把所有需要添加到容器中的bean调用registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//自定义注册器</span></span><br><span class="line">        <span class="comment">//1.开启类路径bean定义扫描器，需要参数bean定义注册器BeanDefinitionRegistry，需要制定是否使用默认类型过滤器</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//2.添加包含性加载类型过滤器（可选，也可以设置为排除性加载类型过滤器）</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">TypeFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//所有匹配全部成功，此处应该添加实际的业务判定条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置扫描路径</span></span><br><span class="line">        scanner.addExcludeFilter(tf);<span class="comment">//排除</span></span><br><span class="line">        scanner.scan(<span class="string">&quot;dao&quot;</span>,<span class="string">&quot;service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>通过创建类<strong>继承相应的处理器的接口</strong>，重写后置处理的方法，来实现<strong>拦截 Bean 的生命周期</strong>来实现自己自定义的逻辑</p><p>BeanPostProcessor：bean 后置处理器，bean 创建对象初始化前后进行拦截工作的</p><p>BeanFactoryPostProcessor：beanFactory 的后置处理器</p><ul><li><pre><code>    加载时机：在 BeanFactory 初始化之后调用，来定制和修改 BeanFactory 的内容；所有的 bean 定义已经保存加载到 beanFactory，但是 bean 的实例还未创建</code></pre></li><li><pre><code>    执行流程：</code></pre><ul><li>ioc 容器创建对象</li><li>invokeBeanFactoryPostProcessors(beanFactory)：执行 BeanFactoryPostProcessor<ul><li>在 BeanFactory 中找到所有类型是 BeanFactoryPostProcessor 的组件，并执行它们的方法</li><li>在初始化创建其他组件前面执行</li></ul></li></ul></li></ul><p>BeanDefinitionRegistryPostProcessor：</p><ul><li><p>加载时机：在所有 bean 定义信息将要被加载，但是 bean 实例还未创建，优先于 BeanFactoryPostProcessor 执行；利用 BeanDefinitionRegistryPostProcessor 给容器中再额外添加一些组件</p></li><li><p>执行流程：</p><ul><li>ioc 容器创建对象</li><li>refresh() → invokeBeanFactoryPostProcessors(beanFactory)</li><li>从容器中获取到所有的 BeanDefinitionRegistryPostProcessor 组件<ul><li>依次触发所有的 postProcessBeanDefinitionRegistry() 方法</li><li>再来触发 postProcessBeanFactory() 方法</li></ul></li></ul></li></ul><hr><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><h5 id="基本概述-1"><a href="#基本概述-1" class="headerlink" title="基本概述"></a>基本概述</h5><p>ApplicationListener：监听容器中发布的事件，完成事件驱动模型开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt;</span><br></pre></td></tr></table></figure><p>所以监听 ApplicationEvent 及其下面的子事件</p><p>应用监听器步骤：</p><ul><li><pre><code>  写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）</code></pre></li><li><pre><code>  把监听器加入到容器 @Component</code></pre></li><li><pre><code>  只要容器中有相关事件的发布，就能监听到这个事件；*   ContextRefreshedEvent：容器刷新完成（所有 bean 都完全创建）会发布这个事件*   ContextClosedEvent：关闭容器会发布这个事件</code></pre></li><li><pre><code>  发布一个事件：`applicationContext.publishEvent()`</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt; &#123;</span><br><span class="line"><span class="comment">//当容器中发布此事件以后，方法触发</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;收到事件：&quot;</span> + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>ContextRefreshedEvent 事件：</p><ul><li><p>容器初始化过程中执行 <code>initApplicationEventMulticaster()</code>：初始化事件多播器</p><ul><li>先去容器中查询 <code>id = applicationEventMulticaster</code> 的组件，有直接返回</li><li>没有就执行 <code>this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)</code> 并且加入到容器中</li><li>以后在其他组件要派发事件，自动注入这个 applicationEventMulticaster</li></ul></li><li><p>容器初始化过程执行 <strong>registerListeners()</strong> 注册监听器</p><ul><li>从容器中获取所有监听器：<code>getBeanNamesForType(ApplicationListener.class, true, false)</code></li><li>将 listener 注册到 ApplicationEventMulticaster</li></ul></li><li><p>容器刷新完成：finishRefresh() → publishEvent(new ContextRefreshedEvent(this))</p><p>发布 ContextRefreshedEvent 事件：</p><ul><li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li><li>multicastEvent 派发事件<ul><li>获取到所有的 ApplicationListener</li><li>遍历 ApplicationListener<ul><li>如果有 Executor，可以使用 Executor 异步派发 <code>Executor executor = getTaskExecutor()</code></li><li>没有就同步执行 listener 方法 <code>invokeListener(listener, event)</code>，拿到 listener 回调 onApplicationEvent</li></ul></li></ul></li></ul></li></ul><p>容器关闭会发布 ContextClosedEvent</p><hr><h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><p>注解：@EventListener</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(classes=&#123;ApplicationEvent.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(ApplicationEvent event)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;UserService。。监听到的事件：&quot;</span> + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：使用 EventListenerMethodProcessor 处理器来解析方法上的 @EventListener，Spring 扫描使用注解的方法，并为之创建一个监听对象</p><p>SmartInitializingSingleton 原理：afterSingletonsInstantiated()</p><ul><li><pre><code>    IOC 容器创建对象并 refresh()</code></pre></li><li><pre><code>    finishBeanFactoryInitialization(beanFactory)：初始化剩下的单实例 bean</code></pre><ul><li>先创建所有的单实例 bean：getBean()</li><li>获取所有创建好的单实例 bean，判断是否是 SmartInitializingSingleton 类型的，如果是就调用 afterSingletonsInstantiated()</li></ul></li></ul><hr><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="基本概述-2"><a href="#基本概述-2" class="headerlink" title="基本概述"></a>基本概述</h3><p>AOP（Aspect Oriented Programing）：面向切面编程，一种编程<strong>范式</strong>，指导开发者如何组织程序结构</p><p>AOP 弥补了 OOP 的不足，基于 OOP 基础之上进行横向开发：</p><ul><li><p>uOOP 规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型</p></li><li><p>uAOP 程序开发主要关注基于 OOP 开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分），将软件开发由手工制作走向半自动化&#x2F;全自动化阶段，实现“插拔式组件体系结构”搭建</p></li></ul><p>AOP 作用：</p><ul><li><p>提高代码的可重用性</p></li><li><p>业务代码编码更简洁</p></li><li><p>业务代码维护更高效</p></li><li><p>业务功能扩展更便捷</p></li></ul><hr><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h4><ul><li><p>Joinpoint（连接点）：就是方法</p></li><li><p>Pointcut（切入点）：就是挖掉共性功能的方法</p></li><li><p>Advice（通知）：就是共性功能，最终以一个方法的形式呈现</p></li><li><p>Aspect（切面）：就是共性功能与挖的位置的对应关系</p></li><li><p>Target（目标对象）：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的</p></li><li><p>Weaving（织入）：就是将挖掉的功能回填的动态过程</p></li><li><p>Proxy（代理）：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现</p></li><li><p>Introduction（引入&#x2F;引介）：就是对原始对象无中生有的添加成员变量或成员方法</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png"></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5.png"></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5.png"></p><hr><h4 id="入门项目-1"><a href="#入门项目-1" class="headerlink" title="入门项目"></a>入门项目</h4><p>开发步骤：</p><ul><li><p>开发阶段</p><ul><li><p>制作程序</p></li><li><p>将非共性功能开发到对应的目标对象类中，并制作成切入点方法</p></li><li><p>将共性功能独立开发出来，制作成通知</p></li><li><p>在配置文件中，声明切入点</p></li><li><p>在配置文件中，声明切入点与通知间的关系（含通知类型），即切面</p></li></ul></li><li><p>运行阶段（AOP 完成）</p><ul><li><p>Spring 容器加载配置文件，监控所有配置的<strong>切入点</strong>方法的执行</p></li><li><p>当监控到切入点方法被运行，<strong>使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入</strong>，完成完整的代码逻辑并运行</p></li></ul></li></ul><ol><li><p>导入坐标 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>业务层抽取通用代码  service &#x2F; UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;共性功能&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aop.AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.制作通知类，在类中定义一个方法用于完成共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//共性功能抽取后职称独立的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;共性功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把通知加入spring容器管理，配置aop  applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--原始Spring控制资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>= <span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.配置共性功能成功spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.开启AOP命名空间: beans标签内--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4.配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--5.配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--6.配置切面（切入点与通知的关系）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--7.配置具体的切入点对应通知中那个操作方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;function&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//先输出共性功能，然后 user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="XML开发-1"><a href="#XML开发-1" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>Aspect（切面）用于描述切入点与通知间的关系，是 AOP 编程中的一个概念</p><p>AspectJ 是基于 java 语言对 Aspect 的实现</p><hr><h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>标签：<a href="aop:config">aop:config</a>，<beans> 的子标签</p><p>作用：设置 AOP</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个beans标签中可以配置多个aop:config标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="pointcut"><a href="#pointcut" class="headerlink" title="pointcut"></a>pointcut</h5><p>标签：<a href="aop:pointcut">aop:pointcut</a>，归属于 aop:config 标签和 aop:aspect 标签</p><p>作用：设置切入点</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>一个 aop:config 标签中可以配置多个 aop:pointcut 标签，且该标签可以配置在 aop:aspect 标签内</li></ul><p>属性：</p><ul><li><p>id ：识别切入点的名称</p></li><li><p>expression ：切入点表达式</p></li></ul><hr><h5 id="aspect"><a href="#aspect" class="headerlink" title="aspect"></a>aspect</h5><p>标签：<a href="aop:aspect">aop:aspect</a>，aop:config 的子标签</p><p>作用：设置具体的 AOP 通知对应的切入点（切面）</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:config标签中可以配置多个aop:aspect标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>ref ：通知所在的 bean 的 id</li></ul><hr><h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点描述的是某个方法</p><p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p><hr><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字(访问修饰符  返回值  包名.类名.方法名(参数)异常名)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配UserService中只含有一个参数的findById方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure><p>格式解析：</p><ul><li>关键字：描述表达式的匹配模式（参看关键字列表）</li><li>访问修饰符：方法的访问控制权限修饰符</li><li>类名：方法所在的类（此处可以配置接口名称）</li><li>异常：方法定义中指定抛出的异常</li></ul><p>关键字：</p><ul><li><p>execution ：匹配执行指定方法</p></li><li><p>args ：匹配带有指定参数类型的方法</p></li><li><p>within、this、target、@within、@target、@args、@annotation、bean、reference pointcut等</p></li></ul><p>通配符：</p><ul><li><p>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.seazean包下的任意包中的UserService类或接口中所有find开头的带有一个任意参数的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.seazean.*.UserService.find*(*)</span><br></pre></td></tr></table></figure></li><li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com包下的任意包中的UserService类或接口中所有名称为findById参数任意数量和类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure></li><li><p>+：专用于匹配子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配任意包下的Service结尾的类或者接口的子类或者实现类</span></span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ul><p>逻辑运算符：</p><ul><li>&amp;&amp;：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配</li><li>||：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配</li><li>! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(..))<span class="comment">//前三个都是匹配全部</span></span><br><span class="line">execution(* *..*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..)) </span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.User*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*Service.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.UserService.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.find*(..))<span class="comment">//find开头</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.*Id(..))<span class="comment">//I</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,*))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById())</span><br><span class="line">execution(List com.seazean.service.*Service+.findAll(..))</span><br></pre></td></tr></table></figure><hr><h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>XML 配置规则：</p><ul><li><p>企业开发命名规范严格遵循规范文档进行</p></li><li><p>先为方法配置局部切入点，再抽取类中公共切入点，最后抽取全局切入点</p></li><li><p>代码走查过程中检测切入点是否存在越界性包含</p></li><li><p>代码走查过程中检测切入点是否存在非包含性进驻</p></li><li><p>设定 AOP 执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配（不绝对正确：加进一个不该加的，删去一个不该删的相当于结果不变）</p></li><li><p>设定完毕的切入点如果发生调整务必进行回归测试</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.配置公共切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2.配置局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用公共切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3.直接配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p>AOP 的通知类型共5种：前置通知，后置通知、返回后通知、抛出异常后通知、环绕通知</p><h6 id="before"><a href="#before" class="headerlink" title="before"></a>before</h6><p>标签：<a href="aop:before">aop:before</a>，aop:aspect的子标签</p><p>作用：设置前置通知</p><ul><li><strong>前置通知</strong>：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行</li><li>应用：数据校验</li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:before标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><h6 id="after"><a href="#after" class="headerlink" title="after"></a>after</h6><p>标签：<a href="aop:after">aop:after</a>，aop:aspect的子标签</p><p>作用：设置后置通知</p><ul><li><p><strong>后置通知</strong>：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知</p></li><li><p>应用：现场清理</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><h6 id="after-r"><a href="#after-r" class="headerlink" title="after-r"></a>after-r</h6><p>标签：<a href="aop:after-returning">aop:after-returning</a>，aop:aspect的子标签</p><p>作用：设置返回后通知</p><ul><li><p><strong>返回后通知</strong>：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行</p></li><li><p>应用：返回值相关数据处理</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-returning标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>method：在通知类中设置当前通知类别对应的方法</li><li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li><li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li><li>returning：设置接受返回值的参数，与通知类中对应方法的参数一致</li></ul><h6 id="after-t"><a href="#after-t" class="headerlink" title="after-t"></a>after-t</h6><p>标签：<a href="aop:after-throwing">aop:after-throwing</a>，aop:aspect的子标签</p><p>作用：设置抛出异常后通知</p><ul><li><strong>抛出异常后通知</strong>：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行</li><li>应用：对原始方法中出现的异常信息进行处理</li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-throwing标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>method：在通知类中设置当前通知类别对应的方法</li><li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li><li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li><li>throwing：设置接受异常对象的参数，与通知类中对应方法的参数一致</li></ul><h6 id="around"><a href="#around" class="headerlink" title="around"></a>around</h6><p>标签：<a href="aop:around">aop:around</a>，aop:aspect的子标签</p><p>作用：设置环绕通知</p><ul><li><p><strong>环绕通知</strong>：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行</p></li><li><p>应用：功能强大，可以做任何事情</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:around标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><p>环绕通知的开发方式（参考通知顺序章节）：</p><ul><li><p>环绕通知是<strong>在原始方法的前后添加功能</strong>，在环绕通知中，存在对原始方法的显式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知方法相关说明：</p><ul><li><p>方法须设定 Object 类型的返回值，否则会<strong>拦截</strong>原始方法的返回。如果原始方法返回值类型为 void，通知方法也可以设定返回值类型为 void，最终返回 null</p></li><li><p>方法需在第一个参数位置设定 ProceedingJoinPoint 对象，通过该对象调用 proceed() 方法，实现<strong>对原始方法的调用</strong>。如省略该参数，原始方法将无法执行</p></li><li><p>使用 proceed() 方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出 Throwable 对象，封装原始方法中可能出现的异常信息</p></li></ul></li></ul><hr><h5 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h5><p>当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准。</p><ul><li><p>AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void after()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>after...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterReturing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterReturing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterThrowing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterThrowing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public Object around(ProceedingJoinPoint pjp) &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around before...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">       //对原始方法的调用</span></span><br><span class="line"><span class="string">        Object ret = pjp.proceed();</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around after...<span class="string">&quot;+ret);</span></span><br><span class="line"><span class="string">       return ret;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml  <strong>顺序执行</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>第一种方式：</p><ul><li><p>设定通知方法第一个参数为 JoinPoint，通过该对象调用 getArgs() 方法，获取原始方法运行的参数数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的通知均可以获取参数，环绕通知使用ProceedingJoinPoint.getArgs()方法</p></li></ul><p>第二种方式：</p><ul><li><p>设定切入点表达式为通知方法传递参数（锁定通知变量名）</p></li><li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p></li><li><p>解释：</p><ul><li><code>&amp;amp</code> 代表并且 &amp;</li><li>输出结果：a &#x3D; param1   b &#x3D; param2</li></ul></li></ul><p>第三种方式：</p><ul><li><p>设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）</p></li><li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%B8%89.png"></p></li><li><p>解释：输出结果 a &#x3D; param2   b &#x3D; param1</p></li></ul><hr><h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>环绕通知和返回后通知可以获取返回值，后置通知不一定，其他类型获取不到</p><p>第一种方式：适用于返回后通知（after-returning）</p><ul><li><p>设定返回值变量名</p></li><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return:&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第二种：适用于环绕通知（around）</p><ul><li><p>在通知类的方法中调用原始方法获取返回值</p></li><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> userService.save();</span><br><span class="line">       System.out.println(<span class="string">&quot;app.....&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h6><p>环绕通知和抛出异常后通知可以获取异常，后置通知不一定，其他类型获取不到</p><p>第一种：适用于返回后通知（after-throwing）</p><ul><li><p>设定异常对象变量名</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(t.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第二种：适用于环绕通知（around）</p><ul><li>在通知类的方法中调用原始方法捕获异常</li></ul><ul><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：try……catch……捕获异常后，ret为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//对此处调用进行try……catch……捕获异常，或抛出异常</span></span><br><span class="line">    <span class="comment">/* try &#123;</span></span><br><span class="line"><span class="comment">            ret = pjp.proceed();</span></span><br><span class="line"><span class="comment">        &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;around exception...&quot; + throwable.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userService.delete();</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="获取全部"><a href="#获取全部" class="headerlink" title="获取全部"></a>获取全部</h6><ul><li><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + i + <span class="string">&quot;,&quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service update running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service delete running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        <span class="comment">//通过JoinPoint参数获取调用原始方法所携带的参数</span></span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturing</span><span class="params">(Object ret)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturing...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>+t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对原始方法的调用</span></span><br><span class="line">            ret = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...exception....&quot;</span>+throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;around after...&quot;</span>+ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="comment">//        userService.save(666, 888);</span></span><br><span class="line"><span class="comment">//        int ret = userService.update();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;app.....&quot; + ret);</span></span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h4><p>AOP 注解简化 XML：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.png"></p><p>注意事项：</p><ol><li><p>切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法</p></li><li><p>引用切入点时必须使用方法调用名称，方法后面的 () 不能省略</p></li><li><p>切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用</p></li><li><p>可以在通知类型注解后添加参数，实现 XML 配置中的属性，例如 after-returning 后的 returning 性</p></li></ol><hr><h4 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h4><h5 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h5><p>开启 AOP 注解支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;aop,config,service&quot;</span>/&gt;</span><span class="comment">&lt;!--启动Spring扫描--&gt;</span></span><br></pre></td></tr></table></figure><p>开发步骤：</p><ol><li>导入坐标（伴随 spring-context 坐标导入已经依赖导入完成）</li><li>开启 AOP 注解支持</li><li>配置切面 @Aspect</li><li>定义专用的切入点方法，并配置切入点 @Pointcut</li><li>为通知方法配置通知类型及对应切入点 @Before</li></ol><h5 id="纯注解-1"><a href="#纯注解-1" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解：@EnableAspectJAutoProxy</p><p>位置：Spring 注解配置类定义上方</p><p>作用：设置当前类开启 AOP 注解驱动的支持，加载 AOP 注解</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="基本注解-1"><a href="#基本注解-1" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h5><p>注解：@Aspect</p><p>位置：类定义上方</p><p>作用：设置当前类为切面类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Pointcut-1"><a href="#Pointcut-1" class="headerlink" title="Pointcut"></a>Pointcut</h5><p>注解：@Pointcut</p><p>位置：方法定义上方</p><p>作用：使用当前方法名作为切入点引用名称</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* *(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）</p><h5 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h5><p>注解：@Before</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为前置通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">//joinPoint.getArgs();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>多个参数时，JoinPoint参数一定要在第一位</strong></p><h5 id="After"><a href="#After" class="headerlink" title="After"></a>After</h5><p>注解：@After</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为后置通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AfterR"><a href="#AfterR" class="headerlink" title="AfterR"></a>AfterR</h5><p>注解：@AfterReturning</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为返回后通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;pt()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊参数：</p><ul><li>returning ：设定使用通知方法参数<strong>接收</strong>返回值的变量名</li></ul><h5 id="AfterT"><a href="#AfterT" class="headerlink" title="AfterT"></a>AfterT</h5><p>注解：@AfterThrowing</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为异常后通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;pt()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊参数：</p><ul><li>throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名</li></ul><h5 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h5><p>注解：@Around</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为环绕通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>AOP 使用 XML 配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念，参照通知所配置的<strong>方法名字符串对应的编码值顺序</strong>，可以简单理解为字母排序</p><ul><li><p>同一个通知类中，相同通知类型以方法名排序为准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop001Log</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop002Exception</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同通知类中，以类名排序为准</p></li><li><p>使用 @Order 注解通过变更 bean 的加载顺序改变通知的加载顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">//先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(2)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice1</span> &#123;<span class="comment">//默认执行此通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDecorator</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//原始调用</span></span><br><span class="line">        userService.save();</span><br><span class="line">        <span class="comment">//增强功能（后置）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>JDKProxy 动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强，因为<strong>代理类继承Proxy</strong></p><p>静态代理和动态代理的区别：</p><ul><li>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</li><li>动态代理是程序在运行后通过反射创建字节码文件交由 JVM 加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceJDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceJDKProxy</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            userService.getClass().getClassLoader(),<span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">            userService.getClass().getInterfaces(),<span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;<span class="comment">//对原始方法执行进行拦截并增强</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB（Code Generation Library）：Code 生成类库 </p><p>CGLIB 特点：</p><ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li>CGLIB <strong>继承被代理类</strong>，如果代理类是 final 则不能实现</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-cglib.png"></p><ul><li><p>CGLIB 类</p><ul><li>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强，包括 Object 类中的方法（toString、hashCode）</li><li>返回值类型采用多态向下转型，所以需要设置父类类型</li></ul><p>需要对方法进行判断是否是 save，来选择性增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplCglibProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceCglibProxy</span><span class="params">(Class cls)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.设置Enhancer对象的父类是指定类型UserServerImpl</span></span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.设置回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method m, Object[] args, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//o是被代理出的类创建的对象，所以使用MethodProxy调用，并且是调用父类</span></span><br><span class="line">                <span class="comment">//通过调用父类的方法实现对原始方法的调用</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                <span class="comment">//后置增强内容,需要判断是都是save方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;I love Java&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//使用Enhancer对象创建对应的对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserService)enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> UserServiceCglibProxy.createUserServiceCglibProxy(UserServiceImpl.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="代理选择"><a href="#代理选择" class="headerlink" title="代理选择"></a>代理选择</h4><p>Spirng 可以通过配置的形式控制使用的代理形式，Spring 会先判断是否实现了接口，如果实现了接口就使用 JDK 动态代理，如果没有实现接口则使用 CGLIB 动态代理，通过配置可以修改为使用 CGLIB </p><ul><li><p>XML 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>XML 注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注解驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改为使用 cglib 创建代理对象</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>JDK 动态代理和 CGLIB 动态代理的区别：</p><ul><li>JDK 动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。</li><li>CGLIB 动态代理即使被代理的类没有实现接口也可以使用，因为 CGLIB 动态代理是使用继承被代理类的方式进行扩展</li><li>CGLIB 动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被 final 修饰的话，就不能进行代理</li></ul></li></ul><hr><h4 id="织入时机"><a href="#织入时机" class="headerlink" title="织入时机"></a>织入时机</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA.png" alt="AOP织入时机"></p><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>事务：数据库中多个操作合并在一起形成的操作序列，事务特征（ACID）</p><p>作用：</p><ul><li>当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）</li><li>当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）</li></ul><p>Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口</p><p>Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 <strong>Innodb 引擎</strong>，是支持事务的；如果 MySQL 使用 MyISAM 引擎，那从根上就是不支持事务的</p><p><strong>保证原子性</strong>：</p><ul><li>要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></li><li>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong> 实现，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</li><li>回滚日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</li></ul><hr><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p><strong>分布式事务</strong>：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高</p><p>在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</p><hr><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，也就是方法嵌套：</p><ul><li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p></li><li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外层事务 Service A 的 aMethod 调用内层 Service B 的 bMethod</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务则<strong>加入该事务</strong>；如果当前没有事务则创建一个新的事务<ul><li>内外层是相同的事务，在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚</li><li>工作流程：<ul><li>线程执行到 serviceA.aMethod() 时，其实是执行的代理 serviceA 对象的 aMethod</li><li>首先执行事务增强器逻辑（环绕增强），提取事务标签属性，检查当前线程是否绑定 connection 数据库连接资源，没有就调用 datasource.getConnection()，设置事务提交为手动提交 autocommit(false)</li><li>执行其他增强器的逻辑，然后调用 target 的目标方法 aMethod() 方法，进入 serviceB 的逻辑</li><li>serviceB 也是先执行事务增强器的逻辑，提取事务标签属性，但此时会检查到线程绑定了 connection，检查注解的传播属性，所以调用 DataSourceUtils.getConnection(datasource) 共享该连接资源，执行完相关的增强和 SQL 后，发现事务并不是当前方法开启的，可以直接返回上层</li><li>serviceA.aMethod() 继续执行，执行完增强后进行提交事务或回滚事务</li></ul></li></ul></li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则以非事务的方式继续运行</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则抛出异常</li></ul><p><strong>不支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起<ul><li>内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚</li><li>如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交</li></ul></li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： <strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起</li><li>TransactionDefinition.PROPAGATION_NEVER： <strong>以非事务方式运行</strong>，如果当前存在事务，则抛出异常</li></ul><p>其他情况：</p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务（两个事务没有关系）来运行<ul><li>如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC</li><li>如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback</li><li><strong>应用场景</strong>：在查询数据的时候要向数据库中存储一些日志，系统不希望存日志的行为影响到主逻辑，可以使用该传播</li></ul></li></ul><p>requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的</p><hr><h4 id="超时属性"><a href="#超时属性" class="headerlink" title="超时属性"></a>超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过该时间限制事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1</p><hr><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中</p><p>读操作为什么需要启用事务支持：</p><ul><li>MySQL  默认对每一个新建立的连接都启用了 <code>autocommit</code> 模式，在该模式下，每一个发送到 MySQL 服务器的 SQL 语句都会在一个<strong>单独</strong>的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务</li><li>执行多条查询语句，如果方法加上了 <code>@Transactional</code> 注解，这个方法执行的所有 SQL 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 <code>@Transactional</code>，每条 SQL 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出<strong>现读数据不一致的状态</strong></li></ul><hr><h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><h4 id="事务对象"><a href="#事务对象" class="headerlink" title="事务对象"></a>事务对象</h4><p>J2EE 开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p><p>Spring 为业务层提供了整套的事务解决方案：</p><ul><li><p>PlatformTransactionManager</p></li><li><p>TransactionDefinition</p></li><li><p>TransactionStatus</p></li></ul><hr><h4 id="PTM"><a href="#PTM" class="headerlink" title="PTM"></a>PTM</h4><p>PlatformTransactionManager，平台事务管理器实现类：</p><ul><li><p>DataSourceTransactionManager  适用于 Spring JDBC 或 MyBatis</p></li><li><p>HibernateTransactionManager  适用于 Hibernate3.0 及以上版本</p></li><li><p>JpaTransactionManager  适用于 JPA</p></li><li><p>JdoTransactionManager  适用于 JDO</p></li><li><p>JtaTransactionManager  适用于 JTA</p></li></ul><p>管理器：</p><ul><li><p>JPA（Java Persistence API）Java EE 标准之一，为 POJO 提供持久化标准规范，并规范了持久化开发的统一 API，符合 JPA 规范的开发可以在不同的 JPA 框架下运行</p><p><strong>非持久化一个字段</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure></li><li><p>JDO（Java Data Object）是 Java 对象持久化规范，用于存取某种数据库中的对象，并提供标准化 API。JDBC 仅针对关系数据库进行操作，JDO 可以扩展到关系数据库、XML、对象数据库等，可移植性更强</p></li><li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与 JDBC 相比，JDBC 事务则被限定在一个单一的数据库连接，而一个 JTA 事务可以有多个参与者，比如 JDBC 连接、JDO 都可以参与到一个 JTA 事务中</p></li></ul><p>此接口定义了事务的基本操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus getTransaction(TransactionDefinition definition)</td><td>获取事务</td></tr><tr><td>void commit(TransactionStatus status)</td><td>提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>回滚事务</td></tr></tbody></table><hr><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>TransactionDefinition 此接口定义了事务的基本信息：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>获取事务定义名称</td></tr><tr><td>boolean isReadOnly()</td><td>获取事务的读写属性</td></tr><tr><td>int getIsolationLevel()</td><td>获取事务隔离级别</td></tr><tr><td>int getTimeout()</td><td>获取事务超时时间</td></tr><tr><td>int getPropagationBehavior()</td><td>获取事务传播行为特征</td></tr></tbody></table><hr><h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean isNewTransaction()</td><td>获取事务是否处于新开始事务状态</td></tr><tr><td>voin flush()</td><td>刷新事务状态</td></tr><tr><td>boolean isCompleted()</td><td>获取事务是否处于已完成状态</td></tr><tr><td>boolean hasSavepoint()</td><td>获取事务是否具有回滚储存点</td></tr><tr><td>boolean isRollbackOnly()</td><td>获取事务是否处于回滚状态</td></tr><tr><td>void setRollbackOnly()</td><td>设置事务处于回滚状态</td></tr></tbody></table><hr><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>编程式、声明式（XML）、声明式（注解）</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>银行转账业务</p><ul><li><p>包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DAO层接口：AccountDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">//入账操作name:入账用户名money:入账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出账操作name:出账用户名money:出账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层接口提供转账操作：AccountService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"><span class="comment">//转账操作outName:出账用户名inName:入账用户名money:转账金额</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">accountDao.inMoney(outName,money);</span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射配置文件：dao &#x2F; AccountDao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;inMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money + #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;outMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money - #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.2.185:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li><li><p>核心配置文件：applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描映射配置和Dao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ap...xml&quot;</span>);</span><br><span class="line"><span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> (AccountService) ctx.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">accountService.transfer(<span class="string">&quot;Jock1&quot;</span>, <span class="string">&quot;Jock2&quot;</span>, <span class="number">100d</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="编程式-1"><a href="#编程式-1" class="headerlink" title="编程式"></a>编程式</h4><p>编程式事务就是代码显式的给出事务的开启和提交</p><ul><li><p>修改业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建事务管理器，</span></span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//2.为事务管理器设置与数据层相同的数据源</span></span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//3.创建事务定义对象</span></span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="comment">//4.创建事务状态对象，用于控制事务执行，【开启事务】</span></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    accountDao.inMoney(inName,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;    <span class="comment">//模拟业务层事务过程中出现错误</span></span><br><span class="line">    accountDao.outMoney(outName,money);</span><br><span class="line">    <span class="comment">//5.提交事务</span></span><br><span class="line">    dstm.commit(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="AOP改造"><a href="#AOP改造" class="headerlink" title="AOP改造"></a>AOP改造</h4><ul><li><p>将业务层的事务处理功能抽取出来制作成 AOP 通知，利用环绕通知运行期动态织入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">tx</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">        <span class="comment">//事务定义</span></span><br><span class="line">        <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="comment">//事务状态</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span>  ptm.getTransaction(td);</span><br><span class="line">        <span class="comment">//pjp.getArgs()标准写法，也可以不加，同样可以传递参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        ptm.commit(ts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml，要开启 AOP 空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改bean的属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置AOP通知类，并注入dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.TxAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用环绕通知将通知类织入到原始业务对象执行过程中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..transfer(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;tx&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><h4 id="XML-2"><a href="#XML-2" class="headerlink" title="XML"></a>XML</h4><h5 id="tx使用"><a href="#tx使用" class="headerlink" title="tx使用"></a>tx使用</h5><p>删除 TxAdvice 通知类，开启 tx 命名空间，配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义事务管理的通知类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义控制的事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用aop:advisor在AOP配置中引用事务专属通知类，底层invoke调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>aop:advice 与 aop:advisor 区别<ul><li><p>aop:advice 配置的通知类可以是普通 Java 对象，不实现接口，也不使用继承关系</p></li><li><p>aop:advisor 配置的通知类必须实现通知接口，底层 invoke 调用</p><ul><li><p>MethodBeforeAdvice</p></li><li><p>AfterReturningAdvice</p></li><li><p>ThrowsAdvice</p></li></ul></li></ul></li></ul><p>pom.xml 文件引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="tx配置"><a href="#tx配置" class="headerlink" title="tx配置"></a>tx配置</h5><h6 id="advice"><a href="#advice" class="headerlink" title="advice"></a>advice</h6><p>标签：tx:advice，beans 的子标签</p><p>作用：专用于声明事务通知</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>id：用于配置 aop 时指定通知器的 id</li><li>transaction-manager：指定事务管理器 bean</li></ul><h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><p>类型：tx:attributes，tx:advice 的子标签</p><p>作用：定义通知属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="method"><a href="#method" class="headerlink" title="method"></a>method</h6><p>标签：tx:method，tx:attribute 的子标签</p><p>作用：设置具体的事务属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标准格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span><span class="comment">&lt;!--标准--&gt;</span></span><br></pre></td></tr></table></figure><p>说明：通常事务属性会配置多个，包含 1 个读写的全事务属性，1 个只读的查询类事务属性</p><p>属性：</p><ul><li>name：待添加事务的方法名表达式（支持 * 通配符）</li><li>read-only：设置事务的读写属性，true 为只读，false 为读写</li><li>timeout：设置事务的超时时长，单位秒，-1 为无限长</li><li>isolation：设置事务的隔离界别，该隔离级设定是基于 Spring 的设定，非数据库端</li><li>no-rollback-for：设置事务中不回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>rollback-for：设置事务中必回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>propagation：设置事务的传播行为</li></ul><hr><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><h6 id="XML-3"><a href="#XML-3" class="headerlink" title="XML"></a>XML</h6><p>标签：tx:annotation-driven</p><p>归属：beans 标签</p><p>作用：开启事务注解驱动，并指定对应的事务管理器</p><p>范例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h6 id="纯注解-2"><a href="#纯注解-2" class="headerlink" title="纯注解"></a>纯注解</h6><p>名称：@EnableTransactionManagement</p><p>类型：类注解，Spring 注解配置类上方</p><p>作用：开启注解驱动，等同 XML 格式中的注解驱动</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//自动装配</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h5><p>名称：@Transactional</p><p>类型：方法注解，类注解，接口注解</p><p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    readOnly = false,</span></span><br><span class="line"><span class="meta">    timeout = -1,</span></span><br><span class="line"><span class="meta">    isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">    rollbackFor = &#123;ArithmeticException.class, IOException.class&#125;,</span></span><br><span class="line"><span class="meta">    noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRES_NEW</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> addAccount&#123;&#125; </span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效</p></li><li><p>不推荐在接口上使用 <code>@Transactional</code> 注解</p><p>原因：在接口上使用注解，<strong>只有在使用基于接口的代理（JDK）时才会生效，因为注解是不能继承的</strong>，这就意味着如果正在使用基于类的代理（CGLIB）时，那么事务的设置将不能被基于类的代理所识别</p></li><li><p>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</p></li><li><p>默认情况下，事务只有遇到运行期异常 和 Error 会导致事务回滚，但是在遇到检查型（Checked）异常时不会回滚</p><ul><li>继承自 RuntimeException 或 error 的是非检查型异常，比如空指针和索引越界，而继承自 Exception 的则是检查型异常，比如 IOException、ClassNotFoundException，RuntimeException 本身继承 Exception</li><li>非检查型类异常可以不用捕获，而检查型异常则必须用 try 语句块把异常交给上级方法，这样事务才能有效</li></ul></li></ul><p><strong>事务不生效的问题</strong></p><ul><li><p>情况 1：确认创建的 MySQL 数据库表引擎是 InnoDB，MyISAM 不支持事务</p></li><li><p>情况 2：注解到 protected，private 方法上事务不生效，但不会报错</p><p>原因：理论上而言，不用 public 修饰，也可以用 aop 实现事务的功能，但是方法私有化让其他业务无法调用</p><p>AopUtils.canApply：<code>methodMatcher.matches(method, targetClass) --true--&gt; return true</code><br><code>TransactionAttributeSourcePointcut.matches()</code> ，AbstractFallbackTransactionAttributeSource 中 getTransactionAttribute 方法调用了其本身的 computeTransactionAttribute 方法，当加了事务注解的方法不是 public 时，该方法直接返回 null，所以造成增强不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况 3：注解所在的类没有被加载成 Bean</p></li><li><p>情况 4：在业务层捕捉异常后未向上抛出，事务不生效</p><p>原因：在业务层捕捉并处理了异常（try..catch）等于把异常处理掉了，Spring 就不知道这里有错，也不会主动去回滚数据，推荐做法是在业务层统一抛出异常，然后在控制层统一处理</p></li><li><p>情况 5：遇到检测异常时，也无法回滚</p><p>原因：Spring 的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。想针对检测异常进行事务回滚，可以在 @Transactional 注解里使用 rollbackFor 属性明确指定异常</p></li><li><p>情况 6：Spring 的事务传播策略在<strong>内部方法</strong>调用时将不起作用，在一个 Service 内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务，事务注解要加到调用方法上才生效</p><p>原因：Spring 的事务都是使用 AOP 代理的模式，动态代理 invoke 后会调用原始对象，而原始对象在去调用方法时是不会触发拦截器，就是<strong>一个方法调用本对象的另一个方法</strong>，所以事务也就无法生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注解添加在update方法上无效，需要添加到add()方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况 7：注解在接口上，代理对象是 CGLIB</p></li></ul><hr><h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><ul><li><p>Dao 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">//对当前方法添加事务，该配置将替换接口的配置</span></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = false,</span></span><br><span class="line"><span class="meta">        timeout = -1,</span></span><br><span class="line"><span class="meta">        isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;&#125;,//java.lang.ArithmeticException.class, IOException.class</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span> &#123;</span><br><span class="line">        accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加文件 Spring.config、Mybatis.config、JDBCConfig (参考ioc_Mybatis)、TransactionManagerConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><p>Spring 模板对象：TransactionTemplate、JdbcTemplate、RedisTemplate、RabbitTemplate、JmsTemplate、HibernateTemplate、RestTemplate</p><ul><li><p>JdbcTemplate：提供标准的 sql 语句操作API</p></li><li><p>NamedParameterJdbcTemplate：提供标准的具名 sql 语句操作API</p></li><li><p>RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMoney</span><span class="params">(Integer id, Double money)</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;account:id:&quot;</span>+id,money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Double <span class="title function_">findMondyById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">money</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;account:id:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Double</span>(money.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-RedisTemplate.png"></p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="XML-4"><a href="#XML-4" class="headerlink" title="XML"></a>XML</h3><p>三大对象：</p><ul><li><p><strong>BeanDefinition</strong>：是 Spring 中极其重要的一个概念，存储了 bean 对象的所有特征信息，如是否单例、是否懒加载、factoryBeanName 等，和 bean 的关系就是类与对象的关系，一个不同的 bean 对应一个 BeanDefinition</p></li><li><p><strong>BeanDefinationRegistry</strong>：存放 BeanDefination 的容器，是一种键值对的形式，通过特定的 Bean 定义的 id，映射到相应的 BeanDefination，<strong>BeanFactory 的实现类同样继承 BeanDefinationRegistry 接口</strong>，拥有保存 BD 的能力</p></li><li><p><strong>BeanDefinitionReader</strong>：读取配置文件，<strong>XML 用 Dom4j 解析</strong>，<strong>注解用 IO 流加载解析</strong></p></li></ul><p>程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><p>源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">    <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="comment">//将 resource 包装成带编码格式的 EncodedResource</span></span><br><span class="line">    <span class="comment">//EncodedResource 中 getReader()方法，调用java.io包下的 转换流 创建指定编码的输入流对象</span></span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>XmlBeanDefinitionReader.loadBeanDefinitions()</code>：<strong>把 Resource 解析成 BeanDefinition 对象</strong></p><ul><li><code>currentResources = this.resourcesCurrentlyBeingLoaded.get()</code>：拿到当前线程已经加载过的所有 EncodedResoure 资源，用 ThreadLocal 保证线程安全</li><li><code>if (currentResources == null)</code>：判断 currentResources 是否为空，为空则进行初始化</li><li><code>if (!currentResources.add(encodedResource))</code>：如果已经加载过该资源会报错，防止重复加载</li><li><code>inputSource = new InputSource(inputStream)</code>：资源对象包装成 InputSource，InputSource 是 <strong>SAX</strong> 中的资源对象，用来进行 XML 文件的解析</li><li><code>return doLoadBeanDefinitions()</code>：<strong>加载返回</strong></li><li><code>currentResources.remove(encodedResource)</code>：加载完成移除当前 encodedResource</li><li><code>resourcesCurrentlyBeingLoaded.remove()</code>：ThreadLocal 为空时移除元素，防止内存泄露</li></ul></li><li><p><code>XmlBeanDefinitionReader.doLoadBeanDefinitions(inputSource, resource)</code>：真正的加载函数</p><p><code>Document doc = doLoadDocument(inputSource, resource)</code>：转换成有<strong>层次结构</strong>的 Document 对象</p><ul><li><p><code>getEntityResolver()</code><strong>：获取用来解析 DTD、XSD 约束的解析器</strong></p></li><li><p><code>getValidationModeForResource(resource)</code>：获取验证模式</p></li></ul><p><code>int count = registerBeanDefinitions(doc, resource)</code>：<strong>将 Document 解析成 BD 对象，注册（添加）到  BeanDefinationRegistry 中</strong>，返回新注册的数量</p><ul><li><code>createBeanDefinitionDocumentReader()</code>：创建 DefaultBeanDefinitionDocumentReader 对象</li><li><code>getRegistry().getBeanDefinitionCount()</code>：获取解析前 BeanDefinationRegistry 中的 bd 数量</li><li><code>registerBeanDefinitions(doc, readerContext)</code>：注册 BD<ul><li><code>this.readerContext = readerContext</code>：保存上下文对象</li><li><code>doRegisterBeanDefinitions(doc.getDocumentElement())</code>：真正的注册 BD 函数<ul><li><code>doc.getDocumentElement()</code>：拿出顶层标签 <beans></beans></li></ul></li></ul></li><li><code>return getRegistry().getBeanDefinitionCount() - countBefore</code>：返回新加入的数量</li></ul></li><li><p><code>DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions()</code>：注册 BD 到 BR</p><ul><li><code>createDelegate(getReaderContext(), root, parent)</code>：beans 是标签的解析器对象</li><li><code>delegate.isDefaultNamespace(root)</code>：判断 beans 标签是否是默认的属性</li><li><code>root.getAttribute(PROFILE_ATTRIBUTE)</code>：解析 profile 属性</li><li><code>preProcessXml(root)</code>：解析前置处理，自定义实现</li><li><code>parseBeanDefinitions(root, this.delegate)</code>：<strong>解析 beans 标签中的子标签</strong><ul><li><code>parseDefaultElement(ele, delegate)</code>：如果是默认的标签，用该方法解析子标签<ul><li>判断标签名称，进行相应的解析</li><li><code>processBeanDefinition(ele, delegate)</code>：</li></ul></li><li><code>delegate.parseCustomElement(ele)</code>：解析自定义的标签</li></ul></li><li><code>postProcessXml(root)</code>：解析后置处理</li></ul></li><li><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code>：<strong>解析 bean 标签并注册到注册中心</strong></p><ul><li><p><code>delegate.parseBeanDefinitionElement(ele)</code>：解析 bean 标签封装为 BeanDefinitionHolder</p><ul><li><p><code>if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty())</code>：条件一成立说明 name 没有值，条件二成立说明别名有值</p><p><code>beanName = aliases.remove(0)</code>：拿别名列表的第一个元素当作 beanName</p></li><li><p><code>parseBeanDefinitionElement(ele, beanName, containingBean)</code>：<strong>解析 bean 标签</strong></p><ul><li><code>parseState.push(new BeanEntry(beanName))</code>：当前解析器的状态设置为 BeanEntry</li><li>class 和 parent 属性存在一个，parent 是作为父标签为了被继承</li><li><code>createBeanDefinition(className, parent)</code>：设置了class 的 GenericBeanDefinition对象</li><li><code>parseBeanDefinitionAttributes()</code>：解析 bean 标签的属性</li><li>接下来解析子标签</li></ul></li><li><p><code>beanName = this.readerContext.generateBeanName(beanDefinition)</code>：生成 className + # + 序号的名称赋值给 beanName </p></li><li><p><code>return new BeanDefinitionHolder(beanDefinition, beanName, aliases)</code>：<strong>包装成 BeanDefinitionHolder</strong></p></li></ul></li><li><p><code>registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</code>：<strong>注册到容器</strong></p><ul><li><code>beanName = definitionHolder.getBeanName()</code>：获取beanName</li><li><code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>：添加到注册中心</li></ul></li><li><p><code>getReaderContext().fireComponentRegistered()</code>：发送注册完成事件</p></li></ul></li></ul><p><strong>说明：源码部分的笔记不一定适合所有人阅读，作者采用流水线式去解析重要的代码，解析的结构类似于树状，如果视觉疲劳可以去网上参考一些博客和流程图学习源码。</strong></p><hr><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h4><p>Spring IOC 容器是 ApplicationContext 或者 BeanFactory，使用多个 Map 集合保存单实例 Bean，环境信息等资源，不同层级有不同的容器，比如整合 SpringMVC 的父子容器（先看 Bean 部分的源码解析再回看容器）</p><p>ClassPathXmlApplicationContext 与 AnnotationConfigApplicationContext 差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(annotatedClasses);<span class="comment">// 解析配置类，封装成一个 BeanDefinitionHolder，并注册到容器</span></span><br><span class="line">    refresh();<span class="comment">// 加载刷新容器中的 Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 Spring 的注解解析器到容器</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 实例化路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext.refresh()：</p><ul><li><p>prepareRefresh()：刷新前的<strong>预处理</strong></p><ul><li><code>this.startupDate = System.currentTimeMillis()</code>：设置容器的启动时间</li><li><code>initPropertySources()</code>：初始化一些属性设置，可以自定义个性化的属性设置方法</li><li><code>getEnvironment().validateRequiredProperties()</code>：检查环境变量</li><li><code>earlyApplicationEvents= new LinkedHashSet&lt;ApplicationEvent&gt;()</code>：保存容器中早期的事件</li></ul></li><li><p>obtainFreshBeanFactory()：获取一个<strong>全新的 BeanFactory 接口实例</strong>，如果容器中存在工厂实例直接销毁</p><p><code>refreshBeanFactory()</code>：创建 BeanFactory，设置序列化 ID、读取 BeanDefinition 并加载到工厂</p><ul><li><code>if (hasBeanFactory())</code>：applicationContext 内部拥有一个 beanFactory 实例，需要将该实例完全释放销毁</li><li><code>destroyBeans()</code>：销毁原 beanFactory 实例，将 beanFactory 内部维护的单实例 bean 全部清掉，如果哪个 bean 实现了 Disposablejie接口，还会进行 bean distroy 方法的调用处理<ul><li><code>this.singletonsCurrentlyInDestruction = true</code>：设置当前 beanFactory 状态为销毁状态</li><li><code>String[] disposableBeanNames</code>：获取销毁集合中的 bean，如果当前 bean 有<strong>析构函数</strong>就会在销毁集合</li><li><code>destroySingleton(disposableBeanNames[i])</code>：遍历所有的 disposableBeans，执行销毁方法<ul><li><code>removeSingleton(beanName)</code>：清除三级缓存和 registeredSingletons 中的当前 beanName 的数据</li><li><code>this.disposableBeans.remove(beanName)</code>：从销毁集合中清除，每个 bean 只能 destroy 一次</li><li><code>destroyBean(beanName, disposableBean)</code>：销毁 bean<ul><li>dependentBeanMap 记录了依赖当前 bean 的其他 bean 信息，因为依赖的对象要被回收了，所以依赖当前 bean 的其他对象都要执行 destroySingleton，遍历 dependentBeanMap 执行销毁</li><li><code>bean.destroy()</code>：解决完成依赖后，执行 DisposableBean 的 destroy 方法</li><li><code> this.dependenciesForBeanMap.remove(beanName)</code>：保存当前 bean 依赖了谁，直接清除</li></ul></li></ul></li><li>进行一些集合和缓存的清理工作</li></ul></li><li><code>closeBeanFactory()</code>：将容器内部的 beanFactory 设置为空，重新创建</li><li><code>beanFactory = createBeanFactory()</code>：创建新的 DefaultListableBeanFactory 对象</li><li><code>beanFactory.setSerializationId(getId())</code>：进行 ID 的设置，可以根据 ID 获取 BeanFactory 对象</li><li><code>customizeBeanFactory(beanFactory)</code>：设置是否允许覆盖和循环引用</li><li><code>loadBeanDefinitions(beanFactory)</code>：<strong>加载 BeanDefinition 信息，注册 BD注册到 BeanFactory 中</strong></li><li><code>this.beanFactory = beanFactory</code>：把 beanFactory 填充至容器中</li></ul><p><code>getBeanFactory()</code>：返回创建的 DefaultListableBeanFactory 对象，该对象继承 BeanDefinitionRegistry</p></li><li><p>prepareBeanFactory(beanFactory)：<strong>BeanFactory 的预准备</strong>工作，向容器中添加一些组件</p><ul><li><code>setBeanClassLoader(getClassLoader())</code>：给当前 bf 设置一个<strong>类加载器</strong>，加载 bd 的 class 信息</li><li><code>setBeanExpressionResolver()</code>：设置 EL 表达式解析器</li><li><code>addPropertyEditorRegistrar</code>：添加一个属性编辑器，解决属性注入时的格式转换</li><li><code>addBeanPostProcessor()</code>：添加后处理器，主要用于向 bean 内部注入一些框架级别的实例</li><li><code>ignoreDependencyInterface()</code>：设置忽略自动装配的接口，bean 内部的这些类型的字段   不参与依赖注入</li><li><code>registerResolvableDependency()</code>：注册一些类型依赖关系</li><li><code>addBeanPostProcessor()</code>：将配置的监听者注册到容器中，当前 bean 实现 ApplicationListener 接口就是监听器事件</li><li><code>beanFactory.registerSingleton()</code>：添加一些系统信息</li></ul></li><li><p>postProcessBeanFactory(beanFactory)：BeanFactory 准备工作完成后进行的后置处理工作，扩展方法</p></li><li><p>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行 BeanFactoryPostProcessor 的方法</strong></p><ul><li><p><code>processedBeans = new HashSet&lt;&gt;()</code>：存储已经执行过的 BeanFactoryPostProcessor 的 beanName</p></li><li><p><code>if (beanFactory instanceof BeanDefinitionRegistry)</code>：<strong>当前 BeanFactory 是 bd 的注册中心，bd 全部注册到 bf</strong></p></li><li><p><code>for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors)</code>：遍历所有的 bf 后置处理器</p></li><li><p><code>if (postProcessor instanceof BeanDefinitionRegistryPostProcessor)</code>：是 Registry 类的后置处理器</p><p><code>registryProcessor.postProcessBeanDefinitionRegistry(registry)</code>：向 bf 中注册一些 bd</p><p><code>registryProcessors.add(registryProcessor)</code>：添加到 BeanDefinitionRegistryPostProcessor 集合</p></li><li><p><code>regularPostProcessors.add(postProcessor)</code>：添加到 BeanFactoryPostProcessor 集合</p></li><li><p>逻辑到这里已经获取到所有 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor  接口类型的后置处理器</p></li><li><p><strong>首先回调 BeanDefinitionRegistryPostProcessor 类的后置处理方法 postProcessBeanDefinitionRegistry()</strong></p><ul><li><p>获取实现了 PriorityOrdered（主排序接口）接口的 bdrpp，进行 sort 排序，然后全部执行并放入已经处理过的集合</p></li><li><p>再执行实现了 Ordered（次排序接口）接口的 bdrpp</p></li><li><p>最后执行没有实现任何优先级或者是顺序接口 bdrpp，<code>boolean reiterate = true</code> 控制 while 是否需要再次循环，循环内是查找并执行 bdrpp 后处理器的 registry 相关的接口方法，接口方法执行以后会向 bf 内注册 bd，注册的 bd 也有可能是 bdrpp 类型，所以需要该变量控制循环</p></li><li><p><code>processedBeans.add(ppName)</code>：已经执行过的后置处理器存储到该集合中，防止重复执行</p></li><li><p><code> invokeBeanFactoryPostProcessors()</code>：bdrpp 继承了 BeanFactoryPostProcessor，有 postProcessBeanFactory 方法</p></li></ul></li><li><p><strong>执行普通 BeanFactoryPostProcessor 的相关 postProcessBeanFactory 方法，按照主次无次序执行</strong></p><ul><li><code>if (processedBeans.contains(ppName))</code>：会过滤掉已经执行过的后置处理器</li></ul></li><li><p><code>beanFactory.clearMetadataCache()</code>：清除缓存中合并的 Bean 定义，因为后置处理器可能更改了元数据</p></li></ul></li></ul><p><strong>以上是 BeanFactory 的创建及预准备工作，接下来进入 Bean 的流程</strong></p><ul><li><p>registerBeanPostProcessors(beanFactory)：<strong>注册 Bean 的后置处理器</strong>，为了干预 Spring 初始化 bean 的流程，这里仅仅是向容器中<strong>注入而非使用</strong></p><ul><li><p><code>beanFactory.getBeanNamesForType(BeanPostProcessor.class)</code>：<strong>获取配置中实现了 BeanPostProcessor 接口类型</strong></p></li><li><p><code>int beanProcessorTargetCount</code>：后置处理器的数量，已经注册的 + 未注册的 + 即将要添加的一个</p></li><li><p><code>beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker())</code>：添加一个检查器</p><p><code>BeanPostProcessorChecker.postProcessAfterInitialization()</code>：初始化后的后处理器方法</p><ul><li><code>!(bean instanceof BeanPostProcessor) </code>：当前 bean 类型是普通 bean，不是后置处理器</li><li><code>!isInfrastructureBean(beanName)</code>：成立说明当前 beanName 是用户级别的 bean  不是 Spring 框架的</li><li><code>this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount</code>：BeanFactory 上面注册后处理器数量 &lt; 后处理器数量，说明后处理框架尚未初始化完成</li></ul></li><li><p><code>for (String ppName : postProcessorNames)</code>：遍历 PostProcessor 集合，<strong>根据实现不同的顺序接口添加到不同集合</strong></p></li><li><p><code>sortPostProcessors(priorityOrderedPostProcessors, beanFactory)</code>：实现 PriorityOrdered 接口的后处理器排序</p><p><code>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)</code>：<strong>注册到 beanFactory 中</strong></p></li><li><p>接着排序注册实现 Ordered 接口的后置处理器，然后注册普通的（ 没有实现任何优先级接口）后置处理器</p></li><li><p>最后排序 MergedBeanDefinitionPostProcessor 类型的处理器，根据实现的排序接口，排序完注册到 beanFactory 中</p></li><li><p><code>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext))</code>：重新注册 ApplicationListenerDetector 后处理器，用于在 Bean 创建完成后检查是否属于 ApplicationListener 类型，如果是就把 Bean 放到<strong>监听器容器</strong>中保存起来</p></li></ul></li><li><p>initMessageSource()：初始化 MessageSource 组件，主要用于做国际化功能，消息绑定与消息解析</p><ul><li><code>if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME))</code>：容器是否含有名称为 messageSource 的 bean</li><li><code>beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class)</code>：如果有证明用户自定义了该类型的 bean，获取后直接赋值给 this.messageSource</li><li><code>dms = new DelegatingMessageSource()</code>：容器中没有就新建一个赋值</li></ul></li><li><p>initApplicationEventMulticaster()：<strong>初始化事件传播器</strong>，在注册监听器时会用到</p><ul><li><code>if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME))</code>：<strong>条件成立说明用户自定义了事件传播器</strong>，可以实现 ApplicationEventMulticaster 接口编写自己的事件传播器，通过 bean 的方式提供给 Spring</li><li>如果有就直接从容器中获取；如果没有则创建一个 SimpleApplicationEventMulticaster 注册</li></ul></li><li><p>onRefresh()：留给用户去实现，可以硬编码提供一些组件，比如提供一些监听器</p></li><li><p>registerListeners()：注册通过配置提供的 Listener，这些<strong>监听器</strong>最终注册到 ApplicationEventMulticaster 内</p><ul><li><p><code>for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) </code>：注册编码实现的监听器</p></li><li><p><code>getBeanNamesForType(ApplicationListener.class, true, false)</code>：注册通过配置提供的 Listener</p></li><li><p><code>multicastEvent(earlyEvent)</code>：<strong>发布前面步骤产生的事件 applicationEvents</strong></p><p><code>Executor executor = getTaskExecutor()</code>：获取线程池，有线程池就异步执行，没有就同步执行</p></li></ul></li><li><p>finishBeanFactoryInitialization()：<strong>实例化非懒加载状态的单实例</strong></p><ul><li><p><code>beanFactory.freezeConfiguration()</code>：<strong>冻结配置信息</strong>，就是冻结 BD 信息，冻结后无法再向 bf 内注册 bd</p></li><li><p><code>beanFactory.preInstantiateSingletons()</code>：实例化 non-lazy-init singletons</p><ul><li><p><code>for (String beanName : beanNames)</code>：遍历容器内所有的 beanDefinitionNames</p></li><li><p><code>getMergedLocalBeanDefinition(beanName)</code>：获取与父类合并后的对象（Bean → 获取流程部分详解此函数）</p></li><li><p><code>if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</code>：BD 对应的 Class 满足非抽象、单实例，非懒加载，需要预先实例化</p><p><code>if (isFactoryBean(beanName))</code>：BD 对应的 Class 是 factoryBean 对象</p><ul><li><code>getBean(FACTORY_BEAN_PREFIX + beanName)</code>：获取工厂 FactoryBean 实例本身</li><li><code>isEagerInit</code>：控制 FactoryBean 内部管理的 Bean 是否也初始化</li><li><code>getBean(beanName)</code>：<strong>初始化 Bean，获取 Bean 详解此函数</strong></li></ul><p><code>getBean(beanName)</code>：不是工厂 bean 直接获取</p></li><li><p><code>for (String beanName : beanNames)</code>：检查所有的 Bean 是否实现 SmartInitializingSingleton 接口，实现了就执行 afterSingletonsInstantiated()，进行一些创建后的操作</p></li></ul></li></ul></li><li><p><code>finishRefresh()</code>：完成刷新后做的一些事情，主要是启动生命周期</p><ul><li><code>clearResourceCaches()</code>：清空上下文缓存</li><li><code>initLifecycleProcessor()</code>：<strong>初始化和生命周期有关的后置处理器</strong>，容器的生命周期<ul><li><code>if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME))</code>：成立说明自定义了生命周期处理器</li><li><code>defaultProcessor = new DefaultLifecycleProcessor()</code>：Spring 默认提供的生命周期处理器</li><li><code> beanFactory.registerSingleton()</code>：将生命周期处理器注册到 bf 的一级缓存和注册单例集合中</li></ul></li><li><code>getLifecycleProcessor().onRefresh()</code>：获取该**生命周期后置处理器回调 onRefresh()**，调用 <code>startBeans(true)</code><ul><li><code>lifecycleBeans = getLifecycleBeans()</code>：获取到所有实现了 Lifecycle 接口的对象包装到 Map 内，key 是beanName， value 是 Lifecycle 对象</li><li><code>int phase = getPhase(bean)</code>：获取当前 Lifecycle 的 phase 值，当前生命周期对象可能依赖其他生命周期对象的执行结果，所以需要 phase 决定执行顺序，数值越低的优先执行</li><li><code>LifecycleGroup group = phases.get(phase)</code>：把 phsae 相同的 Lifecycle 存入 LifecycleGroup</li><li><code>if (group == null)</code>：group 为空则创建，初始情况下是空的</li><li><code>group.add(beanName, bean)</code>：将当前 Lifecycle 添加到当前 phase 值一样的 group 内</li><li><code>Collections.sort(keys)</code>：<strong>从小到大排序，按优先级启动</strong></li><li><code>phases.get(key).start()</code>：遍历所有的 Lifecycle 对象开始启动</li><li><code>doStart(this.lifecycleBeans, member.name, this.autoStartupOnly)</code>：底层调用该方法启动<ul><li><code>bean = lifecycleBeans.remove(beanName)</code>： 确保 Lifecycle 只被启动一次，在一个分组内被启动了在其他分组内就看不到 Lifecycle 了</li><li><code>dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName)</code>：获取当前即将被启动的 Lifecycle 所依赖的其他 beanName，需要<strong>先启动所依赖的 bean</strong>，才能启动自身</li><li><code>if ()</code>：传入的参数 autoStartupOnly 为 true 表示启动 isAutoStartUp 为 true 的 SmartLifecycle 对象，不会启动普通的生命周期的对象；false 代表全部启动</li><li>bean.start()：<strong>调用启动方法</strong></li></ul></li></ul></li><li><code>publishEvent(new ContextRefreshedEvent(this))</code>：<strong>发布容器刷新完成事件</strong></li><li><code>liveBeansView.registerApplicationContext(this)</code>：暴露 Mbean</li></ul></li></ul><p>补充生命周期 stop() 方法的调用</p><ul><li><p>DefaultLifecycleProcessor.stop()：调用 DefaultLifecycleProcessor.stopBeans()</p><ul><li><p>获取到所有实现了 Lifecycle 接口的对象并按 phase 数值分组的</p></li><li><p><code>keys.sort(Collections.reverseOrder())</code>：按 phase 降序排序 Lifecycle 接口，最先启动的最晚关闭（责任链？）</p></li><li><p><code>phases.get(key).stop()</code>：遍历所有的 Lifecycle 对象开始停止</p><ul><li><p><code>latch = new CountDownLatch(this.smartMemberCount)</code>：创建 CountDownLatch，设置 latch 内部的值为当前分组内的  smartMemberCount 的数量</p></li><li><p><code>countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;())</code>：保存当前正在处理关闭的smartLifecycle 的 BeanName</p></li><li><p><code>for (LifecycleGroupMember member : this.members)</code>：处理本分组内需要关闭的 Lifecycle</p><p><code>doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames)</code>：真正的停止方法</p><ul><li><p><code>getBeanFactory().getDependentBeans(beanName)</code>：<strong>获取依赖当前 Lifecycle 的其他对象的 beanName</strong>，因为当前的 Lifecycle 即将要关闭了，所有的依赖了当前 Lifecycle 的 bean 也要关闭</p></li><li><p><code>countDownBeanNames.add(beanName)</code>：将当前 SmartLifecycle beanName 添加到 countDownBeanNames 集合内，该集合表示正在关闭的 SmartLifecycle</p></li><li><p><code>bean.stop()</code>：调用停止的方法</p></li></ul></li></ul></li></ul></li></ul><hr><h4 id="获取Bean-1"><a href="#获取Bean-1" class="headerlink" title="获取Bean"></a>获取Bean</h4><p>单实例：在容器启动时创建对象</p><p>多实例：在每次获取的时候创建对象</p><p>获取流程：<strong>获取 Bean 时先从单例池获取，如果没有则进行第二次获取，并带上工厂类去创建并添加至单例池</strong></p><p>Java 启动 Spring 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><p>AbstractBeanFactory.doGetBean()：获取 Bean，context.getBean() 追踪到此</p><ul><li><p><code>beanName = transformedBeanName(name)</code>：name 可能是一个别名，重定向出来真实 beanName；也可能是一个 &amp; 开头的 name，说明要获取的 bean 实例对象，是一个 FactoryBean 对象（IOC 原理 → 核心类）</p><ul><li><code>BeanFactoryUtils.transformedBeanName(name)</code>：判断是哪种 name，返回截取 &amp; 以后的 name 并放入缓存<ul><li><code>transformedBeanNameCache.computeIfAbsent</code>：缓存是并发安全集合，key &#x3D;&#x3D; null || value &#x3D;&#x3D; null 时 put 成功 </li><li>do while 循环一直去除 &amp; 直到不再含有 &amp;</li></ul></li><li><code>canonicalName(name)</code>：aliasMap 保存别名信息，其中的 do while 逻辑是迭代查找，比如 A 别名叫做 B，但是 B 又有别名叫 C， aliasMap 为 {“C”:”B”, “B”:”A”}，get(C) 最后返回的是  A</li></ul></li><li><p><code>DefaultSingletonBeanRegistry.getSingleton()</code>：<strong>第一次获取从缓存池获取</strong>（循环依赖详解此代码）</p><ul><li>缓存中有数据进行 getObjectForBeanInstance() 获取可使用的 Bean（本节结束部分详解此函数）</li><li>缓存中没有数据进行下面的逻辑进行创建</li></ul></li><li><p><code>if(isPrototypeCurrentlyInCreation(beanName))</code>：检查 bean 是否在原型（Prototype）正在被创建的集合中，如果是就报错，说明产生了循环依赖，<strong>原型模式解决不了循环依赖</strong></p><p>原因：先加载 A，把 A 加入集合，A 依赖 B 去加载 B，B 又依赖 A，去加载 A，发现 A 在正在创建集合中，产生循环依赖</p></li><li><p><code>markBeanAsCreated(beanName)</code>：把 bean 标记为已经创建，<strong>防止其他线程重新创建 Bean</strong></p></li><li><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：<strong>获取合并父 BD 后的 BD 对象</strong>，BD 是直接继承的，合并后的 BD 信息是包含父类的 BD 信息</p><ul><li><p><code>this.mergedBeanDefinitions.get(beanName)</code>：从缓存中获取</p></li><li><p><code>if(bd.getParentName()==null)</code>：beanName 对应 BD 没有父 BD 就不用处理继承，封装为 RootBeanDefinition 返回</p></li><li><p><code>parentBeanName = transformedBeanName(bd.getParentName())</code>：处理父 BD 的 name 信息</p></li><li><p><code>if(!beanName.equals(parentBeanName))</code>：一般情况父子 BD 的名称不同</p><p><code>pbd = getMergedBeanDefinition(parentBeanName)</code>：递归调用，最终返回父 BD 的父 BD 信息</p></li><li><p><code>mbd = new RootBeanDefinition(pbd)</code>：按照父 BD 信息创建 RootBeanDefinition 对象</p></li><li><p><code>mbd.overrideFrom(bd)</code>：<strong>子 BD 信息覆盖 mbd</strong>，因为是要以子 BD 为基准，不存在的才去父 BD 寻找（<strong>类似 Java 继承</strong>）</p></li><li><p><code>this.mergedBeanDefinitions.put(beanName, mbd)</code>：放入缓存</p></li></ul></li><li><p><code>checkMergedBeanDefinition()</code>：判断当前 BD 是否为<strong>抽象 BD</strong>，抽象 BD 不能创建实例，只能作为父 BD 被继承</p></li><li><p><code>mbd.getDependsOn()</code>：获取 bean 标签 depends-on</p></li><li><p><code>if(dependsOn != null)</code>：<strong>遍历所有的依赖加载，解决不了循环依赖</strong></p><p><code>isDependent(beanName, dep)</code>：判断循环依赖，出现循环依赖问题报错</p><ul><li><p>两个 Map：<code>&lt;bean name=&quot;A&quot; depends-on=&quot;B&quot; ...&gt;</code></p><ul><li>dependentBeanMap：记录依赖了当前 beanName 的其他 beanName（谁依赖我，我记录谁）</li><li>dependenciesForBeanMap：记录当前 beanName 依赖的其它 beanName </li><li>以 B 为视角 dependentBeanMap {“B”：{“A”}}，以 A 为视角 dependenciesForBeanMap {“A” :{“B”}}</li></ul></li><li><p><code>canonicalName(beanName)</code>：处理 bean 的 name</p></li><li><p><code>dependentBeans = this.dependentBeanMap.get(canonicalName)</code>：获取依赖了当前 bean 的 name</p></li><li><p><code>if (dependentBeans.contains(dependentBeanName))</code>：依赖了当前 bean 的集合中是否有该 name，有就产生循环依赖</p></li><li><p>进行递归处理所有的引用：假如 <code>&lt;bean name=&quot;A&quot; dp=&quot;B&quot;&gt; &lt;bean name=&quot;B&quot; dp=&quot;C&quot;&gt; &lt;bean name=&quot;C&quot; dp=&quot;A&quot;&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependentBeanMap=&#123;A:&#123;C&#125;, B:&#123;A&#125;, C:&#123;B&#125;&#125; </span><br><span class="line"><span class="comment">// C 依赖 A     判断谁依赖了C递归判断谁依赖了B</span></span><br><span class="line">isDependent(C, A)  → C#dependentBeans=&#123;B&#125; → isDependent(B, A); → B#dependentBeans=&#123;A&#125; <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li></ul><p><code>registerDependentBean(dep, beanName)</code>：把 bean 和依赖注册到两个 Map 中，注意参数的位置，被依赖的在前</p><p><code>getBean(dep)</code>：<strong>先加载依赖的 Bean</strong>，又进入 doGetBean() 的逻辑</p></li><li><p><code>if (mbd.isSingleton())</code>：<strong>判断 bean 是否是单例的 bean</strong></p><p><code>getSingleton(String, ObjectFactory&lt;?&gt;)</code>：<strong>第二次获取，传入一个工厂对象</strong>，这个方法更倾向于创建实例并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanName, mbd, args);<span class="comment">//创建，跳转生命周期</span></span><br><span class="line">    <span class="comment">//lambda表达式，调用了ObjectFactory的getObject()方法，实际回调接口实现的是 createBean()方法进行创建对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>singletonObjects.get(beanName)</code>：从一级缓存检查是否已经被加载，单例模式复用已经创建的 bean</p></li><li><p><code>this.singletonsCurrentlyInDestruction</code>：容器销毁时会设置这个属性为 true，这时就不能再创建 bean 实例了</p></li><li><p><code>beforeSingletonCreation(beanName)</code>：检查构造注入的依赖，<strong>构造参数注入产生的循环依赖无法解决</strong></p><p><code>!this.singletonsCurrentlyInCreation.add(beanName)</code>：将当前 beanName 放入到正在创建中单实例集合，放入成功说明没有产生循环依赖，失败则产生循环依赖，进入判断条件内的逻辑抛出异常</p><p>原因：加载 A，向正在创建集合中添加了 {A}，根据 A 的构造方法实例化 A 对象，发现 A 的构造方法依赖 B，然后加载 B，B 构造方法的参数依赖于 A，又去加载 A 时来到当前方法，因为创建中集合已经存在 A，所以添加失败</p></li><li><p><code>singletonObject = singletonFactory.getObject()</code>：<strong>创建 bean</strong>（生命周期部分详解）</p></li><li><p><strong>创建完成以后，Bean 已经初始化好，是一个完整的可使用的 Bean</strong></p></li><li><p><code>afterSingletonCreation(beanName)</code>：从正在创建中的集合中移出</p></li><li><p><code>addSingleton(beanName, singletonObject)</code>：<strong>添加一级缓存单例池中，从二级三级缓存移除</strong></p></li></ul><p><code>bean = getObjectForBeanInstance</code>：<strong>单实例可能是普通单实例或者 FactoryBean</strong>，如果是 FactoryBean 实例，需要判断 name 是带 &amp; 还是不带 &amp;，带 &amp; 说明 getBean 获取 FactoryBean 对象，否则是获取 FactoryBean 内部管理的实例</p><ul><li><p>参数 name 是未处理 &amp; 的 name，beanName 是处理过 &amp; 和别名后的 name</p></li><li><p><code>if(BeanFactoryUtils.isFactoryDereference(name))</code>：判断 doGetBean 中参数 name 前是否带 &amp;，不是处理后的</p></li><li><p><code>if(!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name))</code>：Bean 是普通单实例或者是 FactoryBean 就可以直接返回，否则进入下面的获取 <strong>FactoryBean 内部管理的实例</strong>的逻辑</p></li><li><p><code>getCachedObjectForFactoryBean(beanName)</code>：尝试到缓存获取，获取到直接返回，获取不到进行下面逻辑</p></li><li><p><code>if (mbd == null &amp;&amp; containsBeanDefinition(beanName))</code>：Spring 中有当前 beanName 的 BeanDefinition 信息</p><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：获取合并后的 BeanDefinition</p></li><li><p><code>mbd.isSynthetic()</code>：默认值是 false 表示这是一个用户对象，如果是 true 表示是系统对象</p></li><li><p><code>object = getObjectFromFactoryBean(factory, beanName, !synthetic)</code>：从工厂内获取实例</p><ul><li><code>factory.isSingleton() &amp;&amp; containsSingleton(beanName)</code>：工厂内部维护的对象是单实例并且一级缓存存在该 bean</li><li>首先去缓存中获取，获取不到就<strong>使用工厂获取</strong>然后放入缓存，进行循环依赖判断</li></ul></li></ul></li><li><p><code>else if (mbd.isPrototype())</code>：<strong>bean 是原型的 bean</strong></p><p><code>beforePrototypeCreation(beanName)</code>：当前线程正在创建的原型对象 beanName 存入 prototypesCurrentlyInCreation</p><ul><li><code>curVal = this.prototypesCurrentlyInCreation.get()</code>：获取当前线程的正在创建的原型类集合</li><li><code>this.prototypesCurrentlyInCreation.set(beanName)</code>：集合为空就把当前 beanName 加入</li><li><code>if (curVal instanceof String)</code>：已经有线程相关原型类创建了，把当前的创建的加进去</li></ul><p><code>createBean(beanName, mbd, args)</code>：创建原型类对象，不需要三级缓存</p><p><code>afterPrototypeCreation(beanName)</code>：从正在创建中的集合中移除该 beanName， <strong>与 beforePrototypeCreation逻辑相反</strong></p></li><li><p><code>convertIfNecessary()</code>：<strong>依赖检查</strong>，检查所需的类型是否与实际 bean 实例的类型匹配</p></li><li><p><code>return (T) bean</code>：返回创建完成的 bean</p></li></ul><hr><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h5><p>Bean 的生命周期：实例化 instantiation，填充属性 populate，初始化 initialization，销毁 destruction</p><p>AbstractAutowireCapableBeanFactory.createBean()：进入 Bean 生命周期的流程</p><ul><li><p><code>resolvedClass = resolveBeanClass(mbd, beanName)</code>：判断 mdb 中的 class 是否已经<strong>加载到 JVM</strong>，如果未加载则使用类加载器将 beanName 加载到 JVM中并返回 class 对象</p></li><li><p><code>if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null)</code>：条件成立封装 mbd 并把 resolveBeanClass 设置到 bd 中</p><ul><li>条件二：mbd 在 resolveBeanClass 之前是否有 class</li><li>条件三：mbd 有 className</li></ul></li><li><p><code>bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>：实例化前的后置处理器返回一个代理实例对象（不是 AOP）</p><ul><li>自定义类继承 InstantiationAwareBeanPostProcessor，重写 postProcessBeforeInstantiation 方法，<strong>方法逻辑为创建对象</strong> </li><li>并配置文件 <code>&lt;bean class=&quot;intefacePackage.MyInstantiationAwareBeanPostProcessor&quot;&gt;</code> 导入为 bean</li><li>条件成立，<strong>短路操作</strong>，直接 return bean</li></ul></li><li><p><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>：Do it</p></li></ul><p>AbstractAutowireCapableBeanFactory.<strong>doCreateBean</strong>(beanName, RootBeanDefinition, Object[] args)：创建 Bean</p><ul><li><p><code>BeanWrapper instanceWrapper = null</code>：<strong>Spring 给所有创建的 Bean 实例包装成 BeanWrapper</strong>，内部最核心的方法是获取实例，提供了一些额外的接口方法，比如属性访问器</p></li><li><p><code>instanceWrapper = this.factoryBeanInstanceCache.remove(beanName)</code>：单例对象尝试从缓存中获取，会移除缓存</p></li><li><p><code>createBeanInstance()</code>：<strong>缓存中没有实例就进行创建实例</strong>（逻辑复杂，下一小节详解）</p></li><li><p><code>if (!mbd.postProcessed)</code>：每个 bean 只进行一次该逻辑</p><p><code>applyMergedBeanDefinitionPostProcessors()</code>：<strong>后置处理器，合并 bd 信息</strong>，接下来要属性填充了</p><p><code>AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()</code>：<strong>后置处理逻辑（@Autowired）</strong></p><ul><li><p><code>metadata = findAutowiringMetadata(beanName, beanType, null)</code>：提取当前 bean 整个继承体系内的 <strong>@Autowired、@Value、@Inject</strong> 信息，存入一个 InjectionMetadata 对象，保存着当前 bean 信息和要自动注入的字段信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;<span class="comment">//当前 bean </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;InjectedElement&gt; injectedElements;<span class="comment">//要注入的信息集合</span></span><br></pre></td></tr></table></figure><ul><li><p><code>metadata = buildAutowiringMetadata(clazz)</code>：查询当前 clazz 感兴趣的注解信息</p><ul><li><p><code>ReflectionUtils.doWithLocalFields()</code>：提取<strong>字段</strong>的注解的信息</p><p><code>findAutowiredAnnotation(field)</code>：代表感兴趣的注解就是那三种注解，获取这三种注解的元数据</p></li><li><p><code>ReflectionUtils.doWithLocalMethods()</code>：提取<strong>方法</strong>的注解的信息</p></li><li><p><code>do&#123;&#125; while (targetClass != null &amp;&amp; targetClass != Object.class)</code>：循环从父类中解析，直到 Object 类</p></li></ul></li><li><p><code>this.injectionMetadataCache.put(cacheKey, metadata)</code>：存入缓存</p></li></ul></li></ul><p><code>mbd.postProcessed = true</code>：设置为 true，下次访问该逻辑不会再进入</p></li><li><p><code>earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)</code>：单例、解决循环引用、是否在单例正在创建集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 【放入三级缓存一个工厂对象，用来获取提前引用】</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    <span class="comment">// lamda 表达式，用来获取提前引用，循环依赖部分详解该逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code> populateBean(beanName, mbd, instanceWrapper)</code>：**属性填充，依赖注入，整体逻辑是先处理标签再处理注解，填充至 pvs 中，最后通过 apply 方法最后完成属性依赖注入到 BeanWrapper **</p><ul><li><p><code>if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName))</code>：实例化后的后置处理器，默认返回 true，可以自定义类继承 InstantiationAwareBeanPostProcessor 修改后置处理方法的返回值为 false，使 continueWithPropertyPopulation 为 false，<strong>会导致直接返回，不进行属性的注入</strong></p></li><li><p><code>if (!continueWithPropertyPopulation)</code>：自定义方法返回值会造成该条件成立，逻辑为直接返回，<strong>不进行依赖注入</strong></p></li><li><p><code>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)</code>：处理依赖注入逻辑开始</p></li><li><p><code>mbd.getResolvedAutowireMode() == ?</code>：<strong>根据 bean 标签配置的 autowire</strong> 判断是 BY_NAME 或者 BY_TYPE</p><p><code>autowireByName(beanName, mbd, bw, newPvs)</code>：根据字段名称去获取依赖的 bean，还没注入，只是添加到 pvs</p><ul><li><p><code>propertyNames = unsatisfiedNonSimpleProperties(mbd, bw)</code>：bean 实例中有该字段和该字段的 setter 方法，但是在 bd 中没有 property 属性</p><ul><li><p>拿到配置的 property 信息和 bean 的所有字段信息</p></li><li><p><code>pd.getWriteMethod() != null</code>：<strong>当前字段是否有 set 方法，配置类注入的方式需要 set 方法</strong></p><p><code>!isExcludedFromDependencyCheck(pd)</code>：当前字段类型是否在忽略自动注入的列表中</p><p><code>!pvs.contains(pd.getName()</code>：当前字段不在 xml 或者其他方式的配置中，也就是 bd 中不存在对应的 property</p><p><code>!BeanUtils.isSimpleProperty(pd.getPropertyType()</code>：是否是基本数据类型和内置的几种数据类型，基本数据类型不允许自动注入</p></li></ul></li><li><p><code>if (containsBean(propertyName))</code>：BeanFactory 中存在当前 property 的 bean 实例，说明找到对应的依赖数据</p></li><li><p><code>getBean(propertyName)</code>：<strong>拿到 propertyName 对应的 bean 实例</strong></p></li><li><p><code>pvs.add(propertyName, bean)</code>：填充到 pvs 中</p></li><li><p><code>registerDependentBean(propertyName, beanName))</code>：添加到两个依赖 Map（dependsOn）中</p></li></ul><p><code>autowireByType(beanName, mbd, bw, newPvs)</code>：根据字段类型去查找依赖的 bean</p><ul><li><code>desc = new AutowireByTypeDependencyDescriptor(methodParam, eager)</code>：依赖描述信息</li><li><code>resolveDependency(desc, beanName, autowiredBeanNames, converter)</code>：根据描述信息，查找依赖对象，容器中没有对应的实例但是有对应的 BD，会调用 getBean(Type) 获取对象</li></ul><p><code>pvs = newPvs</code>：newPvs 是处理了依赖数据后的 pvs，所以赋值给 pvs</p></li><li><p><code>hasInstAwareBpps</code>：表示当前是否有 InstantiationAwareBeanPostProcessors 的后置处理器（Autowired）</p></li><li><p><code>pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code>：**@Autowired 注解的注入**，这个传入的 pvs 对象，最后原封不动的返回，不会添加东西</p><ul><li><p><code>findAutowiringMetadata()</code>：包装着当前 bd 需要注入的注解信息集合，<strong>三种注解的元数据</strong>，直接缓存获取</p></li><li><p><code>InjectionMetadata.InjectedElement.inject()</code>：遍历注解信息解析后注入到 Bean，方法和字段的注入实现不同</p><p>以字段注入为例：</p><ul><li><p><code>value = resolveFieldValue(field, bean, beanName)</code>：处理字段属性值</p><p><code>value = beanFactory.resolveDependency()</code>：解决依赖</p><p><code>result = doResolveDependency()</code>：<strong>真正处理自动注入依赖的逻辑</strong></p><ul><li><p><code>Object shortcut = descriptor.resolveShortcut(this)</code>：默认返回 null</p></li><li><p><code>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor)</code>：<strong>获取 @Value 的值</strong></p></li><li><p><code>converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor())</code>：如果 value 不是 null，就直接进行类型转换返回数据</p></li><li><p><code>matchingBeans = findAutowireCandidates(beanName, type, descriptor)</code>：如果 value 是空说明字段是引用类型，<strong>获取 @Autowired 的 Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addCandidateEntry() → Object beanInstance = descriptor.resolveCandidate()</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 获取 bean</span></span><br><span class="line">    <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>ReflectionUtils.makeAccessible(field)</code>：修改访问权限</p></li><li><p><code>field.set(bean, value)</code>：获取属性访问器为此 field 对象赋值</p></li></ul></li></ul></li><li><p><code>applyPropertyValues()</code>：<strong>将所有解析的 PropertyValues 的注入至 BeanWrapper 实例中</strong>（深拷贝）</p><ul><li><code>if (pvs.isEmpty())</code>：注解 @Autowired 和 @Value 标注的信息在后置处理的逻辑注入完成，此处为空直接返回</li><li>下面的逻辑进行 XML 配置的属性的注入，首先获取转换器进行数据转换，然后<strong>获取 WriteMethod (set) 方法进行反射调用</strong>，完成属性的注入</li></ul></li></ul></li><li><p><code>initializeBean(String,Object,RootBeanDefinition)</code>：<strong>初始化，分为配置文件和实现接口两种方式</strong></p><ul><li><p><code>invokeAwareMethods(beanName, bean)</code>：根据 bean 是否实现 Aware 接口执行初始化的方法</p></li><li><p><code>wrappedBean = applyBeanPostProcessorsBeforeInitialization</code>：初始化前的后置处理器，可以继承接口重写方法</p><ul><li><code>processor.postProcessBeforeInitialization()</code>：执行后置处理的方法，默认返回 bean 本身</li><li><code>if (current == null) return result</code>：重写方法返回 null，会造成后置处理的短路，直接返回</li></ul></li><li><p><code>invokeInitMethods(beanName, wrappedBean, mbd)</code>：<strong>反射执行初始化方法</strong></p><ul><li><p><code>isInitializingBean = (bean instanceof InitializingBean)</code>：初始化方法的定义有两种方式，一种是自定义类实现 InitializingBean 接口，另一种是配置文件配置 &lt;bean id&#x3D;”…” class&#x3D;”…” init-method&#x3D;”init”&#x2F; &gt;</p></li><li><p><code>isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))</code>：</p><ul><li><p>条件一：当前 bean 是不是实现了 InitializingBean </p></li><li><p>条件二：InitializingBean 接口中的方法 afterPropertiesSet，判断该方法是否是容器外管理的方法</p></li></ul></li><li><p><code>if (mbd != null &amp;&amp; bean.getClass() != NullBean.class)</code>：成立说明是配置文件的方式</p><p><code>if(!(接口条件))</code>表示<strong>如果通过接口实现了初始化方法的话，就不会在调用配置类中 init-method 定义的方法</strong></p><p><code>((InitializingBean) bean).afterPropertiesSet()</code>：调用方法</p><p><code>invokeCustomInitMethod</code>：执行自定义的方法</p><ul><li><code>initMethodName = mbd.getInitMethodName()</code>：获取方法名</li><li><code>Method initMethod = ()</code>：根据方法名获取到 init-method 方法</li><li><code> methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod)</code>：将方法转成从接口层面获取</li><li><code>ReflectionUtils.makeAccessible(methodToInvoke)</code>：访问权限设置成可访问</li><li><code> methodToInvoke.invoke(bean)</code>：<strong>反射调用初始化方法</strong>，以当前 bean 为角度去调用</li></ul></li></ul></li><li><p><code>wrappedBean = applyBeanPostProcessorsAfterInitialization</code>：初始化后的后置处理器</p><ul><li><p><code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code>：如果 Bean 被子类标识为要代理的 bean，则使用配置的拦截器<strong>创建代理对象</strong>，AOP 部分详解</p></li><li><p>如果不存在循环依赖，创建动态代理 bean 在此处完成；否则真正的创建阶段是在属性填充时获取提前引用的阶段，<strong>循环依赖</strong>详解，源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该集合用来避免重复将某个 bean 生成代理对象，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 beanName 或者加上 &amp;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);y</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey)</span> != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>if (earlySingletonExposure)</code>：是否允许提前引用</p><p><code>earlySingletonReference = getSingleton(beanName, false)</code>：<strong>从二级缓存获取实例</strong>，放入一级缓存是在 doGetBean 中的sharedInstance &#x3D; getSingleton() 逻辑中，此时在 createBean 的逻辑还没有返回，所以一级缓存没有</p><p><code>if (earlySingletonReference != null)</code>：当前 bean 实例从二级缓存中获取到了，说明<strong>产生了循环依赖</strong>，在属性填充阶段会提前调用三级缓存中的工厂生成 Bean 的代理对象（或原始实例），放入二级缓存中，然后使用原始 bean 继续执行初始化</p><ul><li><p><code> if (exposedObject == bean)</code>：<strong>初始化后的 bean &#x3D;&#x3D; 创建的原始实例</strong>，条件成立的两种情况：当前的真实实例不需要被代理；当前实例存在循环依赖已经被提前代理过了，初始化时的后置处理器直接返回 bean 原实例</p><p><code>exposedObject = earlySingletonReference</code>：<strong>把代理后的 Bean 传给 exposedObject 用来返回，因为只有代理对象才封装了拦截器链，main 方法中用代理对象调用方法时会进行增强，代理是对原始对象的包装，所以这里返回的代理对象中含有完整的原实例（属性填充和初始化后的），是一个完整的代理对象，返回后外层方法会将当前 Bean 放入一级缓存</strong></p></li><li><p><code>else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName))</code>：是否有其他 bean 依赖当前 bean，执行到这里说明是不存在循环依赖、存在增强代理的逻辑，也就是正常的逻辑</p><ul><li><p><code>dependentBeans = getDependentBeans(beanName)</code>：取到依赖当前 bean 的其他 beanName</p></li><li><p><code>if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))</code>：判断 dependentBean 是否创建完成</p><ul><li><code>if (!this.alreadyCreated.contains(beanName))</code>：成立当前 bean 尚未创建完成，当前 bean 是依赖exposedObject 的 bean，返回 true</li></ul></li><li><p><code>return false</code>：创建完成返回 false</p><p><code>actualDependentBeans.add(dependentBean)</code>：创建完成的 dependentBean 加入该集合</p></li><li><p><code>if (!actualDependentBeans.isEmpty())</code>：条件成立说明有依赖于当前 bean 的 bean 实例创建完成，但是当前的 bean 还没创建完成返回，依赖当前 bean 的外部 bean 持有的是不完整的 bean，所以需要报错</p></li></ul></li></ul></li><li><p><code>registerDisposableBeanIfNecessary</code>：判断当前 bean 是否需要<strong>注册析构函数回调</strong>，当容器销毁时进行回调</p><ul><li><p><code>if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))</code></p><ul><li><p>如果是原型 prototype 不会注册析构回调，不会回调该函数，对象的回收由 JVM 的 GC 机制完成</p></li><li><p>requiresDestruction()：</p><ul><li><p><code>DisposableBeanAdapter.hasDestroyMethod(bean, mbd)</code>：bd 中定义了 DestroyMethod 返回 true</p></li><li><p><code>hasDestructionAwareBeanPostProcessors()</code>：后处理器框架决定是否进行析构回调</p></li></ul></li></ul></li><li><p><code>registerDisposableBean()</code>：条件成立进入该方法，给当前单实例注册回调适配器，适配器内根据当前 bean 实例是继承接口（DisposableBean）还是自定义标签来判定具体调用哪个方法实现</p></li></ul></li><li><p><code>this.disposableBeans.put(beanName, bean)</code>：向销毁集合添加实例</p></li></ul><hr><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>AbstractAutowireCapableBeanFactory.createBeanInstance(beanName, RootBeanDefinition, Object[] args)</p><ul><li><p><code>resolveBeanClass(mbd, beanName)</code>：确保 Bean 的 Class 真正的被加载</p></li><li><p>判断类的访问权限是不是 public，不是进入下一个判断，是否允许访问类的 non-public 的构造方法，不允许则报错</p></li><li><p><code>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier()</code>：获取创建实例的函数，可以自定义，没有进入下面的逻辑</p></li><li><p><code>if (mbd.getFactoryMethodName() != null)</code>：<strong>判断 bean 是否设置了 factory-method 属性，优先使用</strong></p><p><bean class="" factory-method="">，设置了该属性进入 factory-method 方法创建实例</p></li><li><p><code>resolved = false</code>：代表 bd 对应的构造信息是否已经解析成可以反射调用的构造方法</p></li><li><p><code>autowireNecessary = false</code>：是否自动匹配构造方法</p></li><li><p><code>if(mbd.resolvedConstructorOrFactoryMethod != null)</code>：获取 bd 的构造信息转化成反射调用的 method 信息</p><ul><li>method 为 null 则 resolved 和 autowireNecessary 都为默认值 false</li><li><code>autowireNecessary = mbd.constructorArgumentsResolved</code>：构造方法有参数，设置为 true</li></ul></li><li><p><strong>bd 对应的构造信息解析完成，可以直接反射调用构造方法了</strong>：</p><ul><li><p><code>return autowireConstructor(beanName, mbd, null, null)</code>：<strong>有参构造</strong>，根据参数匹配最优的构造器创建实例</p></li><li><p><code>return instantiateBean(beanName, mbd)</code>：<strong>无参构造方法通过反射创建实例</strong></p><ul><li><p><code>SimpleInstantiationStrategy.instantiate()</code>：<strong>真正用来实例化的函数</strong>（无论如何都会走到这一步）</p><ul><li><p><code>if (!bd.hasMethodOverrides())</code>：没有方法重写覆盖</p><p><code>BeanUtils.instantiateClass(constructorToUse)</code>：调用 <code>Constructor.newInstance()</code> 实例化</p></li><li><p><code>instantiateWithMethodInjection(bd, beanName, owner)</code>：<strong>有方法重写采用 CGLIB  实例化</strong></p></li></ul></li><li><p><code>BeanWrapper bw = new BeanWrapperImpl(beanInstance)</code>：包装成 BeanWrapper 类型的对象</p></li><li><p><code>return bw</code>：返回实例</p></li></ul></li></ul></li><li><p><code>ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName)</code>：**@Autowired 注解**，对应的后置处理器 AutowiredAnnotationBeanPostProcessor 逻辑</p><ul><li><p>配置了 lookup 的相关逻辑</p></li><li><p><code>this.candidateConstructorsCache.get(beanClass)</code>：从缓存中获取构造方法，第一次获取为 null，进入下面逻辑</p></li><li><p><code>rawCandidates = beanClass.getDeclaredConstructors()</code>：获取所有的构造器</p></li><li><p><code>Constructor&lt;?&gt; requiredConstructor = null</code>：唯一的选项构造器，**@Autowired(required &#x3D; “true”)** 时有值</p></li><li><p><code>for (Constructor&lt;?&gt; candidate : rawCandidates)</code>：遍历所有的构造器：</p><p><code>ann = findAutowiredAnnotation(candidate)</code>：有三种注解中的一个会返回注解的属性</p><ul><li><p>遍历 this.autowiredAnnotationTypes 中的三种注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);<span class="comment">//！！！！！！！！！！！！！！</span></span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(...ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><code> AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type)</code>：获取注解的属性</p></li><li><p><code>if (attributes != null) return attributes</code>：任意一个注解属性不为空就注解返回</p></li></ul><p><code>if (ann == null)</code>：注解属性为空</p><ul><li><code>userClass = ClassUtils.getUserClass(beanClass)</code>：如果当前 beanClass 是代理对象，方法上就已经没有注解了，所以<strong>获取原始的用户类型重新获取该构造器上的注解属性</strong>（<strong>事务注解失效</strong>也是这个原理）</li></ul><p><code>if (ann != null)</code>：注解属性不为空了</p><ul><li><p><code>required = determineRequiredStatus(ann)</code>：获取 required 属性的值</p><ul><li><code>!ann.containsKey(this.requiredParameterName) || </code>：判断属性是否包含 required，不包含进入后面逻辑</li><li><code>this.requiredParameterValue == ann.getBoolean(this.requiredParameterName)</code>：获取属性值返回</li></ul></li><li><p><code>if (required)</code>：代表注解 @Autowired(required &#x3D; true)</p><p><code>if (!candidates.isEmpty())</code>：true 代表只能有一个构造方法，构造集合不是空代表可选的构造器不唯一，报错</p><p><code>requiredConstructor = candidate</code>：把构造器赋值给 requiredConstructor</p></li><li><p><code>candidates.add(candidate)</code>：把当前构造方法添加至 candidates 集合</p></li></ul><p><code> if(candidate.getParameterCount() == 0)</code>：当前遍历的构造器的参数为 0 代表没有参数，是<strong>默认构造器</strong>，赋值给 defaultConstructor </p></li><li><p><code>candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0])</code>：<strong>将构造器转成数组返回</strong></p></li></ul></li><li><p><code>if(ctors != null)</code>：条件成立代表指定了<strong>构造方法数组</strong></p><p><code>mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR</code>：<bean autowire=""> 标签内 autowiremode 的属性值，默认是 no，AUTOWIRE_CONSTRUCTOR 代表选择最优的构造方法</p><p><code>mbd.hasConstructorArgumentValues()</code>：bean 信息中是否配置了构造参数的值</p><p><code>!ObjectUtils.isEmpty(args)</code>：getBean 时，指定了参数 arg</p></li><li><p><code>return autowireConstructor(beanName, mbd, ctors, args)</code>：<strong>选择最优的构造器进行创建实例</strong>（复杂，不建议研究）</p><ul><li><p><code>beanFactory.initBeanWrapper(bw)</code>：向 BeanWrapper 中注册转换器，向工厂中注册属性编辑器</p></li><li><p><code>Constructor&lt;?&gt; constructorToUse = null</code>：实例化反射构造器</p><p><code>ArgumentsHolder argsHolderToUse</code>：实例化时真正去用的参数，并持有对象</p><ul><li>rawArguments 是转换前的参数，arguments 是类型转换完成的参数</li></ul><p><code>Object[] argsToUse</code>：参数实例化时使用的参数</p></li><li><p><code>Object[] argsToResolve</code>：表示构造器参数做转换后的参数引用</p></li><li><p><code>if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved)</code>：</p><ul><li>条件一成立说明当前 bd 生成的实例不是第一次，缓存中有解析好的构造器方法可以直接拿来反射调用</li><li>条件二成立说明构造器参数已经解析过了</li></ul></li><li><p><code>argsToUse = resolvePreparedArguments()</code>：argsToResolve 不是完全解析好的，还需要继续解析</p></li><li><p><code>if (constructorToUse == null || argsToUse == null)</code>：条件成立说明缓存机制失败，进入构造器匹配逻辑</p></li><li><p><code>Constructor&lt;?&gt;[] candidates = chosenCtors</code>：chosenCtors  只有在构造方法上有 autowaire 三种注解时才有数据</p></li><li><p><code>if (candidates == null)</code>：candidates 为空就根据 beanClass 是否允许访问非公开的方法来获取构造方法</p></li><li><p><code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code>：默认无参</p><p><code>bw.setBeanInstance(instantiate())</code>：<strong>使用无参构造器反射调用，创建出实例对象，设置到 BeanWrapper 中去</strong></p></li><li><p><code>boolean autowiring</code>：<strong>需要选择最优的构造器</strong></p></li><li><p><code>cargs = mbd.getConstructorArgumentValues()</code>：获取参数值</p><p><code>resolvedValues = new ConstructorArgumentValues()</code>：获取已经解析后的构造器参数值</p><ul><li><code>final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues</code>：key 是 index， value 是值</li><li><code>final List&lt;ValueHolder&gt; genericArgumentValues</code>：没有 index 的值</li></ul><p><code>minNrOfArgs = resolveConstructorArguments(..,resolvedValues)</code>：从 bd 中解析并获取构造器参数的个数</p><ul><li><code>valueResolver.resolveValueIfNecessary()</code>：将引用转换成真实的对象</li><li><code>resolvedValueHolder.setSource(valueHolder)</code>：将对象填充至 ValueHolder 中</li><li><code> resolvedValues.addIndexedArgumentValue()</code>：将参数值封装至 resolvedValues 中</li></ul></li><li><p><code>AutowireUtils.sortConstructors(candidates)</code>：排序规则 public &gt; 非公开的 &gt; 参数多的 &gt; 参数少的</p></li><li><p><code> int minTypeDiffWeight = Integer.MAX_VALUE</code>：值越低说明构造器<strong>参数列表类型</strong>和构造参数的匹配度越高</p></li><li><p><code>Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors</code>：模棱两可的构造器，两个构造器匹配度相等时放入</p></li><li><p><code>for (Constructor&lt;?&gt; candidate : candidates)</code>：遍历筛选出 minTypeDiffWeight 最低的构造器</p></li><li><p><code>Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes()</code>：获取当前处理的构造器的参数类型</p></li><li><p><code>if()</code>：candidates 是排过序的，当前筛选出来的构造器的优先级一定是优先于后面的 constructor</p></li><li><p><code>if (paramTypes.length &lt; minNrOfArgs)</code>：需求的小于给的，不匹配</p></li><li><p><code>int typeDiffWeight</code>：获取匹配度</p><ul><li><code>mbd.isLenientConstructorResolution()</code>：true 表示 ambiguousConstructors 允许有数据，false 代表不允许有数据，有数据就报错（LenientConstructorResolution：宽松的构造函数解析）</li><li><code>argsHolder.getTypeDifferenceWeight(paramTypes)</code>：选择参数转换前和转换后匹配度最低的，循环向父类中寻找该方法，直到寻找到 Obejct 类</li></ul></li><li><p><code> if (typeDiffWeight &lt; minTypeDiffWeight)</code>：条件成立说明当前循环处理的构造器更优</p></li><li><p><code>else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight)</code>：当前处理的构造器的计算出来的 DiffWeight 与上一次筛选出来的最优构造器的值一致，说明有模棱两可的情况</p></li><li><p><code>if (constructorToUse == null)</code>：未找到可以使用的构造器，报错</p></li><li><p><code> else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution())</code>：模棱两可有数据，LenientConstructorResolution &#x3D;&#x3D; false，所以报错</p></li><li><p><code>argsHolderToUse.storeCache(mbd, constructorToUse)</code>：匹配成功，进行缓存，方便后来者使用该 bd 实例化</p></li><li><p><code> bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse))</code>：匹配成功调用 instantiate 创建出实例对象，设置到 BeanWrapper 中去</p></li></ul></li><li><p><code>return instantiateBean(beanName, mbd)</code>：默认走到这里</p></li></ul><hr><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>循环依赖：是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成一个环形调用</p><p>Spring 循环依赖有四种：</p><ul><li>DependsOn 依赖加载【无法解决】（两种 Map）</li><li>原型模式 Prototype 循环依赖【无法解决】（正在创建集合）</li><li>单例 Bean 循环依赖：构造参数产生依赖【无法解决】（正在创建集合，getSingleton() 逻辑中）</li><li>单例 Bean 循环依赖：setter 产生依赖【可以解决】</li></ul><p>解决循环依赖：提前引用，提前暴露创建中的 Bean</p><ul><li>Spring 先实例化 A，拿到 A 的构造方法反射创建出来 A 的早期实例对象，这个对象被包装成 ObjectFactory 对象，放入三级缓存</li><li>处理 A 的依赖数据，检查发现 A 依赖 B 对象，所以 Spring 就会去根据 B 类型到容器中去 getBean(B)，这里产生递归</li><li>拿到 B 的构造方法，进行反射创建出来 B 的早期实例对象，也会把 B 包装成 ObjectFactory 对象，放到三级缓存，处理 B 的依赖数据，检查发现 B 依赖了 A 对象，然后 Spring 就会去根据 A 类型到容器中去 getBean(A.class)</li><li>这时从三级缓存中获取到 A 的早期对象进入属性填充</li></ul><p>循环依赖的三级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级缓存：存放所有初始化完成单实例 bean，单例池，key是beanName，value是对应的单实例对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级缓存：存放实例化未进行初始化的 Bean，提前引用池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. 3*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p>为什么需要三级缓存？</p><ul><li>循环依赖解决需要提前引用动态代理对象，AOP 动态代理是在 Bean 初始化后的后置处理中进行，这时的 bean 已经是成品对象。因为需要提前进行动态代理，三级缓存的 ObjectFactory 提前产生需要代理的对象，把提前引用放入二级缓存</li><li>如果只有二级缓存，提前引用就直接放入了一级缓存，然后 Bean 初始化完成后又会放入一级缓存，产生数据覆盖，<strong>导致提前引用的对象和一级缓存中的并不是同一个对象</strong></li><li>一级缓存只能存放完整的单实例，<strong>为了保证 Bean 的生命周期不被破坏</strong>，不能将未初始化的 Bean 暴露到一级缓存</li><li>若存在循环依赖，<strong>后置处理不创建代理对象，真正创建代理对象的过程是在 getBean(B) 的阶段中</strong></li></ul></li><li><p>三级缓存一定会创建提前引用吗？</p><ul><li>出现循环依赖就会去三级缓存获取提前引用，不出现就不会，走正常的逻辑，创建完成直接放入一级缓存</li><li>存在循环依赖，就创建代理对象放入二级缓存，如果没有增强方法就返回 createBeanInstance 创建的实例，因为 addSingletonFactory 参数中传入了实例化的 Bean，在 singletonFactory.getObject() 中返回给 singletonObject，所以<strong>存在循环依赖就一定会使用工厂</strong>，但是不一定创建的是代理对象，不需要增强就是原始对象</li></ul></li><li><p>wrapIfNecessary 一定创建代理对象吗？（AOP 动态代理部分有源码解析）</p><ul><li>存在增强器会创建动态代理，不需要增强就不需要创建动态代理对象</li><li>存在循环依赖会提前增强，初始化后不需要增强</li></ul></li><li><p>什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？</p><ul><li><p>实例化之后，依赖注入之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createBeanInstance -&gt; addSingletonFactory -&gt; populateBean</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>假如 A 依赖 B，B 依赖 A</p><ul><li><p>当 A 创建实例后填充属性前，执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加给定的单例工厂以构建指定的单例</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 单例池包含该Bean说明已经创建完成，不需要循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">//加入三级缓存</span></span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName,singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="comment">// 从二级缓存移除，因为三个Map中都是一个对象，不能同时存在！</span></span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>填充属性时 A 依赖 B，这时需要 getBean(B)，也会把 B 的工厂放入三级缓存，接着 B 填充属性时发现依赖 A，去进行**第一次 ** getSingleton(A)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);<span class="comment">//为true代表允许拿到早期引用。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 在一级缓存中获取 beanName 对应的单实例对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 单实例确实尚未创建；单实例正在创建，发生了循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存获取</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存不存在，并且允许获取早期实例对象，去三级缓存查看</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从三级缓存获取工厂对象，并得到 bean 的提前引用</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 【缓存升级】，放入二级缓存，提前引用池</span></span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 从三级缓存移除该对象</span></span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从三级缓存获取 A 的 Bean：<code>singletonFactory.getObject()</code>，调用了 lambda 表达式的 getEarlyBeanReference 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="comment">// 【向提前引用代理池 earlyProxyReferences 中添加该 Bean，防止对象被重新代理】</span></span><br><span class="line">    <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="comment">// 创建代理对象，createProxy</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B 填充了 A 的提前引用后会继续初始化直到完成，<strong>返回原始 A 的逻辑继续执行</strong></p></li></ul><hr><h3 id="AOP-2"><a href="#AOP-2" class="headerlink" title="AOP"></a>AOP</h3><h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p>@EnableAspectJAutoProxy：AOP 注解驱动，给容器中导入 AspectJAutoProxyRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">// 是否强制使用 CGLIB 创建代理对象 </span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前代理对象暴露到上下文内，方便代理对象内部的真实对象拿到代理对象</span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJAutoProxyRegistrar 在用来向容器中注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>，以 BeanDefiantion 形式存在，在容器初始化时加载。AnnotationAwareAspectJAutoProxyCreator 间接实现了 InstantiationAwareBeanPostProcessor，Order 接口，该类会在 Bean 的实例化和初始化的前后起作用</p><p>工作流程：创建 IOC 容器，调用 refresh() 刷新容器，<code>registerBeanPostProcessors(beanFactory)</code> 阶段，通过 getBean() 创建 AnnotationAwareAspectJAutoProxyCreator 对象，在生命周期的初始化方法中执行回调 initBeanFactory() 方法初始化注册三个工具类：BeanFactoryAdvisorRetrievalHelperAdapter、ReflectiveAspectJAdvisorFactory、BeanFactoryAspectJAdvisorsBuilderAdapter</p><hr><h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>Bean 初始化完成的执行后置处理器的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 【beanName 或者加上 &amp; 的 beanName】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该 key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAutoProxyCreator.wrapIfNecessary()：根据通知创建动态代理，没有通知直接返回原实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件一般不成立，很少使用 TargetSourceCreator 去创建对象 BeforeInstantiation 阶段，doCreateBean 之前的阶段</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// advisedBeans 集合保存的是 bean 是否被增强过了</span></span><br><span class="line">    <span class="comment">// 条件成立说明当前 beanName 对应的实例不需要被增强处理，判断是在 BeforeInstantiation 阶段做的</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件一：判断当前 bean 类型是否是基础框架类型，这个类的实例不能被增强</span></span><br><span class="line">    <span class="comment">// 条件二：shouldSkip 判断当前 beanName 是否是 .ORIGINAL 结尾，如果是就跳过增强逻辑，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【查找适合当前 bean 实例的增强方法】（下一节详解）</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 条件成立说明上面方法查询到适合当前class的通知</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 根据查询到的增强创建代理对象（下一节详解）</span></span><br><span class="line">        <span class="comment">// 参数一：目标对象</span></span><br><span class="line">        <span class="comment">// 参数二：beanName</span></span><br><span class="line">        <span class="comment">// 参数三：匹配当前目标对象 clazz 的 Advisor 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="comment">// 保存代理对象类型</span></span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行到这里说明没有查到通知，当前 bean 不需要增强</span></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="comment">// 【返回原始的 bean 实例】</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h4><p>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()：查找适合当前类实例的增强，并进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">// 查询适合当前类型的增强通知</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 增强为空直接返回 null，不需要创建代理</span></span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是空，转成数组返回</span></span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()：</p><ul><li><p><code>candidateAdvisors = findCandidateAdvisors()</code>：<strong>获取当前容器内可以使用（所有）的 advisor</strong>，调用的是 AnnotationAwareAspectJAutoProxyCreator 类的方法，每个方法对应一个 Advisor </p><ul><li><p><code>advisors = super.findCandidateAdvisors()</code>：<strong>查询出 XML 配置的所有 Advisor 类型</strong></p><ul><li><code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors()</code>：通过 BF 查询出来 BD 配置的 class 中 是 Advisor 子类的 BeanName</li><li><code>advisors.add()</code>：使用 Spring 容器获取当前这个 Advisor 类型的实例</li></ul></li><li><p><code>advisors.addAll(....buildAspectJAdvisors())</code>：<strong>获取所有添加 @Aspect 注解类中的 Advisor</strong></p><p><code>buildAspectJAdvisors()</code>：构建的方法，<strong>把 Advice 封装成 Advisor</strong></p><ul><li><p><code> beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)</code>：获取出容器内 Object 所有的 beanName，就是全部的</p></li><li><p><code> for (String beanName : beanNames)</code>：遍历所有的 beanName，判断每个 beanName 对应的 Class 是否是 Aspect 类型，就是加了 @Aspect 注解的类</p><ul><li><p><code>factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName)</code>：使用工厂模式管理 Aspect 的元数据，关联的真实 @Aspect 注解的实例对象</p></li><li><p><code>classAdvisors = this.advisorFactory.getAdvisors(factory)</code>：添加了 @Aspect 注解的类的通知信息</p><ul><li><p>aspectClass：@Aspect 标签的类的 class</p></li><li><p><code>for (Method method : getAdvisorMethods(aspectClass))</code>：遍历<strong>不包括 @Pointcut 注解的方法</strong></p><p><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName)</code>：<strong>将当前 method 包装成 Advisor 数据</strong></p><ul><li><p><code>AspectJExpressionPointcut expressionPointcut = getPointcut()</code>：获取切点表达式</p></li><li><p><code>return new InstantiationModelAwarePointcutAdvisorImpl()</code>：把 method 中 Advice 包装成 Advisor，Spring 中每个 Advisor 内部一定是持有一个 Advice 的，Advice 内部最重要的数据是当前 method 和aspectInstanceFactory，工厂用来获取实例</p><p><code>this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)</code>：实例化 Advice 对象，逻辑是获取注解信息，根据注解的不同生成对应的 Advice 对象</p></li></ul></li></ul></li><li><p><code>advisors.addAll(classAdvisors)</code>：保存通过 @Aspect 注解定义的 Advisor 数据</p></li></ul></li><li><p><code>this.aspectBeanNames = aspectNames</code>：将所有 @Aspect 注解 beanName 缓存起来，表示提取 Advisor 工作完成</p></li><li><p><code>return advisors</code>：返回 Advisor 列表</p></li></ul></li></ul></li><li><p><code>eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, ...)</code>：<strong>选出匹配当前类的增强</strong></p><ul><li><p><code>if (candidateAdvisors.isEmpty())</code>：条件成立说明当前 Spring 没有可以操作的 Advisor</p></li><li><p><code>List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;()</code>：存放匹配当前 beanClass 的 Advisors 信息</p></li><li><p><code>for (Advisor candidate : candidateAdvisors)</code>：<strong>遍历所有的 Advisor</strong></p><p><code> if (canApply(candidate, clazz, hasIntroductions))</code>：判断遍历的 advisor 是否匹配当前的 class，匹配就加入集合</p><ul><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：创建的 advisor 是 InstantiationModelAwarePointcutAdvisorImpl 类型</p><p><code>PointcutAdvisor pca = (PointcutAdvisor) advisor</code>：封装当前 Advisor</p><p><code>return canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>：重载该方法</p><ul><li><code>if (!pc.getClassFilter().matches(targetClass))</code>：<strong>类不匹配 Pointcut 表达式，直接返回 false</strong></li><li><code>methodMatcher = pc.getMethodMatcher()</code>：<strong>获取 Pointcut 方法匹配器</strong>，类匹配进行类中方法的匹配</li><li><code>Set&lt;Class&lt;?&gt;&gt; classes</code>：保存目标对象 class 和目标对象父类超类的接口和自身实现的接口</li><li><code>if (!Proxy.isProxyClass(targetClass))</code>：判断当前实例是不是代理类，确保 class 内存储的数据包括目标对象的class  而不是代理类的 class</li><li><code>for (Class&lt;?&gt; clazz : classes)</code>：<strong>检查目标 class 和上级接口的所有方法，查看是否会被方法匹配器匹配</strong>，如果有一个方法匹配成功，就说明目标对象 AOP 代理需要增强<ul><li><code>specificMethod = AopUtils.getMostSpecificMethod(method, targetClass)</code>：方法可能是接口的，判断当前类有没有该方法</li><li><code>return (specificMethod != method &amp;&amp; matchesMethod(specificMethod))</code>：<strong>类和方法的匹配</strong>，不包括参数</li></ul></li></ul></li></ul></li></ul></li><li><p><code>extendAdvisors(eligibleAdvisors)</code>：在 eligibleAdvisors 列表的索引 0 的位置添加 DefaultPointcutAdvisor，<strong>封装了 ExposeInvocationInterceptor 拦截器</strong></p></li><li><p><code> eligibleAdvisors = sortAdvisors(eligibleAdvisors)</code>：<strong>对拦截器进行排序</strong>，数值越小优先级越高，高的排在前面</p><ul><li>实现 Ordered 或 PriorityOrdered 接口，PriorityOrdered 的级别要优先于 Ordered，使用 OrderComparator 比较器</li><li>使用 @Order（Spring 规范）或 @Priority（JDK 规范）注解，使用 AnnotationAwareOrderComparator 比较器</li><li>ExposeInvocationInterceptor 实现了 PriorityOrdered ，所以总是排在第一位，MethodBeforeAdviceInterceptor 没实现任何接口，所以优先级最低，排在最后</li></ul></li><li><p><code>return eligibleAdvisors</code>：返回拦截器链</p></li></ul><hr><h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><p>AbstractAutoProxyCreator.createProxy()：根据增强方法创建代理对象</p><ul><li><p><code>ProxyFactory proxyFactory = new ProxyFactory()</code>：<strong>无参构造 ProxyFactory</strong>，此处讲解一下两种有参构造方法：</p><ul><li><p>public ProxyFactory(Object target)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"><span class="comment">// 将目标对象封装成 SingletonTargetSource 保存到父类的字段中</span></span><br><span class="line">   setTarget(target);</span><br><span class="line">    <span class="comment">// 获取目标对象 class 所有接口保存到 AdvisedSupport 中的 interfaces 集合中</span></span><br><span class="line">   setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassUtils.getAllInterfaces(target) 底层调用 getAllInterfacesForClassAsSet(java.lang.Class&lt;?&gt;, java.lang.ClassLoader)：</p><ul><li><code>if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader))</code>：<ul><li>条件一：判断当前目标对象是接口</li><li>条件二：检查给定的类在给定的 ClassLoader 中是否可见</li></ul></li><li><code>Class&lt;?&gt;[] ifcs = current.getInterfaces()</code>：拿到自己实现的接口，拿不到接口实现的接口</li><li><code>current = current.getSuperclass()</code>：递归寻找父类的接口，去获取父类实现的接口</li></ul></li><li><p>public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个代理的接口</span></span><br><span class="line">    addInterface(proxyInterface);</span><br><span class="line">    <span class="comment">// 添加通知，底层调用 addAdvisor</span></span><br><span class="line">    addAdvice(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>addAdvisor(pos, new DefaultPointcutAdvisor(advice))</code>：Spring 中 Advice 对应的接口就是 Advisor，Spring 使用 Advisor 包装 Advice 实例</li></ul></li></ul></li><li><p><code>proxyFactory.copyFrom(this)</code>：填充一些信息到 proxyFactory</p></li><li><p><code>if (!proxyFactory.isProxyTargetClass())</code>：条件成立说明 proxyTargetClass 为 false（默认），两种配置方法：</p><ul><li><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; </code>：强制使用 CGLIB</li><li><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></li></ul><p><code>if (shouldProxyTargetClass(beanClass, beanName))</code>：如果 bd 内有 preserveTargetClass &#x3D; true ，那么这个 bd 对应的 class <strong>创建代理时必须使用 CGLIB</strong>，条件成立设置 proxyTargetClass 为 true</p><p><code>evaluateProxyInterfaces(beanClass, proxyFactory)</code>：<strong>根据目标类判定是否可以使用 JDK 动态代理</strong></p><ul><li><code>targetInterfaces = ClassUtils.getAllInterfacesForClass()</code>：获取当前目标对象 class 和父类的全部实现接口</li><li><code>boolean hasReasonableProxyInterface = false</code>：实现的接口中是否有一个合理的接口</li><li><code>if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0)</code>：遍历所有的接口，如果有任意一个接口满足条件，设置 hRPI 变量为 true<ul><li>条件一：判断当前接口是否是 Spring 生命周期内会回调的接口</li><li>条件二：接口不能是 GroovyObject、Factory、MockAccess 类型的</li><li>条件三：找到一个可以使用的被代理的接口</li></ul></li><li><code>if (hasReasonableProxyInterface)</code>：<strong>有合理的接口，将这些接口设置到 proxyFactory 内</strong></li><li><code>proxyFactory.setProxyTargetClass(true)</code>：<strong>没有合理的代理接口，强制使用 CGLIB 创建对象</strong></li></ul></li><li><p><code>advisors = buildAdvisors(beanName, specificInterceptors)</code>：匹配目标对象 clazz 的 Advisors，填充至 ProxyFactory</p></li><li><p><code>proxyFactory.setPreFiltered(true)</code>：设置为 true 表示传递给 proxyFactory 的 Advisors 信息做过基础类和方法的匹配</p></li><li><p><code>return proxyFactory.getProxy(getProxyClassLoader())</code>：创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)：参数是一个配置对象，保存着创建代理需要的生产资料，会加锁创建，保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 条件二为 true 代表强制使用 CGLIB 动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || </span><br><span class="line">        <span class="comment">// 条件三：被代理对象没有实现任何接口或者只实现了 SpringProxy 接口，只能使用 CGLIB 动态代理</span></span><br><span class="line">        hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立说明 target 【是接口或者是已经被代理过的类型】，只能使用 JDK 动态代理</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);<span class="comment">// 使用 JDK 动态代理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);<span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);<span class="comment">// 【有接口的情况下只能使用 JDK 动态代理】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JdkDynamicAopProxy.getProxy(java.lang.ClassLoader)：获取 JDK 的代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 配置类封装到 JdkDynamicAopProxy.advised 属性中</span></span><br><span class="line">    <span class="built_in">this</span>.advised = config;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取需要代理的接口数组</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找当前所有的需要代理的接口，看是否有 equals 方法和 hashcode 方法，如果有就做一个标记</span></span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法最终返回一个代理类对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// classLoader：类加载器  proxiedInterfaces：生成的代理类，需要实现的接口集合</span></span><br><span class="line">    <span class="comment">// this JdkDynamicAopProxy 实现了 InvocationHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopProxyUtils.completeProxiedInterfaces(this.advised, true)：获取代理的接口数组，并添加 SpringProxy 接口</p><ul><li><p><code>specifiedInterfaces = advised.getProxiedInterfaces()</code>：从 ProxyFactory 中拿到所有的 target 提取出来的接口</p><ul><li><code>if (specifiedInterfaces.length == 0)</code>：如果没有实现接口，检查当前 target 是不是接口或者已经是代理类，封装到 ProxyFactory 的 interfaces 集合中</li></ul></li><li><p><code> addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)</code>：判断目标对象所有接口中是否有 SpringProxy 接口，没有的话需要添加，这个接口<strong>标识这个代理类型是 Spring 管理的</strong></p><ul><li><code>addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>：判断目标对象的所有接口，是否已经有 Advised 接口</li><li><code> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class))</code>：判断目标对象的所有接口，是否已经有 DecoratingProxy 接口</li><li><code>int nonUserIfcCount = 0</code>：非用户自定义的接口数量，接下来要添加上面的三个接口了</li><li><code>proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount]</code>：创建一个新的 class 数组，长度是原目标对象提取出来的接口数量和 Spring 追加的数量，然后进行 <strong>System.arraycopy 拷贝到新数组中</strong></li><li><code>int index = specifiedInterfaces.length</code>：获取原目标对象提取出来的接口数量，当作 index</li><li><code>if(addSpringProxy)</code>：根据上面三个布尔值把接口添加到新数组中</li><li><code>return proxiedInterfaces</code>：返回追加后的接口集合</li></ul></li></ul><p>JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods()：查找在任何定义在接口中的 equals 和 hashCode 方法</p><ul><li><code>for (Class&lt;?&gt; proxiedInterface : proxiedInterfaces)</code>：遍历所有的接口<ul><li><p><code> Method[] methods = proxiedInterface.getDeclaredMethods()</code>：获取接口中的所有方法</p></li><li><p><code>for (Method method : methods)</code>：遍历所有的方法</p><ul><li><code>if (AopUtils.isEqualsMethod(method))</code>：当前方法是 equals 方法，把 equalsDefined 置为 true</li><li><code>if (AopUtils.isHashCodeMethod(method))</code>：当前方法是 hashCode 方法，把 hashCodeDefined 置为 true</li></ul></li><li><p><code>if (this.equalsDefined &amp;&amp; this.hashCodeDefined)</code>：如果有一个接口中有这两种方法，直接返回</p></li></ul></li></ul></li></ul><hr><h4 id="方法增强"><a href="#方法增强" class="headerlink" title="方法增强"></a>方法增强</h4><p>main() 函数中调用用户方法，会进入代理对象的 invoke 方法</p><p>JdkDynamicAopProxy 类中的 invoke 方法是真正执行代理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy：代理对象，method：目标对象的方法，args：目标对象方法对应的参数</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advised 就是初始化 JdkDynamicAopProxy 对象时传入的变量</span></span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 条件成立说明代理类实现的接口没有定义 equals 方法，并且当前 method 调用 equals 方法，</span></span><br><span class="line">        <span class="comment">// 就调用 JdkDynamicAopProxy 提供的 equals 方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line"><span class="comment">// 需不需要暴露当前代理对象到 AOP 上下文内</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 【把代理对象设置到上下文环境】</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 targetSource 获取真正的代理对象</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找【适合该方法的增强】，首先从缓存中查找，查找不到进入主方法【下文详解】</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截器链是空，说明当前 method 不需要被增强</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有匹配当前 method 的方法拦截器，要做增强处理，把方法信息封装到方法调用器里</span></span><br><span class="line">            <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// 【拦截器链驱动方法，核心】</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">          <span class="comment">// 如果目标方法返回目标对象，这里做个普通替换返回代理对象</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果允许了提前暴露，这里需要设置为初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// 当前代理对象已经完成工作，【把原始对象设置回上下文】</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)：查找适合该方法的增强，首先从缓存中查找，获取通知时是从全部增强中获取适合当前类的，这里是<strong>从当前类的中获取适合当前方法的增强</strong></p><ul><li><p><code>AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance()</code>：向容器注册适配器，<strong>可以将非 Advisor 类型的增强，包装成为 Advisor，将 Advisor 类型的增强提取出来对应的 MethodInterceptor</strong></p><ul><li><p><code>instance = new DefaultAdvisorAdapterRegistry()</code>：该对象向容器中注册了 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter 三个适配器</p></li><li><p>Advisor 中持有 Advice 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advisor</span> &#123;</span><br><span class="line">Advice <span class="title function_">getAdvice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>advisors = config.getAdvisors()</code>：获取 ProxyFactory 内部持有的增强信息</p></li><li><p><code>interceptorList = new ArrayList&lt;&gt;(advisors.length)</code>：拦截器列表有 5 个，1 个 ExposeInvocation和 4 个增强器</p></li><li><p><code>actualClass = (targetClass != null ? targetClass : method.getDeclaringClass())</code>：真实的目标对象类型</p></li><li><p><code>Boolean hasIntroductions = null</code>：引介增强，不关心</p></li><li><p><code>for (Advisor advisor : advisors)</code>：<strong>遍历所有的 advisor 增强</strong></p></li><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：条件成立说明当前 Advisor 是包含切点信息的，进入匹配逻辑</p><p><code>pointcutAdvisor = (PointcutAdvisor) advisor</code>：转成可以获取到切点信息的接口</p><p><code>if(config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass))</code>：当前代理被预处理，或者当前被代理的 class 对象匹配当前 Advisor 成功，只是 class 匹配成功</p><ul><li><p><code>mm = pointcutAdvisor.getPointcut().getMethodMatcher()</code>：获取切点的方法匹配器，不考虑引介增强</p></li><li><p><code>match = mm.matches(method, actualClass)</code>：<strong>静态匹配成功返回 true，只关注于处理类及其方法，不考虑参数</strong></p></li><li><p><code>if (match)</code>：如果静态切点检查是匹配的，在运行的时候才进行<strong>动态切点检查，会考虑参数匹配</strong>（代表传入了参数）。如果静态匹配失败，直接不需要进行参数匹配，提高了工作效率</p><p><code>interceptors = registry.getInterceptors(advisor)</code>：提取出当前 advisor 内持有的 advice 信息 </p><ul><li><p><code>Advice advice = advisor.getAdvice()</code>：获取增强方法</p></li><li><p><code>if (advice instanceof MethodInterceptor)</code>：当前 advice 是 MethodInterceptor 直接加入集合</p></li><li><p><code>for (AdvisorAdapter adapter : this.adapters)</code>：<strong>遍历三个适配器进行匹配</strong>（初始化时创建的），匹配成功创建对应的拦截器返回，以 MethodBeforeAdviceAdapter 为例</p><p><code>if (adapter.supportsAdvice(advice))</code>：判断当前 advice 是否是对应的 MethodBeforeAdvice</p><p><code>interceptors.add(adapter.getInterceptor(advisor))</code>：条件成立就往拦截器链中添加 advisor</p><ul><li><code>advice = (MethodBeforeAdvice) advisor.getAdvice()</code>：<strong>获取增强方法</strong></li><li><code>return new MethodBeforeAdviceInterceptor(advice)</code>：<strong>封装成 MethodBeforeAdviceInterceptor 返回</strong></li></ul></li></ul><p><code>interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm))</code>：向拦截器链添加动态匹配器</p><p><code>interceptorList.addAll(Arrays.asList(interceptors))</code>：将当前 advisor 内部的方法拦截器追加到 interceptorList</p></li></ul></li><li><p><code>interceptors = registry.getInterceptors(advisor)</code>：进入 else 的逻辑，说明当前 Advisor 匹配全部 class 的全部 method，全部加入到 interceptorList</p></li><li><p><code>return interceptorList</code>：返回 method 方法的拦截器链</p></li></ul><p>retVal &#x3D; invocation.proceed()：<strong>拦截器链驱动方法</strong></p><ul><li><p><code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code>：条件成立说明方法拦截器全部都已经调用过了（index 从 - 1 开始累加），接下来需要执行目标对象的目标方法</p><p><code>return invokeJoinpoint()</code>：<strong>调用连接点（目标）方法</strong></p></li><li><p><code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>：<strong>获取下一个方法拦截器</strong></p></li><li><p><code>if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)</code>：需要运行时匹配</p><p><code>if (dm.methodMatcher.matches(this.method, targetClass, this.arguments))</code>：判断是否匹配成功</p><ul><li><code>return dm.interceptor.invoke(this)</code>：匹配成功，执行方法</li><li><code>return proceed()</code>：匹配失败跳过当前拦截器</li></ul></li><li><p><code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>：<strong>一般方法拦截器都会执行到该方法，此方法内继续执行 proceed() 完成责任链的驱动，直到最后一个  MethodBeforeAdviceInterceptor 调用前置通知，然后调用 mi.proceed()，发现是最后一个拦截器就直接执行连接点（目标方法），return 到上一个拦截器的 mi.proceed() 处，依次返回到责任链的上一个拦截器执行通知方法</strong></p></li></ul><p>图示先从上往下建立链，然后从下往上依次执行，责任链模式</p><ul><li><p>正常执行：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 返回通知</p></li><li><p>出现异常：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 异常通知</p></li><li><p>MethodBeforeAdviceInterceptor 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先执行通知方法，再驱动责任链</span></span><br><span class="line">    <span class="built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="comment">// 开始驱动目标方法执行，执行完后返回到这，然后继续向上层返回</span></span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AfterReturningAdviceInterceptor 源码：没有任何异常处理机制，直接抛给上层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先驱动责任链，再执行通知方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> mi.proceed();</span><br><span class="line">    <span class="built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJAfterThrowingAdvice 执行异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认直接驱动责任链</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 出现错误才执行该方法</span></span><br><span class="line">        <span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">            invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png"></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></p><hr><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><h4 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h4><h5 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>容器启动时会根据注解注册对应的解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// 注册解析器</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span>());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> <span class="title class_">JtaTransactionManagerBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取对应的解析器 NamespaceHandlerSupport#findParserForElement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanDefinitionParser <span class="title function_">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    <span class="comment">// 获取对应的解析器</span></span><br><span class="line">    <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.parsers.get(localName);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用解析器的方法对 XML 文件进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"><span class="comment">// 向Spring容器注册了一个 BD -&gt; TransactionalEventListenerFactory.class</span></span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">            registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;proxy&quot;，默认逻辑，不配置 mode 时</span></span><br><span class="line">        <span class="comment">// 用来向容器中注入一些 BeanDefinition，包括事务增强器、事务拦截器、注解解析器</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>@EnableTransactionManagement 导入 TransactionManagementConfigurationSelector，该类给 Spring 容器中两个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="comment">// 导入 AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration（默认）</span></span><br><span class="line">        <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">        <span class="comment">// 导入 AspectJTransactionManagementConfiguration（与声明式事务无关）</span></span><br><span class="line">        <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoProxyRegistrar：给容器中注册 InfrastructureAdvisorAutoProxyCreator，<strong>利用后置处理器机制拦截 bean 以后包装并返回一个代理对象</strong>，代理对象中保存所有的拦截器，利用拦截器的链式机制依次进入每一个拦截器中进行拦截执行（就是 AOP 原理）</p><p>ProxyTransactionManagementConfiguration：是一个 Spring 的事务配置类，注册了三个 Bean：</p><ul><li>BeanFactoryTransactionAttributeSourceAdvisor：事务驱动，利用注解 @Bean 把该类注入到容器中，该增强器有两个字段：</li><li>TransactionAttributeSource：解析事务注解的相关信息，真实类型是 AnnotationTransactionAttributeSource，构造方法中注册了三个<strong>注解解析器</strong>，解析 Spring、JTA、Ejb3 三种类型的事务注解</li><li>TransactionInterceptor：<strong>事务拦截器</strong>，代理对象执行拦截器方法时，调用 TransactionInterceptor 的 invoke 方法，底层调用TransactionAspectSupport.invokeWithinTransaction()，通过 PlatformTransactionManager 控制着事务的提交和回滚，所以事务的底层原理就是通过 AOP 动态织入，进行事务开启和提交</li></ul><p>注解解析器 SpringTransactionAnnotationParser <strong>解析 @Transactional 注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="type">RuleBasedTransactionAttribute</span> <span class="variable">rbta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleBasedTransactionAttribute</span>();</span><br><span class="line"><span class="comment">// 从注解信息中获取传播行为</span></span><br><span class="line">    <span class="type">Propagation</span> <span class="variable">propagation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">    rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">    <span class="comment">// 获取隔离界别</span></span><br><span class="line">    <span class="type">Isolation</span> <span class="variable">isolation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">    rbta.setIsolationLevel(isolation.value());</span><br><span class="line">    rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">    <span class="comment">// 从注解信息中获取 readOnly 参数</span></span><br><span class="line">    rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">    <span class="comment">// 从注解信息中获取 value 信息并且设置 qualifier，表示当前事务指定使用的【事务管理器】</span></span><br><span class="line">    rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">// 【存放的是 rollback 条件】，回滚规则放在这个集合</span></span><br><span class="line">    List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示事务碰到哪些指定的异常才进行回滚，不指定的话默认是 RuntimeException/Error 非检查型异常菜回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与 rollbackFor 功能相同</span></span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示事务碰到指定的 exception 实现对象不进行回滚，否则碰到其他的class就进行回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置回滚规则</span></span><br><span class="line">    rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="驱动方法"><a href="#驱动方法" class="headerlink" title="驱动方法"></a>驱动方法</h4><p>TransactionInterceptor 事务拦截器的核心驱动方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// targetClass 是需要被事务增强器增强的目标类，invocation.getThis() → 目标对象 → 目标类</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 参数一是目标方法，参数二是目标类，参数三是方法引用，用来触发驱动方法</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务属性源信息</span></span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">//  提取 @Transactional 注解信息，txAttr 是注解信息的承载对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 获取 Spring 配置的事务管理器</span></span><br><span class="line">    <span class="comment">// 首先会检查是否通过XML或注解配置 qualifier，没有就尝试去容器获取，一般情况下为 DatasourceTransactionManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="comment">// 权限定类名.方法名，该值用来当做事务名称使用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 条件成立说明是【声明式事务】</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">    <span class="comment">// 用来【开启事务】</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an 【around advice】: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// 环绕通知，执行目标方法（方法引用方式，invocation::proceed，还是调用 proceed）</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//  执行业务代码时抛出异常，执行回滚逻辑</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理事务的信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务的入口</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 编程式事务，省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><h5 id="事务绑定"><a href="#事务绑定" class="headerlink" title="事务绑定"></a>事务绑定</h5><p>创建事务的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">                                                       <span class="meta">@Nullable</span> TransactionAttribute txAttr, </span></span><br><span class="line"><span class="params">                                                       <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务的名称： 类的权限定名.方法名</span></span><br><span class="line">        txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过事务管理器根据事务属性创建事务状态对象，事务状态对象一般情况下包装着 事务对象，当然也有可能是null</span></span><br><span class="line">            <span class="comment">// 方法上的注解为 @Transactional(propagation = NOT_SUPPORTED || propagation = NEVER) 时</span></span><br><span class="line">            <span class="comment">// 【下一小节详解】</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">                             <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 包装成一个上层的事务上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionAspectSupport#prepareTransactionInfo：为事务的属性和状态准备一个事务信息对象</p><ul><li><code>TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification)</code>：创建事务信息对象</li><li><code>txInfo.newTransactionStatus(status)</code>：填充事务的状态信息</li><li><code>txInfo.bindToThread()</code>：利用 ThreadLocal <strong>把当前事务信息绑定到当前线程</strong>，不同的事务信息会形成一个栈的结构<ul><li><code>this.oldTransactionInfo = transactionInfoHolder.get()</code>：获取其他事务的信息存入 oldTransactionInfo </li><li><code>transactionInfoHolder.set(this)</code>：将当前的事务信息设置到 ThreadLocalMap 中</li></ul></li></ul><hr><h5 id="事务创建"><a href="#事务创建" class="headerlink" title="事务创建"></a>事务创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 获取事务的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">        definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 条件成立说明当前是事务重入的情况，事务中有 ConnectionHolder 对象</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// a方法开启事务，a方法内调用b方法，b方法仍然加了 @Transactional 注解，需要检查传播行为</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 逻辑到这说明当前线程没有连接资源，一个连接对应一个事务，没有连接就相当于没有开启事务</span></span><br><span class="line">    <span class="comment">// 检查事务的延迟属性</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传播行为是 MANDATORY，没有事务就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要开启事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 什么也没挂起，因为线程并没有绑定事务</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否支持同步线程事务，一般是 true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 新建一个事务状态信息</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 【启动事务】</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 设置线程上下文变量，方便程序运行期间获取当前事务的一些核心的属性，initSynchronization() 启动同步</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不支持事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建事务状态对象</span></span><br><span class="line">        <span class="comment">// 参数2 transaction 是 null 说明当前事务状态是未手动开启事，线程上未绑定任何的连接资源，业务程序执行时需要先去 datasource 获取的 conn，是自动提交事务的，不需要 Spring 再提交事务</span></span><br><span class="line">        <span class="comment">// 参数6 suspendedResources 是 null 说明当前事务状态未挂起任何事务，当前事务执行到后置处理时不需要恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceTransactionManager#doGetTransaction：真正获取事务的方法</p><ul><li><p><code>DataSourceTransactionObject txObject = new DataSourceTransactionObject()</code>：<strong>创建事务对象</strong></p></li><li><p><code>txObject.setSavepointAllowed(isNestedAllowed())</code>：设置事务对象是否支持保存点，由事务管理器控制（默认不支持）</p></li><li><p><code>ConnectionHolder conHolder = TransactionSynchronizationManager.getResource(obtainDataSource())</code>：</p><ul><li><p>从 ThreadLocal 中获取 conHolder 资源，可能拿到 null 或者不是 null</p></li><li><p>是 null：举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;...b.b()....&#125;</span><br></pre></td></tr></table></figure></li><li><p>不是 null：执行 b 方法事务增强的前置逻辑时，可以拿到 a 放进去的 conHolder 资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;....&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>txObject.setConnectionHolder(conHolder, false)</code>：将 ConnectionHolder 保存到事务对象内，参数二是 false 代表连接资源是上层事务共享的，不是新建的连接资源</p></li><li><p><code>return txObject</code>：返回事务的对象</p></li></ul><p>DataSourceTransactionManager#doBegin：事务开启的逻辑</p><ul><li><p><code>txObject = (DataSourceTransactionObject) transaction</code>：强转为事务对象</p></li><li><p>事务中没有数据库连接资源就要分配：</p><p><code>Connection newCon = obtainDataSource().getConnection()</code>：<strong>获取 JDBC 原生的数据库连接对象</strong></p><p><code>txObject.setConnectionHolder(new ConnectionHolder(newCon), true)</code>：代表是新开启的事务，新建的连接对象</p></li><li><p><code>previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)</code>：修改连接属性</p><ul><li><p><code>if (definition != null &amp;&amp; definition.isReadOnly())</code>：注解（或 XML）配置了只读属性，需要设置</p></li><li><p><code>if (..definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT)</code>：注解配置了隔离级别</p><p><code>int currentIsolation = con.getTransactionIsolation()</code>：获取连接的隔离界别</p><p><code>previousIsolationLevel = currentIsolation</code>：保存之前的隔离界别，返回该值</p><p><code> con.setTransactionIsolation(definition.getIsolationLevel())</code>：<strong>将当前连接设置为配置的隔离界别</strong></p></li></ul></li><li><p><code>txObject.setPreviousIsolationLevel(previousIsolationLevel)</code>：将 Conn 原来的隔离级别保存到事务对象，为了释放 Conn 时重置回原状态</p></li><li><p><code>if (con.getAutoCommit())</code>：默认会成立，说明还没开启事务</p><p><code>txObject.setMustRestoreAutoCommit(true)</code>：保存 Conn 原来的事务状态</p><p><code>con.setAutoCommit(false)</code>：<strong>开启事务，JDBC 原生的方式</strong></p></li><li><p><code>txObject.getConnectionHolder().setTransactionActive(true)</code>：表示 Holder 持有的 Conn 已经手动开启事务了</p></li><li><p><code>TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())</code>：将 ConnectionHolder 对象绑定到 ThreadLocal 内，数据源为 key，为了方便获取手动开启事务的连接对象去执行 SQL</p></li></ul><hr><h5 id="事务重入"><a href="#事务重入" class="headerlink" title="事务重入"></a>事务重入</h5><p>事务重入的核心处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">handleExistingTransaction</span><span class="params">( TransactionDefinition definition, </span></span><br><span class="line"><span class="params">                                                    Object transaction, <span class="type">boolean</span> debugEnabled)</span>&#123;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NEVER，需要以非事务方式执行操作，如果当前事务存在则【抛出异常】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NOT_SUPPORTED，以非事务方式运行，如果当前存在事务，则【把当前事务挂起】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="comment">// 挂起事务</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建一个非事务的事务状态对象返回</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 开启新事物的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="comment">// 【挂起当前事务】</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">       <span class="comment">// 【开启新事物】</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NESTED，嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// Spring 默认不支持内嵌事务</span></span><br><span class="line">        <span class="comment">// 【开启方式】：&lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot;&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedTransactionNotSupportedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">            <span class="comment">//  为当前方法创建一个 TransactionStatus 对象，</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span></span><br><span class="line">                prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, <span class="literal">false</span>, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 创建一个 JDBC 的保存点</span></span><br><span class="line">            status.createAndHoldSavepoint();</span><br><span class="line">            <span class="comment">// 不需要使用同步，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Usually only for JTA transaction，开启一个新事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED，【使用当前的事务】</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="挂起恢复"><a href="#挂起恢复" class="headerlink" title="挂起恢复"></a>挂起恢复</h5><p>AbstractPlatformTransactionManager#suspend：<strong>挂起事务</strong>，并获得一个上下文信息对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title function_">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务是同步状态的</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (transaction != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// do it</span></span><br><span class="line">                suspendedResources = doSuspend(transaction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将上层事务绑定在线程上下文的变量全部取出来</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 通过被挂起的资源和上层事务的上下文变量，创建一个【SuspendedResourcesHolder】返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuspendedResourcesHolder</span>(suspendedResources, suspendedSynchronizations, </span><br><span class="line">                                                name, readOnly, isolationLevel, wasActive);</span><br><span class="line">        &#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doSuspend</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="comment">// 将当前方法的事务对象 connectionHolder 属性置为 null，不和上层共享资源</span></span><br><span class="line">    <span class="comment">// 当前方法有可能是不开启事务或者要开启一个独立的事务</span></span><br><span class="line">    txObject.setConnectionHolder(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 【解绑在线程上的事务】</span></span><br><span class="line">    <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#resume：<strong>恢复现场</strong>，根据挂起资源去恢复线程上下文信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">(Object transaction, SuspendedResourcesHolder resourcesHolder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resourcesHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取被挂起的事务资源</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> resourcesHolder.suspendedResources;</span><br><span class="line">        <span class="keyword">if</span> (suspendedResources != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//绑定上一个事务的 ConnectionHolder 到线程上下文</span></span><br><span class="line">            doResume(transaction, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">        <span class="keyword">if</span> (suspendedSynchronizations != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            <span class="comment">// 将线程上下文变量恢复为上一个事务的挂起现场</span></span><br><span class="line">            doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doResume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, Object suspendedResources)</span> &#123;</span><br><span class="line">    <span class="comment">// doSuspend 的逆动作，【绑定资源】</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="提交回滚"><a href="#提交回滚" class="headerlink" title="提交回滚"></a>提交回滚</h4><h5 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务状态信息不为空进入逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 条件二成立 说明目标方法抛出的异常需要回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 事务管理器的回滚方法</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到这里，说明当前事务虽然抛出了异常，但是该异常并不会导致整个事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 继承自 RuntimeException 或 error 的是【非检查型异常】，才会归滚事务</span></span><br><span class="line">    <span class="comment">// 如果配置了其他回滚错误，会获取到回滚规则 rollbackRules 进行判断</span></span><br><span class="line">    <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 事务已经完成不需要回滚</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 开始回滚事务</span></span><br><span class="line">    processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#processRollback：事务回滚</p><ul><li><p><code>triggerBeforeCompletion(status)</code>：用来做扩展逻辑，回滚前的前置处理</p></li><li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，当前方法只是复用了上层事务的一个内嵌事务</p><p><code>status.rollbackToHeldSavepoint()</code>：内嵌事务加入事务时会创建一个保存点，此时恢复至保存点</p></li><li><p><code>if (status.isNewTransaction())</code>：说明事务是当前连接开启的，需要去回滚事务</p><p><code>doRollback(status)</code>：真正的的回滚函数</p><ul><li><code>DataSourceTransactionObject txObject = status.getTransaction()</code>：获取事务对象</li><li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li><li><code>con.rollback()</code>：<strong>JDBC 的方式回滚事务</strong></li></ul></li><li><p><code>else</code>：当前方法是共享的上层的事务，和上层使用同一个 Conn 资源，<strong>共享的事务不能直接回滚，应该交给上层处理</strong></p><p><code>doSetRollbackOnly(status)</code>：设置 con.rollbackOnly &#x3D; true，线程回到上层事务 commit 时会检查该字段，然后执行回滚操作</p></li><li><p><code>triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)</code>：回滚的后置处理</p></li><li><p><code>cleanupAfterCompletion(status)</code>：清理和恢复现场</p></li></ul><hr><h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务管理器的提交方法</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 已经完成的事务不需要提交了</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 条件成立说明是当前的业务强制回滚</span></span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 回滚逻辑，</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 成立说明共享当前事务的【下层事务逻辑出错，需要回滚】</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前事务还是事务重入，会继续抛给上层，最上层事务会进行真实的事务回滚操作</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行提交</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#processCommit：事务提交</p><ul><li><p><code>prepareForCommit(status)</code>：前置处理</p></li><li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，只是复用了上层事务</p><p><code>status.releaseHeldSavepoint()</code>：清理保存点，因为没有发生任何异常，所以保存点没有存在的意义了</p></li><li><p><code>if (status.isNewTransaction())</code>：说明事务是归属于当前连接的，需要去提交事务</p><p><code>doCommit(status)</code>：真正的提交函数</p><ul><li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li><li><code>con.commit()</code>：<strong>JDBC 的方式提交事务</strong></li></ul></li><li><p><code>doRollbackOnCommitException(status, ex)</code>：<strong>提交事务出错后进行回滚</strong></p></li><li><p><code> cleanupAfterCompletion(status)</code>：清理和恢复现场</p></li></ul><hr><h5 id="清理现场"><a href="#清理现场" class="headerlink" title="清理现场"></a>清理现场</h5><p>恢复上层事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cleanupTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的 ThreadLocal 获取上层的事务信息，将当前事务出栈，继续执行上层事务</span></span><br><span class="line">        txInfo.restoreThreadLocalStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restoreThreadLocalStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">    transactionInfoHolder.set(<span class="built_in">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前层级事务结束时的清理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前方法的事务状态为完成状态</span></span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        <span class="comment">// 清理线程上下文变量以及扩展点注册的 sync</span></span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事务是当前线程开启的</span></span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="comment">// 解绑资源</span></span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件成立说明当前事务执行的时候，【挂起了一个上层的事务】</span></span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> (status.hasTransaction() ? status.getTransaction() : <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 恢复上层事务现场</span></span><br><span class="line">        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceTransactionManager#doCleanupAfterCompletion：清理工作</p><ul><li><p><code>TransactionSynchronizationManager.unbindResource(obtainDataSource())</code>：解绑数据库资源</p></li><li><p><code>if (txObject.isMustRestoreAutoCommit())</code>：是否恢复连接，Conn 归还到 DataSource<strong>，归还前需要恢复到申请时的状态</strong></p><p><code>con.setAutoCommit(true)</code>：恢复连接为自动提交</p></li><li><p><code>DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel())</code>：恢复隔离级别</p></li><li><p><code>DataSourceUtils.releaseConnection(con, this.dataSource)</code>：<strong>将连接归还给数据库连接池</strong></p></li><li><p><code>txObject.getConnectionHolder().clear()</code>：清理 ConnectionHolder 资源</p></li></ul><hr><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>@Component 解析流程：</p><ul><li><p>注解类启动容器的时，注册 ClassPathBeanDefinitionScanner 到容器，用来扫描 Bean 的相关信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历指定的所有的包，【这就相当于扫描了】</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 读取当前包下的资源装换为 BeanDefinition，字节流的方式</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">// 遍历，封装，类似于 XML 的解析方式，注册到容器中</span></span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern</code> ：将 package 转化为 ClassLoader 类资源搜索路径 packageSearchPath，例如：<code>com.sea.spring.boot</code> 转化为 <code>classpath*:com/sea/spring/boot/**/*.class</code></p></li><li><p><code>resources = getResourcePatternResolver().getResources(packageSearchPath)</code>：加载路径下的资源</p></li><li><p><code>for (Resource resource : resources) </code>：遍历所有的资源</p><p><code>metadataReader = getMetadataReaderFactory().getMetadataReader(resource)</code>：获取元数据阅读器</p><p><code>if (isCandidateComponent(metadataReader))</code>：<strong>当前类不匹配任何排除过滤器，并且匹配一个包含过滤器</strong>，返回 true</p><ul><li><p>includeFilters 由 <code>registerDefaultFilters()</code> 设置初始值，方法有 @Component，没有 @Service，因为 @Component 是 @Service 的元注解，Spring 在读取 @Service 时也读取了元注解，并将 @Service 作为 @Component 处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class))</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// 拥有了 Component 功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>candidates.add(sbd)</code>：添加到返回结果的 list</p></li></ul></li></ul><p>参考文章：<a href="https://my.oschina.net/floor/blog/4325651">https://my.oschina.net/floor/blog/4325651</a></p><hr><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h4><p>打开 @Autowired 源码，注释上写 Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor</p><p>AutowiredAnnotationBeanPostProcessor 间接实现 InstantiationAwareBeanPostProcessor，就具备了实例化前后（而不是初始化前后）管理对象的能力，实现了 BeanPostProcessor，具有初始化前后管理对象的能力，实现 BeanFactoryAware，具备随时拿到 BeanFactory 的能力，所以这个类<strong>具备一切后置处理器的能力</strong></p><p><strong>在容器启动，为对象赋值的时候，遇到 @Autowired 注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是 Autowired 的原理</strong></p><p>作用时机：</p><ul><li>Spring 在每个 Bean 实例化之后，调用 AutowiredAnnotationBeanPostProcessor 的 <code>postProcessMergedBeanDefinition()</code> 方法，查找该 Bean 是否有 @Autowired 注解，进行相关元数据的获取</li><li>Spring 在每个 Bean 调用 <code>populateBean()</code> 进行属性注入的时候，即调用 <code>postProcessProperties()</code> 方法，查找该 Bean 属性是否有 @Autowired 注解，进行相关数据的填充</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="Spring全家桶" scheme="http://example.com/categories/Java/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring全家桶" scheme="http://example.com/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="JavaWeb" scheme="http://example.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2022/08/16/JVM/"/>
    <id>http://example.com/2022/08/16/JVM/</id>
    <published>2022-08-16T11:06:36.440Z</published>
    <updated>2022-08-16T11:23:05.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作</p><p>特点：</p><ul><li>Java 虚拟机基于<strong>二进制字节码</strong>执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><p>Java 代码执行流程：<code>Java 程序 --（编译）--&gt; 字节码文件 --（解释执行）--&gt; 操作系统（Win，Linux）</code></p><p>JVM 结构：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-概述图.png" style="zoom: 80%;" /><p>JVM、JRE、JDK 对比：</p><ul><li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li><li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-JRE关系.png" style="zoom: 80%;" /><p>参考书籍：<a href="https://book.douban.com/subject/34907497/">https://book.douban.com/subject/34907497/</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1yE411Z7AP">https://www.bilibili.com/video/BV1yE411Z7AP</a></p><hr><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p><ul><li>基于栈式架构的特点：<ul><li>设计和实现简单，适用于资源受限的系统</li><li>使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现<ul><li>零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器</li><li>一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数</li></ul></li><li>不需要硬件的支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点：<ul><li>需要硬件的支持，可移植性差</li><li>性能更好，执行更高效，寄存器比内存快</li><li>以一地址指令、二地址指令、三地址指令为主</li></ul></li></ul><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡</p><ul><li><p><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</p></li><li><p><strong>运行</strong>：</p><ul><li><p>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</p></li><li><p>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，<strong>JVM 使用的是守护线程，main() 和其他线程使用的是用户线程</strong>，守护线程会随着用户线程的结束而结束</p></li><li><p>执行一个 Java 程序时，真真正正在执行的是一个 <strong>Java 虚拟机的进程</strong></p></li><li><p>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</p><p>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</p></li></ul></li><li><p><strong>死亡</strong>：</p><ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><hr><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h3><p>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</p><p>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行</p><ul><li><p>Java1.8 以前的内存结构图：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java7%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li><li><p>Java1.8 之后的内存结果图：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><p>线程运行诊断：</p><ul><li>定位：jps 定位进程 ID</li><li>jstack 进程 ID：用于打印出给定的 Java 进程 ID 或 core file 或远程调试服务的 Java 堆栈信息</li></ul><p>常见 OOM 错误：</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><h3 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><h5 id="Java-栈"><a href="#Java-栈" class="headerlink" title="Java 栈"></a>Java 栈</h5><p>Java 虚拟机栈：Java Virtual Machine Stacks，<strong>每个线程</strong>运行时所需要的内存</p><ul><li><p>每个方法被执行时，都会在虚拟机栈中创建一个栈帧 stack frame（<strong>一个方法一个栈帧</strong>）</p></li><li><p>Java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的</strong></p></li><li><p>虚拟机栈是<strong>每个线程私有的</strong>，每个线程只能有一个活动栈帧，对应方法调用到执行完成的整个过程</p></li><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，每个栈帧中存储着：</p><ul><li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的定义</li><li>操作数栈或表达式栈和其他一些附加信息</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚拟机栈.png" style="zoom:50%;" /></li></ul><p>设置栈内存大小：<code>-Xss size</code>   <code>-Xss 1024k</code></p><ul><li>在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</li></ul><p>虚拟机栈特点：</p><ul><li><p>栈内存<strong>不需要进行GC</strong>，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</p></li><li><p>栈内存分配越大越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）</p></li><li><p>方法内的局部变量是否<strong>线程安全</strong>：</p><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>异常：</p><ul><li>栈帧过多导致栈内存溢出 （超过了栈的容量），会抛出 OutOfMemoryError 异常</li><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常</li></ul><hr><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量表也被称之为局部变量数组或本地变量表，本质上定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p><ul><li>表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li><li>表的容量大小是在编译期确定的，保存在方法的 Code 属性的 maximum local variables 数据项中</li><li>表中的变量只在当前方法调用中有效，方法结束栈帧销毁，局部变量表也会随之销毁</li><li>表中的变量也是重要的垃圾回收根节点，只要被表中数据直接或间接引用的对象都不会被回收</li></ul><p>局部变量表最基本的存储单元是 <strong>slot（变量槽）</strong>：</p><ul><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束，JVM 为每一个 slot 都分配一个访问索引，通过索引即可访问到槽中的数据</li><li>存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress 类型的变量</li><li>32 位以内的类型只占一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占两个 slot</li><li>局部变量表中的槽位是可以<strong>重复利用</strong>的，如果一个局部变量过了其作用域，那么之后申明的新的局部变量就可能会复用过期局部变量的槽位，从而达到节省资源的目的</li></ul><hr><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>栈：可以使用数组或者链表来实现</p><p>操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</p><ul><li><p>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，是执行引擎的一个工作区</p></li><li><p>Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p></li><li><p>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈中</strong></p></li></ul><p>栈顶缓存技术 ToS（Top-of-Stack Cashing）：将栈顶元素全部缓存在 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行的效率</p><p>基于栈式架构的虚拟机使用的零地址指令更加紧凑，完成一项操作需要使用很多入栈和出栈指令，所以需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数，由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度，所以需要栈顶缓存技术</p><hr><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接是指向运行时常量池的方法引用，涉及到栈操作已经是类加载完成，这个阶段的解析是<strong>动态绑定</strong></p><ul><li><p>为了支持当前方法的代码能够实现动态链接，每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.png"></p></li><li><p>在 Java 源文件被编译成的字节码文件中，所有的变量和方法引用都作为符号引用保存在 class 的常量池中</p><p>常量池的作用：提供一些符号和常量，便于指令的识别</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png"></p></li></ul><hr><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><p>Return Address：存放调用该方法的 PC 寄存器的值</p><p>方法的结束有两种方式：正常执行完成、出现未处理的异常，在方法退出后都返回到该方法被调用的位置</p><ul><li>正常：调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的<strong>下一条指令的地址</strong></li><li>异常：返回地址是要通过异常表来确定</li></ul><p>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者</p><p>异常完成出口：方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，本方法的异常表中没有搜素到匹配的异常处理器，导致方法退出</p><p>两者区别：通过异常完成出口退出的不会给上层调用者产生任何的返回值</p><h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p><hr><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈是为虚拟机执行本地方法时提供服务的</p><p>JNI：Java Native Interface，通过使用 Java 本地接口书写程序，可以确保代码在不同的平台上方便移植</p><ul><li><p>不需要进行 GC，与虚拟机栈类似，也是线程私有的，有 StackOverFlowError 和 OutOfMemoryError 异常</p></li><li><p>虚拟机栈执行的是 Java 方法，在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li><li><p>本地方法一般是由其他语言编写，并且被编译为基于本机硬件和操作系统的程序</p></li><li><p>当某个线程调用一个本地方法时，就进入了不再受虚拟机限制的世界，和虚拟机拥有同样的权限</p><ul><li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong></li><li>直接从本地内存的堆中分配任意数量的内存</li><li>可以直接使用本地处理器中的寄存器</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-本地方法栈.png" style="zoom:67%;" /></li></ul><p>图片来源：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a></p><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Program Counter Register 程序计数器（寄存器）</p><p>作用：内部保存字节码的行号，用于记录正在执行的字节码指令地址（如果正在执行的是本地方法则为空）</p><p>原理：</p><ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul><p>特点：</p><ul><li>是线程私有的</li><li><strong>不会存在内存溢出</strong>，是 JVM 规范中唯一一个不出现 OOM 的区域，所以这个空间不会进行 GC</li></ul><p>Java 反编译指令：<code>javap -v Test.class</code></p><p>#20：代表去 Constant pool 查看该地址的指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out;</span></span><br><span class="line"><span class="number">3</span>: astore_1 <span class="comment">// --</span></span><br><span class="line"><span class="number">4</span>: aload_1 <span class="comment">// out.println(1);</span></span><br><span class="line"><span class="number">5</span>: iconst_1 <span class="comment">// --</span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">9</span>: aload_1 <span class="comment">// out.println(2);</span></span><br><span class="line"><span class="number">10</span>: iconst_2 <span class="comment">// --</span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br></pre></td></tr></table></figure><hr><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题</p><p>存放哪些资源：</p><ul><li>对象实例：类初始化生成的对象，<strong>基本数据类型的数组也是对象实例</strong>，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放于方法区，JDK7 开始放置于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li></ul><p>设置堆内存指令：<code>-Xmx Size</code></p><p>内存溢出：new 出对象，循环添加字符数据，当堆中没有内存空间可分配给实例，也无法再扩展时，就会抛出 OutOfMemoryError 异常</p><p>堆内存诊断工具：（控制台命令）</p><ol><li>jps：查看当前系统中有哪些 Java 进程</li><li>jmap：查看堆内存占用情况 <code>jhsdb jmap --heap --pid 进程id</code></li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测</li></ol><p>在 Java7 中堆内会存在<strong>年轻代、老年代和方法区（永久代）</strong>：</p><ul><li>Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区。Survivor 区某一时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。在 Eden 区变满的时候，GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间</li><li>Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区</li><li>Perm 代主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理</li></ul><p>分代原因：不同对象的生命周期不同，70%-99% 的对象都是临时对象，优化 GC 性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机使用的最大堆内存量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xms : 245M</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xmx : 3641M</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区：是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</p><p>方法区是一个 JVM 规范，<strong>永久代与元空间都是其一种实现方式</strong></p><p>方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)</p><p>方法区的 GC：针对常量池的回收及对类型的卸载，比较难实现</p><p>为了<strong>避免方法区出现 OOM</strong>，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，<strong>静态变量和字符串常量池等放入堆中</strong></p><p>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p><p>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了<strong>类在编译期间生成的字面量、符号引用</strong>，JVM 为每个已加载的类维护一个常量池</p><ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul><p>运行时常量池是方法区的一部分</p><ul><li>常量池（编译器生成的字面量和符号引用）中的数据会在类加载的加载阶段放入运行时常量池</li><li>类在解析阶段将这些符号引用替换成直接引用</li><li>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</li></ul><hr><h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>虚拟机内存：Java 虚拟机在执行的时候会把管理的内存分配成不同的区域，受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报 OOM</p><p>本地内存：又叫做<strong>堆外内存</strong>，线程共享的区域，本地内存这块区域是不会受到 JVM 的控制的，不会发生 GC；因此对于整个 Java 的执行效率是提升非常大，但是如果内存的占用超出物理内存的大小，同样也会报 OOM</p><p>本地内存概述图：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-内存图对比.png" style="zoom: 67%;" /><hr><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>PermGen 被元空间代替，永久代的<strong>类信息、方法、常量池</strong>等都移动到元空间区</p><p>元空间与永久代区别：元空间不在虚拟机中，使用的本地内存，默认情况下，元空间的大小仅受本地内存限制</p><p>方法区内存溢出：</p><ul><li><p>JDK1.8 以前会导致永久代内存溢出：java.lang.OutOfMemoryError: PerGen space</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 以后会导致元空间内存溢出：java.lang.OutOfMemoryError: Metaspace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li></ul><p>元空间内存溢出演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_8</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Demo1_8</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1_8</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域</p><p>直接内存详解参考：NET → NIO → 直接内存</p><hr><h3 id="变量位置"><a href="#变量位置" class="headerlink" title="变量位置"></a>变量位置</h3><p>变量的位置不取决于它是基本数据类型还是引用数据类型，取决于它的<strong>声明位置</strong></p><p>静态内部类和其他内部类：</p><ul><li><p><strong>一个 class 文件只能对应一个 public 类型的类</strong>，这个类可以有内部类，但不会生成新的 class 文件</p></li><li><p>静态内部类属于类本身，加载到方法区，其他内部类属于内部类的属性，加载到堆（待考证）</p></li></ul><p>类变量：</p><ul><li>类变量是用 static 修饰符修饰，定义在方法外的变量，随着 Java 进程产生和销毁</li><li>在 Java8 之前把静态变量存放于方法区，在 Java8 时存放在堆中的静态变量区</li></ul><p>实例变量：</p><ul><li>实例（成员）变量是定义在类中，没有 static 修饰的变量，随着类的实例产生和销毁，是类实例的一部分</li><li>在类初始化的时候，从运行时常量池取出直接引用或者值，<strong>与初始化的对象一起放入堆中</strong></li></ul><p>局部变量：</p><ul><li>局部变量是定义在类的方法中的变量</li><li>在所在方法被调用时<strong>放入虚拟机栈的栈帧</strong>中，方法执行结束后从虚拟机栈中弹出，</li></ul><p>类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？</p><ul><li>类常量池与运行时常量池都存储在方法区，而字符串常量池在 Jdk7 时就已经从方法区迁移到了 Java 堆中</li><li>在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符</li><li><strong>在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池</strong></li><li>对于文本字符，会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池</li></ul><p>什么是字面量？什么是符号引用？</p><ul><li><p>字面量：java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这个1便是字面量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;iloveu&quot;</span>;<span class="comment">//iloveu便是字面量</span></span><br></pre></td></tr></table></figure></li><li><p>符号引用：在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址</p></li></ul><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h4><p>不分配内存的对象无法进行其他操作，JVM 为对象分配内存的过程：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象</p><ul><li>如果内存规整，使用指针碰撞（Bump The Pointer）。所有用过的内存在一边，空闲的内存在另外一边，中间有一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离</li><li>如果内存不规整，虚拟机需要维护一个空闲列表（Free List）分配。已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li></ul><hr><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做<strong>快速分配策略</strong></p><ul><li>栈上分配使用的是栈来进行对象内存的分配</li><li>TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存</li></ul><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p><p>问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpg"></p><p>JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在堆中分配内存</p><p>栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存</p><p>参数设置：</p><ul><li><p><code>-XX:UseTLAB</code>：设置是否开启 TLAB 空间</p></li><li><p><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%</p></li><li><p><code>-XX:TLABRefillWasteFraction</code>：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg"></p><hr><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>即时编译（Just-in-time Compilation，JIT）是一种通过在运行时将字节码翻译为机器码，从而改善性能的技术，在 HotSpot 实现中有多种选择：C1、C2 和 C1+C2，分别对应 Client、Server 和分层编译</p><ul><li>C1 编译速度快，优化方式比较保守；C2 编译速度慢，优化方式比较激进</li><li>C1+C2 在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译</li></ul><p>逃逸分析并不是直接的优化手段，而是一个代码分析方式，通过动态分析对象的作用域，为优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸</p><ul><li>方法逃逸：当一个对象在方法中定义之后，被外部方法引用<ul><li>全局逃逸：一个对象的作用范围逃出了当前方法或者当前线程，比如对象是一个静态变量、全局变量赋值、已经发生逃逸的对象、作为当前方法的返回值</li><li>参数逃逸：一个对象被作为方法参数传递或者被参数引用</li></ul></li><li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li></ul><p>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配</p><ul><li><p>同步消除</p><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的<strong>同步锁</strong>，通过 <code>-XX:+EliminateLocks</code> 可以开启同步消除 ( - 号关闭)</p></li><li><p>标量替换</p><ul><li><p>标量替换：如果把一个对象拆散，将其成员变量恢复到基本类型来访问</p></li><li><p>标量 (scalar) ：不可分割的量，如基本数据类型和 reference 类型</p><p>聚合量 (Aggregate)：一个数据可以继续分解，对象一般是聚合量</p></li><li><p>如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替</p></li><li><p>参数设置：</p><ul><li><code>-XX:+EliminateAllocations</code>：开启标量替换</li><li><code>-XX:+PrintEliminateAllocations</code>：查看标量替换情况</li></ul></li></ul></li><li><p>栈上分配</p><p>JIT 编译器在编译期间根据逃逸分析的结果，如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需 GC</p><p>User 对象的作用域局限在方法 fn 中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会生成 User 对象，大大减轻 GC 的压力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">//warm up</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count ; i++) &#123;</span><br><span class="line">            sum += fn(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(age);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> user.getAge();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><h5 id="分代介绍"><a href="#分代介绍" class="headerlink" title="分代介绍"></a>分代介绍</h5><p>Java8 时，堆被分为了两份：新生代和老年代（1:2），在 Java7 时，还存在一个永久代</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><p><strong>Minor GC 和 Full GC</strong>：</p><ul><li>Minor GC：回收新生代，新生代对象存活时间很短，所以 Minor GC 会频繁执行，执行的速度比较快</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，所以 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li></ul><p> Eden 和 Survivor 大小比例默认为 8:1:1</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-分代收集算法.png" style="zoom: 67%;" /><hr><h5 id="分代分配"><a href="#分代分配" class="headerlink" title="分代分配"></a>分代分配</h5><p>工作机制：</p><ul><li><strong>对象优先在 Eden 分配</strong>：当创建一个对象的时候，对象会被分配在新生代的 Eden 区，当 Eden 区要满了时候，触发 YoungGC</li><li>当进行 YoungGC 后，此时在 Eden 区存活的对象被移动到 to 区，并且当前对象的年龄会加 1，清空 Eden 区</li><li>当再一次触发 YoungGC 的时候，会把 Eden 区中存活下来的对象和 to 中的对象，移动到 from 区中，这些对象的年龄会加 1，清空 Eden 区和 to 区</li><li>To 区永远是空 Survivor 区，From 区是有数据的，每次 MinorGC 后两个区域互换</li><li>From 区和 To 区 也可以叫做 S0 区和 S1 区</li></ul><p>晋升到老年代：</p><ul><li><p><strong>长期存活的对象进入老年代</strong>：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p><p><code>-XX:MaxTenuringThreshold</code>：定义年龄的阈值，对象头中用 4 个 bit 存储，所以最大值是 15，默认也是 15</p></li><li><p><strong>大对象直接进入老年代</strong>：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象</p><p><code>-XX:PretenureSizeThreshold</code>：大于此值的对象直接在老年代分配</p></li><li><p><strong>动态对象年龄判定</strong>：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p></li></ul><p>空间分配担保：</p><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</li><li>如果不成立，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC；如果小于或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC</li></ul><hr><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>内存垃圾回收机制主要集中的区域就是线程共享区域：<strong>堆和方法区</strong></p><p>Minor GC 触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</p><p>FullGC 同时回收新生代、老年代和方法区，只会存在一个 FullGC 的线程进行执行，其他的线程全部会被<strong>挂起</strong>，有以下触发条件：</p><ul><li><p>调用 System.gc()：</p><ul><li>在默认情况下，通过 System.gc() 或 Runtime.getRuntime().gc() 的调用，会显式触发 FullGC，同时对老年代和新生代进行回收，但是虚拟机不一定真正去执行，无法保证对垃圾收集器的调用</li><li>不建议使用这种方式，应该让虚拟机管理内存。一般情况下，垃圾回收应该是自动进行的，无须手动触发；在一些特殊情况下，如正在编写一个性能基准，可以在运行之间调用 System.gc()</li></ul></li><li><p>老年代空间不足：</p><ul><li>为了避免引起的 Full GC，应当尽量不要创建过大的对象以及数组</li><li>通过 -Xmn 参数调整新生代的大小，让对象尽量在新生代被回收掉不进入老年代，可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</li></ul></li><li><p>空间分配担保失败</p></li><li><p>JDK 1.7 及以前的永久代（方法区）空间不足</p></li><li><p>Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p></li></ul><p>手动 GC 测试，VM参数：<code>-XX:+PrintGcDetails</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">    System.gc();<span class="comment">//输出: 不会被回收, FullGC时被放入老年代</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    buffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc();<span class="comment">//输出: 正常被回收</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     System.gc();<span class="comment">//输出: 不会被回收, FullGC时被放入老年代</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.gc();<span class="comment">//输出: 正常被回收，slot复用，局部变量过了其作用域 buffer置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点 (Safepoint)：程序执行时并非在所有地方都能停顿下来开始 GC，只有在安全点才能停下</p><ul><li>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题</li><li>大部分指令的执行时间都非常短，通常会根据是否具有让程序长时间执行的特征为标准，选择些执行时间较长的指令作为 Safe Point， 如方法调用、循环跳转和异常跳转等</li></ul><p>在 GC 发生时，让所有线程都在最近的安全点停顿下来的方法：</p><ul><li>抢先式中断：没有虚拟机采用，首先中断所有线程，如果有线程不在安全点，就恢复线程让线程运行到安全点</li><li>主动式中断：设置一个中断标志，各个线程运行到各个 Safe Point 时就轮询这个标志，如果中断标志为真，则将自己进行中断挂起</li></ul><p>问题：Safepoint 保证程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但是当线程处于 Waiting 状态或 Blocked 状态，线程无法响应 JVM 的中断请求，运行到安全点去中断挂起，JVM 也不可能等待线程被唤醒，对于这种情况，需要安全区域来解决</p><p>安全区域 (Safe Region)：指在一段代码片段中，<strong>对象的引用关系不会发生变化</strong>，在这个区域中的任何位置开始 GC 都是安全的</p><p>运行流程：</p><ul><li><p>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</p></li><li><p>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了则继续运行，否则线程必须等待 GC 完成，收到可以安全离开 SafeRegion 的信号</p></li></ul><hr><h3 id="垃圾判断"><a href="#垃圾判断" class="headerlink" title="垃圾判断"></a>垃圾判断</h3><h4 id="垃圾介绍"><a href="#垃圾介绍" class="headerlink" title="垃圾介绍"></a>垃圾介绍</h4><p>垃圾：<strong>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</strong></p><p>作用：释放没用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象</p><p>垃圾收集主要是针对堆和方法区进行，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段，判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></p><hr><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</p><p>优点：</p><ul><li>回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收</li><li>在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象</li></ul><p>缺点：</p><ul><li><p>每次对象被引用时，都需要去更新计数器，有一点时间开销</p></li><li><p>浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。</p></li><li><p><strong>无法解决循环引用问题，会引发内存泄露</strong>（最大的缺点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">// a = 1</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">// b = 1</span></span><br><span class="line">        a.instance = b;<span class="comment">// b = 2</span></span><br><span class="line">        b.instance = a;<span class="comment">// a = 2</span></span><br><span class="line">        a = <span class="literal">null</span>;<span class="comment">// a = 1</span></span><br><span class="line">        b = <span class="literal">null</span>;<span class="comment">// b = 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"></p><hr><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p><p>GC Roots 对象：</p><ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li></ul><p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</p><hr><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象</p><p>分析工作必须在一个保障<strong>一致性的快照</strong>中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因</p><p>基本原理：</p><ul><li><p>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p></li><li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p></li><li><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-可达性分析算法.png" style="zoom: 50%;" /></li></ul><hr><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><h6 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h6><p>三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：</p><ul><li>白色：尚未访问过</li><li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li><li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li></ul><p>当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：</p><ol><li>初始时，所有对象都在白色集合</li><li>将 GC Roots 直接引用到的对象挪到灰色集合</li><li>从灰色集合中获取对象：<ul><li>将本对象引用到的其他对象全部挪到灰色集合中</li><li>将本对象挪到黑色集合里面</li></ul></li><li>重复步骤 3，直至灰色集合为空时结束</li><li>结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收</li></ol><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法过程.gif" style="zoom: 67%;" /><p>参考文章：<a href="https://www.jianshu.com/p/12544c0ad5c1">https://www.jianshu.com/p/12544c0ad5c1</a></p><hr><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生</p><p><strong>多标情况：</strong>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为<strong>浮动垃圾</strong></p><ul><li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li><li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法多标情况.png" style="zoom: 50%;" /><p><strong>漏标情况：</strong></p><ul><li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li><li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li><li>结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法漏标情况.png" style="zoom:50%;" /><p>代码角度解释漏标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">G</span> <span class="operator">=</span> objE.fieldG; <span class="comment">// 读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 写</span></span><br></pre></td></tr></table></figure><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p><blockquote><p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p></blockquote><p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p><ul><li><p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描</p><p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p><p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p></li><li><p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p><p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了，并且原始快照中本来就应该是灰色对象），最后重新扫描该对象的引用关系</p><p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p></li><li><p>**读屏障 (Load Barrier)**：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p></li></ul><p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p><ul><li>CMS：写屏障 + 增量更新</li><li>G1：写屏障 + SATB</li><li>ZGC：读屏障</li></ul><hr><h4 id="finalization"><a href="#finalization" class="headerlink" title="finalization"></a>finalization</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p><p>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</p><p>生存 OR 死亡：如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用，此对象需要被回收。但事实上这时候它们暂时处于缓刑阶段。<strong>一个无法触及的对象有可能在某个条件下复活自己</strong>，所以虚拟机中的对象可能的三种状态：</p><ul><li>可触及的：从根节点开始，可以到达这个对象</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活</li><li>不可触及的：对象的 finalize() 被调用并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 <strong>finalize() 只会被调用一次</strong>，等到这个对象再被标记为可回收时就必须回收</li></ul><p>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用，原因：</p><ul><li>finalize() 时可能会导致对象复活</li><li>finalize() 方法的执行时间是没有保障的，完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li><li>一个糟糕的 finalize() 会严重影响 GC 的性能</li></ul><hr><h4 id="引用分析"><a href="#引用分析" class="headerlink" title="引用分析"></a>引用分析</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关，Java 提供了四种强度不同的引用类型</p><ol><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致<strong>内存泄漏</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//使用 new 一个新对象的方式来创建强引用</span></span><br></pre></td></tr></table></figure></li><li><p>软引用（SoftReference）：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>仅（可能有强引用，一个对象可以被多个引用）</strong>有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>配合<strong>引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li><li>软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure></li><li><p>弱引用（WeakReference）：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li><li>WeakHashMap 用来存储图片信息，可以在内存不足的时候及时回收，避免了 OOM</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用（PhantomReference）：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，能在这个对象被回收时收到一个系统通知</li><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>终结器引用（finalization）</p></li></ol><hr><h4 id="无用属性"><a href="#无用属性" class="headerlink" title="无用属性"></a>无用属性</h4><h5 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h5><p>方法区主要回收的是无用的类</p><p>判定一个类是否是无用的类，需要同时满足下面 3 个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 <code>ClassLoader</code> 已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是可以</strong>，而并不是和对象一样不使用了就会必然被回收</p><hr><h5 id="废弃常量"><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h5><p>在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该常量，说明常量 “abc” 是废弃常量，如果这时发生内存回收的话<strong>而且有必要的话</strong>（内存不够用），”abc” 就会被系统清理出常量池</p><hr><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>类加载时（第一次访问），这个类中所有静态成员就会被加载到静态变量区，该区域的成员一旦创建，直到程序退出才会被回收</p><p>如果是静态引用类型的变量，静态变量区只存储一份对象的引用地址，真正的对象在堆内，如果要回收该对象可以设置引用为 null</p><p>参考文章：<a href="https://blog.csdn.net/zhengzhb/article/details/7331354">https://blog.csdn.net/zhengzhb/article/details/7331354</a></p><hr><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清理，交换两个内存的角色，完成垃圾的回收</p><p>应用场景：如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之则不适合</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p><p>算法优点：</p><ul><li>没有标记和清除过程，实现简单，运行速度快</li><li>复制过去以后保证空间的连续性，不会出现碎片问题</li></ul><p>算法缺点：</p><ul><li>主要不足是<strong>只使用了内存的一半</strong></li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小</li></ul><p>现在的商业虚拟机都采用这种收集算法<strong>回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间</p><hr><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除算法，是将垃圾回收分为两个阶段，分别是<strong>标记和清除</strong></p><ul><li><p><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></p></li><li><p><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到<strong>空闲列表</strong>的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块</p></li><li><p><strong>分配阶段</strong>：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，如果找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表</p></li></ul><p>算法缺点：</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存，需要维护一个空闲链表</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记清除算法.png" style="zoom: 67%;" /><hr><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>标记整理（压缩）算法是在标记清除算法的基础之上，做了优化改进的算法</p><p>标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是<strong>将存活对象都向内存另一端移动</strong>，然后清理边界以外的垃圾，从而<strong>解决了碎片化</strong>的问题</p><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理效率比较低</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记整理算法.png" style="zoom:67%;" /><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的 2 倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><hr><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>垃圾收集器分类：</p><ul><li>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器<ul><li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</li></ul></li><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器<ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul></li><li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器<ul><li>压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表</li></ul></li><li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器</li></ul><p>GC 性能指标：</p><ul><li><strong>吞吐量</strong>：程序的运行时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率</li><li>内存占用：Java 堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><p><strong>垃圾收集器的组合关系</strong>：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>新生代收集器：Serial、ParNew、Parallel Scavenge</p><p>老年代收集器：Serial old、Parallel old、CMS</p><p>整堆收集器：G1</p><ul><li>红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器</li></ul><p>查看默认的垃圾收回收器：</p><ul><li><p><code>-XX:+PrintcommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数  进程 ID</p></li></ul><hr><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用<strong>复制算法</strong>，新生代基本都是复制算法</p><p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成</p><p><strong>Serial old</strong>：执行老年代垃圾回收的串行收集器，内存回收算法使用的是<strong>标记-整理算法</strong>，同样也采用了串行回收和 STW 机制</p><ul><li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li><li>Serial old 在 Server 模式下主要有两个用途：<ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li></ul></li></ul><p>开启参数：<code>-XX:+UseSerialGC</code> 等价于新生代用 Serial GC 且老年代用 Serial old GC</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Serial%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</p><p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p><hr><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Par 是 Parallel 并行的缩写，New 是只能处理的是新生代</p><p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间</p><p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong>ParNew GC 能与 CMS 收集器配合工作</strong></p><p>相关参数：</p><ul><li><p><code>-XX：+UseParNewGC</code>：表示年轻代使用并行收集器，不影响老年代</p></li><li><p><code>-XX:ParallelGCThreads</code>：默认开启和 CPU 数量相同的线程数</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p><ul><li>对于新生代，回收次数频繁，使用并行方式高效</li><li>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><hr><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>Parallel Scavenge 收集器是应用于新生代的并行垃圾回收器，<strong>采用复制算法</strong>、并行回收和 Stop the World 机制</p><p>Parallel Old 收集器：是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong></p><p>对比其他回收器：</p><ul><li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间</li><li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li><li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong>，可以通过一个开关参数打开 GC Ergonomics</li></ul><p>应用场景：</p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li></ul><p>停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p><p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParallelScavenge%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>参数配置：</p><ul><li><code>-XX：+UseParallelGC</code>：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务</li><li><code>-XX：+UseParalleloldcc</code>：手动指定老年代使用并行回收收集器执行内存回收任务<ul><li>上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的</li></ul></li><li><code>-XX:+UseAdaptivesizepplicy</code>：设置 Parallel Scavenge 收集器具有<strong>自适应调节策略</strong>，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li><li><code>-XX:ParallelGcrhreads</code>：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]&#x2F;8]</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒<ul><li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li><li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数</li></ul></li><li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 &#x3D;1&#x2F;(N+1)，用于衡量吞吐量的大小<ul><li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1</li><li>与 <code>-xx:MaxGCPauseMillis</code> 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例</li></ul></li></ul><hr><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS 全称 Concurrent Mark Sweep，是一款<strong>并发的、使用标记-清除</strong>算法、针对老年代的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong></p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验</p><p>分为以下四个流程：</p><ul><li>初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）</li><li>并发清除：清除标记为可以回收对象，<strong>不需要移动存活对象</strong>，所以这个阶段可以与用户线程同时并发的</li></ul><p>Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的<strong>对象的地址改变</strong>，影响用户线程继续执行</p><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：并发收集、低延迟</p><p>缺点：</p><ul><li><p>吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p></li><li><p>CMS 收集器<strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p><p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间</p></li><li><p>标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</p></li></ul><p>参数设置：</p><ul><li><p><code>-XX：+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务</p><p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即：ParNew + CMS + Serial old的组合</p></li><li><p><code>-XX:CMSInitiatingoccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收</li><li>JDK6 及以上版本默认值为 92%</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长</p></li><li><p><code>-XX:CMSFullGCsBeforecompaction</code>：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p></li><li><p><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量</p><ul><li>CMS 默认启动的线程数是 (ParallelGCThreads+3)&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数</li><li>收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li></ul></li></ul><hr><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="G1-特点"><a href="#G1-特点" class="headerlink" title="G1 特点"></a>G1 特点</h5><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>应用于新生代和老年代</strong>、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&gt;4 ~ 6G），在 JDK9 之后默认使用 G1</p><p>G1 对比其他处理器的优点：</p><ul><li><p>并发与并行：</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li><li>其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会<strong>调用应用程序线程加速垃圾回收</strong>过程</li></ul></li><li><p><strong>分区算法</strong>：</p><ul><li><p>从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</p></li><li><p>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收</p></li><li><p><strong>新的区域 Humongous</strong>：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC</p></li><li><p>G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p></li><li><p>Region 结构图：</p></li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1-Region%E5%8C%BA%E5%9F%9F.png"></p><ul><li><p>空间整合：</p><ul><li>CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片</li></ul></li><li><p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p><ul><li>由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</li></ul><ul><li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</li></ul></li></ul><p>G1 垃圾收集器的缺点：</p><ul><li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高</li><li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间</li></ul><p>应用场景：</p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li><li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li></ul><hr><h5 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h5><p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-G1记忆集.png" style="zoom:67%;" /><ul><li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li><li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li></ul><p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p><ul><li>字长精度</li><li>对象精度</li><li>卡精度(卡表)</li></ul><p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p><p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p><ul><li>CSet of Young Collection</li><li>CSet of Mix Collection</li></ul><hr><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发</p><ul><li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程</li><li>标记完成马上开始混合回收过程</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1回收过程.png" style="zoom: 50%;" /><p>顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收</p><ul><li><p><strong>Young GC</strong>：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收</p><p><strong>回收过程</strong>：</p><ol><li>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</li><li>更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系<ul><li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li><li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li></ul></li><li>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</li><li>复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li><li>处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作</li></ol></li><li><p>**Concurrent Mark **：</p><ul><li>初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC</li><li>并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（<strong>实时回收</strong>），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（<strong>防止漏标</strong>）</li><li>筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p></li><li><p><strong>Mixed GC</strong>：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC</p><p>注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制</p><p>在 G1 中，Mixed GC 可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</p></li><li><p><strong>Full GC</strong>：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC</p><p>产生 Full GC 的原因：</p><ul><li>晋升时没有足够的空间存放晋升的对象</li><li>并发处理过程完成之前空间耗尽，浮动垃圾</li></ul></li></ul><hr><h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1&#x2F;2000</li><li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms</li><li><code>-XX:+ParallelGcThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8</li><li><code>-XX:ConcGCThreads</code>：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1&#x2F;4左右</li><li><code>-XX:InitiatingHeapoccupancyPercent</code>：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li><li><code>-XX:+ClassUnloadingWithConcurrentMark</code>：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li><li><code>-XX:G1NewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5％） </li><li><code>-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最大百分比（默认60％） </li><li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 to space（Survivor中的 to 区）溢出</li></ul><hr><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：</p><ol><li>开启 G1 垃圾收集器</li><li>设置堆的最大内存</li><li>设置最大的停顿时间（STW）</li></ol><p>不断调优暂停时间指标：</p><ul><li><code>XX:MaxGCPauseMillis=x</code> 可以设置启动应用程序暂停的时间，G1会根据这个参数选择 CSet 来满足响应时间的设置</li><li>设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成50ms就不太合理</li><li>暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC</li><li>对这个参数的调优是一个持续的过程，逐步调整到最佳状态</li></ul><p>不要设置新生代和老年代的大小：</p><ul><li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标</li><li>设置了新生代大小相当于放弃了 G1 的自动调优，我们只需要设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小</li></ul><hr><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>ZGC 收集器是一个可伸缩的、低延迟的垃圾收集器，基于 Region 内存布局的，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记压缩算法</strong></p><ul><li>在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了读屏障</li><li>染色指针：直接<strong>将少量额外的信息存储在指针上的技术</strong>，从 64 位的指针中拿高 4 位来标识对象此时的状态<ul><li>染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li><li>可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize() 方法才能被访问到（Finalizable）</li><li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作</li><li>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</li></ul></li><li>内存多重映射：多个虚拟地址指向同一个物理地址</li></ul><p>可并发的标记压缩算法：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，<strong>并更新引用</strong>，不会像 G1 一样必须等待垃圾回收完成才能访问</p><p>ZGC 目标：</p><ul><li>停顿时间不会超过 10ms</li><li>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）</li><li>可支持几百 M，甚至几 T 的堆大小（最大支持4T）</li></ul><p>ZGC 的工作过程可以分为 4 个阶段：</p><ul><li>并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿</li><li>并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）</li><li>并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的<strong>每个 Region 维护一个转发表</strong>（Forward Table），记录从旧地址到新地址的转向关系</li><li>并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销</li></ul><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><p>优点：高吞吐量、低延迟</p><p>缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾</p><p>参考文章：<a href="https://www.cnblogs.com/jimoer/p/13170249.html">https://www.cnblogs.com/jimoer/p/13170249.html</a></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC  不同：</p><ul><li>最小化地使用内存和并行开销，选 Serial GC</li><li>最大化应用程序的吞吐量，选 Parallel GC</li><li>最小化 GC 的中断或停顿时间，选 CMS GC</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png"></p><hr><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="泄露溢出"><a href="#泄露溢出" class="headerlink" title="泄露溢出"></a>泄露溢出</h4><p>内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。由于代码的实现不同就会出现很多种内存泄漏问题，让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏</p><p>内存溢出（out of memory）指的是申请内存时，没有足够的内存可以使用</p><p>内存泄漏和内存溢出的关系：内存泄漏的越来越多，最终会导致内存溢出</p><hr><h4 id="几种情况"><a href="#几种情况" class="headerlink" title="几种情况"></a>几种情况</h4><h5 id="静态集合"><a href="#静态集合" class="headerlink" title="静态集合"></a>静态集合</h5><p>静态集合类的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。原因是<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏</p><hr><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类持有外部类的情况，如果一个外部类的实例对象调用方法返回了一个内部类的实例对象，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象也不会被回收，造成内存泄漏</p><hr><h5 id="连接相关"><a href="#连接相关" class="headerlink" title="连接相关"></a>连接相关</h5><p>数据库连接、网络连接和 IO 连接等，当不再使用时，需要显式调用 close 方法来释放与连接，垃圾回收器才会回收对应的对象，否则将会造成大量的对象无法被回收，从而引起内存泄漏</p><hr><h5 id="不合理域"><a href="#不合理域" class="headerlink" title="不合理域"></a>不合理域</h5><p>变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏；如果没有及时地把对象设置为 null，也有可能导致内存泄漏的发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = readFromNet();<span class="comment">// 从网络中接受数据保存到 msg 中</span></span><br><span class="line">        saveDB(msg);<span class="comment">// 把 msg 保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 readFromNet 方法把接收消息保存在 msg 中，然后调用 saveDB 方法把内容保存到数据库中，此时 msg 已经可以被回收，但是 msg 的生命周期与对象的生命周期相同，造成 msg 不能回收，产生内存泄漏</p><p>解决：</p><ul><li>msg 变量可以放在 receiveMsg 方法内部，当方法使用完，msg 的生命周期也就结束，就可以被回收了</li><li>在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</li></ul><hr><h5 id="改变哈希"><a href="#改变哈希" class="headerlink" title="改变哈希"></a>改变哈希</h5><p>当一个对象被存储进 HashSet 集合中以后，就<strong>不能修改这个对象中的那些参与计算哈希值的字段</strong>，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值不同，这种情况下使用该对象的当前引用作为的参数去 HashSet 集合中检索对象返回 false，导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏</p><hr><h5 id="缓存泄露"><a href="#缓存泄露" class="headerlink" title="缓存泄露"></a>缓存泄露</h5><p>内存泄漏的一个常见来源是缓存，一旦把对象引用放入到缓存中，就会很容易被遗忘</p><p>使用 WeakHashMap 代表缓存，当除了自身有对 key 的引用外没有其他引用，map 会自动丢弃此值</p><hr><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序并没有明显错误，但 pop 函数存在内存泄漏问题，因为 pop 函数只是把栈顶索引下移一位，并没有把上一个出栈索引处的引用置空，导致<strong>栈数组一直强引用着已经出栈的对象</strong></p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="对象访存"><a href="#对象访存" class="headerlink" title="对象访存"></a>对象访存</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>一个 Java 对象内存中存储为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充 （Padding）</p><p>对象头：</p><ul><li><p>普通对象：分为两部分</p><ul><li><p><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">25</span>) + age(<span class="number">4</span>) + lock(<span class="number">3</span>) = 32bit<span class="comment">#32位系统</span></span><br><span class="line">unused(<span class="number">25</span>+<span class="number">1</span>) + hash(<span class="number">31</span>) + age(<span class="number">4</span>) + lock(<span class="number">3</span>) = 64bit<span class="comment">#64位系统</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Klass Word</strong>：类型指针，<strong>指向该对象的 Class 类对象的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 <strong>Java 中的一个引用的大小</strong>）</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-----------------------------------------------------</span>|</span><br><span class="line">|<span class="params">   Object Header (64 bits)   </span>|</span><br><span class="line">|<span class="params">---------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|  Mark Word (<span class="number">32</span> bits)|<span class="params">  Klass Word (32 bits)   </span>|</span><br><span class="line">|<span class="params">---------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure></li><li><p>数组对象：如果对象是一个数组，那在对象头中还有一块数据用于记录数组长度（12 字节）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">   Object Header (96 bits)     </span>|</span><br><span class="line">|<span class="params">-----------------------</span>|-----------------------------|<span class="params">-------------------------</span>|</span><br><span class="line">|<span class="params">  Mark Word(32bits)    </span>|   Klass Word(32bits)   |<span class="params">   array length(32bits)  </span>|</span><br><span class="line">|<span class="params">-----------------------</span>|-----------------------------|<span class="params">-------------------------</span>|</span><br></pre></td></tr></table></figure></li></ul><p>实例数据：实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来</p><p>对齐填充：Padding 起占位符的作用。64 位系统，由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p><p>32 位系统：</p><ul><li><p>一个 int 在 java 中占据 4byte，所以 Integer 的大小为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要补位4byte</span></span><br><span class="line"><span class="number">4</span>(Mark Word) + <span class="number">4</span>(Klass Word) + <span class="number">4</span>(data) + <span class="number">4</span>(Padding) = 16byte</span><br></pre></td></tr></table></figure></li><li><p><code>int[] arr = new int[10]</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于需要8位对齐，所以最终大小为56byte</span></span><br><span class="line"><span class="number">4</span>(Mark Word) + <span class="number">4</span>(Klass Word) + <span class="number">4</span>(length) + <span class="number">4</span>*<span class="number">10</span>(<span class="number">10</span>个int大小) + <span class="number">4</span>(Padding) = 56sbyte</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实际大小"><a href="#实际大小" class="headerlink" title="实际大小"></a>实际大小</h4><p>浅堆（Shallow Heap）：<strong>对象本身占用的内存，不包括内部引用对象的大小</strong>，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐</p><p>JDK7 中的 String：2个 int 值共占 8 字节，value 对象引用占用 4 字节，对象头 8 字节，对齐后占 24 字节，为 String 对象的浅堆大小，与 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash32;</span><br></pre></td></tr></table></figure><p>保留集（Retained Set）：对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括 A 本身），所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合</p><p>深堆（Retained Heap）：指对象的保留集中所有的对象的浅堆大小之和，一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</p><p>对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小</p><p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，<strong>A 的实际大小为 A、C、D 三者之和</strong>，A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-对象的实际大小.png" style="zoom: 67%;" /><p>内存分析工具 MAT 提供了一种叫支配树的对象图，体现了对象实例间的支配关系</p><p>基本性质：</p><ul><li><p>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆</p></li><li><p>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B</p></li><li><p>支配树的边与对象引用图的边不直接对应</p></li></ul><p>左图表示对象引用图，右图表示左图所对应的支配树：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E6%94%AF%E9%85%8D%E6%A0%91.png"></p><p>比如：对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此对象 D 是对象 F 的直接支配者</p><p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/nkq31c">https://www.yuque.com/u21195183/jvm/nkq31c</a></p><hr><h4 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h4><ul><li><p>尽量使用基本数据类型</p></li><li><p>满足容量前提下，尽量用小字段</p></li><li><p>尽量用数组，少用集合，数组中是可以使用基本类型的，但是集合中只能放包装类型，如果需要使用集合，推荐比较节约内存的集合工具：fastutil</p><p>一个 ArrayList 集合，如果里面放了 10 个数字，占用多少内存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><p>Mark Word 占 4byte，Klass Word 占 4byte，一个 int 字段占 4byte，elementData 数组占 12byte，数组中 10 个 Integer 对象占 10×16，所以整个集合空间大小为 184byte（深堆）</p></li><li><p>时间用 long&#x2F;int 表示，不用 Date 或者 String</p></li></ul><hr><h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><p>JVM 是通过<strong>栈帧中的对象引用</strong>访问到其内部的对象实例：</p><ul><li><p>句柄访问：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</p><p>优点：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p></li><li><p>直接指针（HotSpot 采用）：Java 堆对象的布局必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的对象地址</p><p>优点：速度更快，<strong>节省了一次指针定位的时间开销</strong></p><p>缺点：对象被移动时（如进行 GC 后的内存重新排列），对象的 reference 也需要同步更新</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"></p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/afraidToForget/p/12584866.html">https://www.cnblogs.com/afraidToForget/p/12584866.html</a></p><hr><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Java 中，对象的生命周期包括以下几个阶段：</p><ol><li><pre><code> 创建阶段 (Created)：</code></pre></li><li><pre><code> 应用阶段 (In Use)：对象至少被一个强引用持有着</code></pre></li><li><pre><code> 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用</code></pre></li><li><pre><code> 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用</code></pre></li><li><pre><code> 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法</code></pre></li><li><pre><code> 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完 finalize() 方法后仍然处于不可达状态时进入该阶段</code></pre></li><li><pre><code> 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配</code></pre></li></ol><p>参考文章：<a href="https://blog.csdn.net/sodino/article/details/38387049">https://blog.csdn.net/sodino/article/details/38387049</a></p><hr><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类</p><p>Java 对象创建时机：</p><ol><li><p>使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建</p></li><li><p>使用 Class 类的 newInstance 方法（反射机制）</p></li><li><p>使用 Constructor 类的 newInstance 方法（反射机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Constructor&lt;Student&gt; c = Student.class.getConstructor(Integer.class);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> c.newInstance(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p></li><li><p>使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法</p></li><li><p>使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个<strong>单独的对象</strong>，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口</p></li></ol><p>从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的</p><hr><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>创建对象的过程：</p><ol><li><p>判断对象对应的类是否加载、链接、初始化</p></li><li><p>为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从<strong>隐藏变量</strong>也会被分配空间（继承部分解释了为什么会隐藏）</p></li><li><p>处理并发安全问题：</p><ul><li>采用 CAS 配上自旋保证更新的原子性</li><li>每个线程预先分配一块 TLAB</li></ul></li><li><p>初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中</p></li><li><p>执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化</p><ul><li><p>实例变量初始化与实例代码块初始化：</p><p>对实例变量直接赋值或者使用实例代码块赋值，<strong>编译器会将其中的代码放到类的构造函数中去</strong>，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前</p></li><li><p>构造函数初始化：</p><p><strong>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性</strong>，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数</p></li></ul></li></ol><hr><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><ol><li><p>一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次</p><p>JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值</p></li><li><p>类的初始化过程与类的实例化过程的异同？</p><p>类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）</p></li><li><p>假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（<strong>经典案例</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        staticFunction();<span class="comment">//调用静态方法，触发初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;       <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;    <span class="comment">// 实例构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction</span><span class="params">()</span> &#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">112</span>;     <span class="comment">// 静态变量</span></span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p><code>static StaticTest st = new StaticTest();</code>：</p><ul><li><p>实例实例化不一定要在类初始化结束之后才开始</p></li><li><p>在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，<strong>实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置</strong>，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因</p></li></ul><p>代码等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    &lt;clinit&gt;()&#123;</span><br><span class="line">        a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);<span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);  <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        类变量st被初始化</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">        类变量b被初始化为<span class="number">112</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>包括 7 个阶段：</p><ul><li>加载（Loading）</li><li>链接：验证（Verification）、准备（Preparation）、解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><hr><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>加载是类加载的其中一个阶段，注意不要混淆</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构（Java 类模型）</li><li><strong>在内存中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口</strong></li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li><li>从网络中获取，最典型的应用是 Applet</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码</li></ul><p>将字节码文件加载至方法区后，会<strong>在堆中</strong>创建一个 java.lang.Class 对象，用来引用位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象</p><p>方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：</p><ul><li><code>_java_mirror</code> 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用</li><li><code>_super</code> 即父类、<code>_fields</code> 即成员变量、<code>_methods</code> 即方法、<code>_constants</code> 即常量池、<code>_class_loader</code> 即类加载器、<code>_vtable</code> <strong>虚方法表</strong>、<code>_itable</code> 接口方法表</li></ul><p>加载过程：</p><ul><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li><li>Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类的生命周期-加载.png" style="zoom:80%;" /><p>创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：</p><ul><li>如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类</li><li><strong>基本数据类型由启动类加载器加载</strong></li></ul><hr><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全</p><p>主要包括<strong>四种验证</strong>：</p><ul><li><p>文件格式验证</p></li><li><p>语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过</p><ul><li><p>是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法</p></li></ul></li><li><p>字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型</li><li>栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</li></ul></li><li><p>符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法</p></li></ul><hr><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段为<strong>静态变量（类变量）分配内存并设置初始值</strong>，使用的是方法区的内存：</p><p>说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p><p>类变量初始化：</p><ul><li>static 变量分配空间和赋值是两个步骤：<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li><li>如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化</li><li>如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成</li></ul><p>实例：</p><ul><li><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>常量 value 被初始化为 123 而不是 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故 boolean 的默认值就是 false</p></li></ul><hr><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中类、接口、字段、方法的<strong>符号引用替换为直接引用</strong>（内存地址）的过程：</p><ul><li>符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和<strong>方法描述符</strong>（因为类还没有加载完，很多方法是找不到的）</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中</li></ul><p>例如：在 <code>com.demo.Solution</code> 类中引用了 <code>com.test.Quest</code>，把 <code>com.test.Quest</code> 作为符号引用存进类常量池，在类加载完后，<strong>用这个符号引用去方法区找这个类的内存地址</strong></p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等</p><ul><li>在类加载阶段解析的是非虚方法，静态绑定</li><li>也可以在初始化阶段之后再开始解析，这是为了支持 Java 的<strong>动态绑定</strong></li><li>通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> Load2.class.getClassLoader();</span><br><span class="line">    <span class="comment">// cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D</span></span><br><span class="line">    Class&lt;?&gt; c = classloader.loadClass(<span class="string">&quot;cn.jvm.t3.load.C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// new C();会导致类的解析和初始化，从而解析初始化D</span></span><br><span class="line">    System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 <clinit></p><p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init</p><p>类构造器 <clinit>() 与实例构造器 <init>() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机<strong>调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象</p><p>类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类</p><hr><h5 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h5><p><clinit>()：类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的</p><p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p><ul><li>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</li><li>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法</li><li>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定</li><li>static 不加 final 的变量都在初始化环节赋值</li></ul><p><strong>线程安全</strong>问题：</p><ul><li>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都阻塞等待，直到活动线程执行 <clinit>() 方法完毕</li><li>如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</li></ul><p>特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//i = 0;                // 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法，两者不同的是：</p><ul><li>在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法</li><li>在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 <clinit>() 方法</li><li>只有当父接口中定义的变量使用时，父接口才会初始化</li></ul><hr><h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><p>类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化</p><p><strong>主动引用</strong>：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：</p><ul><li>当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）</li><li>当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化<ul><li>getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）</li><li>putstatic：程序给类的静态变量赋值</li><li>invokestatic ：调用一个类的静态方法</li></ul></li><li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并<strong>不适用于接口</strong></li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类</li><li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ul><p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化，称为被动引用</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化</li><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li><li>常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li><li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li></ul><hr><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行</p><p>实例化即调用 <init>()V ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行</p><p>类实例化过程：<strong>父类的类构造器<clinit>() -&gt; 子类的类构造器<clinit>() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</strong></p><p>new 关键字会创建对象并复制 dup 一个对象引用，一个调用 <init> 方法，另一个用来赋值给接收者</p><hr><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java虚拟机进程终止</p><p>卸载类即该类的 <strong>Class 对象被 GC</strong>，卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成</li></ol><p>在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的</p><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h4><p>类加载方式：</p><ul><li>隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象<ul><li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li><li>在 JVM 启动时，通过三大类加载器加载 class</li></ul></li><li>显式加载：<ul><li>ClassLoader.loadClass(className)：只加载和连接，<strong>不会进行初始化</strong></li><li>Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li></ul></li></ul><p>类的唯一性：</p><ul><li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：<ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同</li></ul></li><li>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li></ul><p>命名空间：</p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>基本特征：</p><ul><li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li><li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li></ul><hr><h4 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h4><p>类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象</p><p>从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li><li>自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范<strong>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</strong>，使用 Java 语言实现，独立于虚拟机</li></ul><p>从 Java 开发人员的角度看：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：<ul><li>处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li><li>类加载器负责加载在 <code>JAVA_HOME/jre/lib</code> 或 <code>sun.boot.class.path</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中</li><li>仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li><li>启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li></ul></li><li>扩展类加载器（Extension ClassLoader）：<ul><li>由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null</li><li>将 <code>JAVA_HOME/jre/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li><li>开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载</li></ul></li><li>应用程序类加载器（Application ClassLoader）：<ul><li>由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension</li><li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li><li>这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器</li><li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器</li></ul></li><li>自定义类加载器：由开发人员自定义的类加载器，上级是 Application</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//获取系统类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层  扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">    System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@610455d6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层 获取不到引导类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">bootStrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">    System.out.println(bootStrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于用户自定义类来说：使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String 类使用引导类加载器进行加载的 --&gt; java核心类库都是使用启动类加载器加载的</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充两个类加载器：</p><ul><li>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联</li><li>ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ul><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p>获取 ClassLoader 的途径：</p><ul><li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li><li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread.getContextClassLoader()</code></li><li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的 ClassLoader：<code>DriverManager.getCallerClassLoader()</code></li></ul><p>ClassLoader 类常用方法：</p><ul><li><code>getParent()</code>：返回该类加载器的超类加载器  </li><li><code>loadclass(String name)</code>：加载名为 name 的类，返回结果为 Class 类的实例，<strong>该方法就是双亲委派模式</strong></li><li><code>findclass(String name)</code>：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用</li><li><code>findLoadedClass(String name)</code>：查找名称为 name 的已经被加载过的类，final 修饰无法重写</li><li><code>defineClass(String name, byte[] b, int off, int len)</code>：将<strong>字节流</strong>解析成 JVM 能够识别的类对象</li><li><code>resolveclass(Class&lt;?&gt; c)</code>：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</li><li><code>InputStream getResourceAsStream(String name)</code>：指定资源名称获取输入流</li></ul><hr><h4 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h4><h5 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h5><p>在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制</p><ul><li><p><strong>全盘加载：</strong>当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入</p></li><li><p><strong>双亲委派：</strong>先让父类加载器加载该 Class，在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。简单来说就是，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，<strong>依次递归</strong>，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载</p></li><li><p><strong>缓存机制：</strong>会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中</p><ul><li>这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因</li></ul></li></ul><hr><h5 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h5><p>双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p><p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p><p>双亲委派机制的优点：</p><ul><li><p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性</p></li><li><p>Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p></li><li><p>保护程序安全，防止类库的核心 API 被随意篡改</p><p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行 main 函数，会出现异常，在类 java.lang.String 中找不到 main 方法，防止恶意篡改核心 API 库。出现该信息是因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法</p></li></ul><p>双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-双亲委派模型.png" style="zoom: 50%;" /><hr><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">       <span class="comment">// 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前类加载器如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断当前类加载器是否有父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)</span></span><br><span class="line">         <span class="comment">// 父类加载器的 loadClass 方法，又会检查自己是否已经加载过</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader</span></span><br><span class="line">          <span class="comment">// 则调用 BootStrap ClassLoader 的方法加载类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载</span></span><br><span class="line">                <span class="comment">// 可以自定义 findClass() 方法</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">// 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="破坏委派"><a href="#破坏委派" class="headerlink" title="破坏委派"></a>破坏委派</h5><p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式</p><p>破坏双亲委派模型的方式：</p><ul><li><p>自定义 ClassLoader</p><ul><li>如果不想破坏双亲委派模型，只需要重写 findClass 方法</li><li>如果想要去破坏双亲委派模型，需要去**重写 loadClass **方法</li></ul></li><li><p>引入线程<strong>上下文类加载器</strong></p><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：</p><ul><li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的</li><li>SPI 的实现类是由系统类加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类</li></ul><p>JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型</p></li><li><p>实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）</p><p>IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p><p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</p><ol><li>将以 java.* 开头的类，委派给父类加载器加载</li><li>否则，将委派列表名单内的类，委派给父类加载器加载</li><li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li><li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li><li>否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载</li><li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li><li>否则，类查找失败</li></ol><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中</p></li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-热替换.png" style="zoom: 33%;" /><hr><h4 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h4><p>沙箱机制（Sandbox）：将 Java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，来保证对代码的有效隔离，防止对本地系统造成破坏</p><p>沙箱<strong>限制系统资源访问</strong>，包括 CPU、内存、文件系统、网络，不同级别的沙箱对资源访问的限制也不一样</p><ul><li>JDK1.0：Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码不可以访问本地资源，其实依赖于沙箱机制。如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现</li><li>JDK1.1：针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限</li><li>JDK1.2：改进了安全机制，增加了代码签名，不论本地代码或是远程代码都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</li><li>JDK1.6：当前最新的安全机制，引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，不同的保护域对应不一样的权限。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-沙箱机制.png" style="zoom:67%;" /><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>对于自定义类加载器的实现，只需要继承 ClassLoader 类，覆写 findClass 方法即可</p><p>作用：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类加载器，读取指定的类路径classPath下的class文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取字节码文件的完整路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> classPath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">// 获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">            <span class="comment">// 获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 具体读入数据并写出的过程</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="type">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">// 调用 defineClass()，将字节数组的数据转换为 Class 的实例。</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> defineClass(<span class="literal">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="literal">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:\Workspace\Project\JVM_study\src\java1\&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        Class clazz = loader.loadClass(&quot;</span>Demo1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>加载此类的类的加载器为：<span class="string">&quot; + clazz.getClassLoader().getClass().getName());//MyClassLoader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>加载当前类的类的加载器的父类加载器为：<span class="string">&quot; + clazz.getClassLoader().getParent().getClass().getName());//sun.misc.Launcher$AppClassLoader</span></span><br><span class="line"><span class="string">    &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="string">        e.printStackTrace();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><p>为了保证兼容性，JDK9 没有改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行做了一些变动：</p><ul><li><p>扩展机制被移除，扩展类加载器由于<strong>向后兼容性</strong>的原因被保留，不过被重命名为平台类加载器（platform classloader），可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取</p></li><li><p>JDK9 基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数个 JMOD 文件），其中 Java 类库就满足了可扩展的需求，那就无须再保留 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，此前使用这个目录或者 <code>java.ext.dirs</code> 系统变量来扩展 JDK 功能的机制就不需要再存在</p></li><li><p>启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code></p></li></ul><hr><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Java 文件编译执行的过程：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><ul><li>类加载器：用于装载字节码文件（.class文件）</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对 JVM 中的垃圾内容进行回收</li></ul><hr><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><h4 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h4><p>Java 语言：跨平台的语言（write once ，run anywhere）</p><ul><li>当 Java 源代码成功编译成字节码后，在不同的平台上面运行<strong>无须再次编译</strong></li><li>让一个 Java 程序正确地运行在 JVM 中，Java 源码就必须要被编译为符合 JVM 规范的字节码</li></ul><p>编译过程中的编译器：</p><ul><li><p>前端编译器： Sun 的全量式编译器 javac、 Eclipse 的增量式编译器 ECJ，<strong>把源代码编译为字节码文件 .class</strong></p><ul><li>IntelliJ IDEA 使用 javac 编译器</li><li>Eclipse 中，当开发人员编写完代码后保存时，ECJ 编译器就会把未编译部分的源码逐行进行编译，而非每次都全量编译，因此 ECJ 的编译效率会比 javac 更加迅速和高效</li><li>前端编译器并不会直接涉及编译优化等方面的技术，具体优化细节移交给 HotSpot 的 JIT 编译器负责</li></ul></li><li><p>后端运行期编译器：HotSpot VM 的 C1、C2 编译器，也就是 JIT 编译器，Graal 编译器</p><ul><li>JIT 编译器：执行引擎部分详解</li><li>Graal 编译器：JDK10 HotSpot 加入的一个全新的即时编译器，编译效果短短几年时间就追平了 C2</li></ul></li><li><p>静态提前编译器：AOT  (Ahead Of Time Compiler）编译器，直接把源代码编译成本地机器代码</p><ul><li><p>JDK 9 引入，是与即时编译相对立的一个概念，即时编译指的是在程序的运行过程中将字节码转换为机器码，AOT 是程序运行之前便将字节码转换为机器码</p></li><li><p>优点：JVM 加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少 Java 应用第一次运行慢的现象</p></li><li><p>缺点：</p><ul><li>破坏了 Java <strong>一次编译，到处运行</strong>，必须为每个不同硬件编译对应的发行包</li><li>降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知</li></ul></li></ul></li></ul><hr><h4 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h4><p>机器码：各种用二进制编码方式表示的指令，与 CPU 紧密相关，所以不同种类的 CPU 对应的机器指令不同</p><p>指令：指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令，例如 mov，inc 等，可读性稍好，但是不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同</p><p>指令集：不同的硬件平台支持的指令是有区别的，每个平台所支持的指令，称之为对应平台的指令集</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><p>汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址</p><ul><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li><li>计算机只认识指令码，汇编语言编写的程序也必须翻译成机器指令码，计算机才能识别和执行</li></ul><p>高级语言：为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言</p><p>字节码：是一种中间状态（中间码）的二进制代码，比机器码更抽象，需要直译器转译后才能成为机器码</p><ul><li>字节码为了实现特定软件运行和软件环境，与硬件环境无关</li><li>通过编译器和虚拟机器实现，编译器将源码编译成字节码，虚拟机器将字节码转译为可以直接执行的指令</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-高级语言执行过程.png" style="zoom:50%;" /><hr><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><p>字节码是一种二进制的类文件，是编译之后供虚拟机解释执行的二进制字节码文件，<strong>一个 class 文件对应一个 public 类型的类或接口</strong></p><p>字节码内容是 <strong>JVM 的字节码指令</strong>，不是机器码，C、C++ 经由编译器直接生成机器码，所以执行效率比 Java 高</p><p>JVM 官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>根据 JVM 规范，类文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_infoconstant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[fields_count];</span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，识别类文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表都以 <code>_info</code> 结尾，用于描述有层次关系的数据，整个 Class 文件本质上就是一张表，由于表没有固定长度，所以通常会在其前面加上个数说明</li></ul><p>获取方式：</p><ul><li>HelloWorld.java 执行 <code>javac -parameters -d . HellowWorld.java</code>指令</li><li>写入文件指令 <code>javap -v xxx.class &gt;xxx.txt</code></li><li>IDEA 插件 jclasslib</li></ul><hr><h5 id="魔数版本"><a href="#魔数版本" class="headerlink" title="魔数版本"></a>魔数版本</h5><p>魔数：每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number），是 Class 文件的标识符，代表这是一个能被虚拟机接受的有效合法的 Class 文件，</p><ul><li><p>魔数值固定为 0xCAFEBABE，不符合则会抛出错误</p></li><li><p>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</p></li></ul><p>版本：4 个 字节，5 6两个字节代表的是编译的副版本号 minor_version，而 7 8 两个字节是编译的主版本号 major_version</p><ul><li>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，反之 JVM 会抛出异常 <code>java.lang.UnsupportedClassVersionError</code></li></ul><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><p>图片来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><hr><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池计数器（constant_pool_count），这个容量计数是从 1 而不是 0 开始，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量池项目，这种情况可用索引值 0 来表示</p><p>constant_pool 是一种表结构，以1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池</p><ul><li><p>字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等</p></li><li><p>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p><ul><li><p>全限定名：com&#x2F;test&#x2F;Demo 这个就是类的全限定名，仅仅是把包名的 <code>.</code> 替换成 <code>/</code>，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 <code>;</code> 表示全限定名结束</p></li><li><p>简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 x 的简单名称就是 x</p></li><li><p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td>J</td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td>Z</td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code>，不同方法间用<code>;</code>隔开</td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table></li></ul></li></ul><p>常量类型和结构：</p><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer</p><hr><h5 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h5><p>访问标识（access_flag），又叫访问标志、访问标记，该标识用两个字节表示，用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public类型，是否定义为 abstract类型等</p><ul><li>类的访问权限通常为 ACC_ 开头的常量</li><li>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的，比如若是 public final 的类，则该标记为 <code>ACC_PUBLIC | ACC_FINAL</code></li><li>使用 <code>ACC_SUPER</code> 可以让类更准确地定位到父类的方法，确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为 public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><hr><h5 id="索引集合"><a href="#索引集合" class="headerlink" title="索引集合"></a>索引集合</h5><p>类索引、父类索引、接口索引集合</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个，除了Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口</p><ul><li>interfaces_count 项的值表示当前类或接口的直接超接口数量</li><li>interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中</li></ul></li></ul><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><hr><h5 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h5><p>字段 fields 用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述</p><p>fields_count（字段计数器），表示当前 class 文件 fields 表的成员个数，用两个字节来表示</p><p>fields[]（字段表）：</p><ul><li><p>表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p>字段访问标识：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table></li><li><p>字段名索引：根据该值查询常量池中的指定索引项即可</p></li><li><p>描述符索引：用来描述字段的数据类型、方法的参数列表和返回值</p><table><thead><tr><th>字符</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>有符号字节型树</td></tr><tr><td>C</td><td>char</td><td>Unicode字符，UTF-16编码</td></tr><tr><td>D</td><td>double</td><td>双精度浮点数</td></tr><tr><td>F</td><td>float</td><td>单精度浮点数</td></tr><tr><td>I</td><td>int</td><td>整型数</td></tr><tr><td>J</td><td>long</td><td>长整数</td></tr><tr><td>S</td><td>short</td><td>有符号短整数</td></tr><tr><td>Z</td><td>boolean</td><td>布尔值true&#x2F;false</td></tr><tr><td>V</td><td>void</td><td>代表void类型</td></tr><tr><td>L Classname</td><td>reference</td><td>一个名为Classname的实例</td></tr><tr><td>[</td><td>reference</td><td>一个一维数组</td></tr></tbody></table></li><li><p>属性表集合：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于常量属性而言，attribute_length 值恒为2</p></li></ul><hr><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，完整描述了每个方法的签名</p><ul><li>如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来</li><li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li><li>methods 表可能会出现由编译器自动添加的方法，比如初始化方法 <cinit> 和实例化方法 <init></li></ul><p><strong>重载（Overload）</strong>一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存</p><p>methods_count（方法计数器）：表示 class 文件 methods 表的成员个数，使用两个字节来表示</p><p>methods[]（方法表）：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述</p><ul><li><p>方法表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attrubutes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table></li><li><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为 enum</td></tr></tbody></table></li></ul><hr><h5 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h5><p>属性表集合，指的是 Class 文件所携带的辅助信息，比如该 Class 文件的源文件的名称，以及任何带有 <code>RetentionPolicy.CLASS</code> 或者 <code>RetentionPolicy.RUNTIME</code> 的注解，这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试。字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息</p><p>attributes_ count（属性计数器）：表示当前文件属性表的成员个数</p><p>attributes[]（属性表）：属性表的每个项的值必须是 attribute_info 结构</p><ul><li><p>属性的通用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;<span class="comment">//属性名索引</span></span><br><span class="line">    u4 attribute_length;<span class="comment">//属性长度</span></span><br><span class="line">    u2 attribute_info;<span class="comment">//属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性类型：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类、方法、字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code 属性</td><td>Java 源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code 属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code 属性</td><td>JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Syothetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编泽器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td></tr><tr><td>RuntirmelnvisibleParameterAnniotation</td><td>方法表</td><td>作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数</td></tr><tr><td>AnnotationDefauit</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存 invokeddynanic 指令引用的引导方式限定符</td></tr></tbody></table></li></ul><hr><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><h5 id="javac"><a href="#javac" class="headerlink" title="javac"></a>javac</h5><p>javac：编译命令，将 java 源文件编译成 class 字节码文件</p><p><code>javac xx.java</code> 不会在生成对应的局部变量表等信息，使用 <code>javac -g xx.java</code> 可以生成所有相关信息</p><hr><h5 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h5><p>javap 反编译生成的字节码文件，根据 class 字节码文件，反解析出当前类对应的 code 区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息</p><p>用法：javap <options> <classes></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的/公共类和成员</span><br><span class="line">-package                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line"> <span class="comment">#常用的以下三个</span></span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-c                       对代码进行反汇编<span class="comment">#反编译</span></span><br><span class="line"></span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-<span class="built_in">cp</span> &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><hr><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h5 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h5><p>Java 字节码属于 JVM 基本执行指令。由一个字节长度的代表某种操作的操作码（opcode）以及零至多个代表此操作所需参数的操作数（operand）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码（零地址指令）</p><p>由于限制了 Java 虚拟机操作码的长度为一个字节（0~255），所以指令集的操作码总数不可能超过 256 条</p><p>在 JVM 的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如 iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据</p><ul><li>i 代表对 int 类型的数据操作</li><li>l 代表 long </li><li>s 代表 short</li><li>b 代表 byte</li><li>c 代表 char</li><li>f 代表 float</li><li>d 代表 double</li></ul><p>大部分的指令都没有支持 byte、char、short、boolean 类型，编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend-）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据</p><p>在做值相关操作时:</p><ul><li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，也可能是对象的引用）被压入操作数栈</li><li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等等操作</li></ul><hr><h5 id="加载存储"><a href="#加载存储" class="headerlink" title="加载存储"></a>加载存储</h5><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</p><p>局部变量压栈指令：将给定的局部变量表中的数据压入操作数栈</p><ul><li>xload、xload_n，x 表示取值数据类型，为 i、l、f、d、a， n 为 0 到 3</li><li>指令 xload_n 表示将第 n 个局部变量压入操作数栈，aload_n 表示将一个对象引用压栈</li><li>指令 xload n 通过指定参数的形式，把局部变量压入操作数栈，局部变量数量超过 4 个时使用这个命令</li></ul><p>常量入栈指令：将常数压入操作数栈，根据数据类型和入栈内容的不同，又分为 const、push、ldc 指令</p><ul><li>push：包括 bipush 和 sipush，区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数</li><li>ldc：如果以上指令不能满足需求，可以使用 ldc 指令，接收一个 8 位的参数，该参数指向常量池中的 int、 float 或者 String 的索引，将指定的内容压入堆栈。ldc_w 接收两个 8 位参数，能支持的索引范围更大，如果要压入的元素是 long 或 double 类型的，则使用 ldc2_w 指令</li><li>aconst_null 将 null 对象引用压入栈，iconst_m1 将 int 类型常量 -1 压入栈，iconst_0 将 int 类型常量 0 压入栈</li></ul><p>出栈装入局部变量表指令：将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</p><ul><li>xstore、xstore_n，x 表示取值类型为 i、l、f、d、a， n 为 0 到 3</li><li>xastore 表示存入数组，x 取值为 i、l、f、d、a、b、c、s</li></ul><p>扩充局部变量表的访问索引的指令：wide</p><hr><h5 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h5><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈</p><p>没有直接支持 byte、 short、 char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理，数组类型也是转换成 int 数组</p><ul><li><p>加法指令：iadd、ladd、fadd、dadd</p></li><li><p>减法指令：isub、lsub、fsub、dsub</p></li><li><p>乘法指令：imu、lmu、fmul、dmul</p></li><li><p>除法指令：idiv、ldiv、fdiv、ddiv</p></li><li><p>求余指令：irem、lrem、frem、drem（remainder 余数）</p></li><li><p>取反指令：ineg、lneg、fneg、dneg （negation 取反）</p></li><li><p>自增指令：iinc（直接<strong>在局部变量 slot 上进行运算</strong>，不用放入操作数栈）</p></li><li><p>位运算指令，又可分为：</p><ul><li>位移指令：ishl、ishr、 iushr、lshl、lshr、 lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li></ul></li><li><p>比较指令：dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p></li></ul><p>运算模式：</p><ul><li>向最接近数舍入模式，JVM 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示形式与该值一样接近，将优先选择最低有效位为零的</li><li>向零舍入模式：将浮点数转换为整数时，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果</li></ul><p>NaN 值：当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义，将使用 NaN 值来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> i / <span class="number">0.0</span>;</span><br><span class="line">System.out.println(j);<span class="comment">//无穷大，NaN: not a number</span></span><br></pre></td></tr></table></figure><p>**分析 i++**：从字节码角度分析：a++ 和 ++a 的区别是先执行 iload 还是先执行 iinc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">4</span> iload_1<span class="comment">//存入操作数栈</span></span><br><span class="line"> <span class="number">5</span> iinc <span class="number">1</span> by <span class="number">1</span><span class="comment">//自增i++</span></span><br><span class="line"> <span class="number">8</span> istore_3<span class="comment">//把操作数栈没有自增的数据的存入局部变量表</span></span><br><span class="line"> <span class="number">9</span> iinc <span class="number">2</span> by <span class="number">1</span><span class="comment">//++i</span></span><br><span class="line"><span class="number">12</span> iload_2<span class="comment">//加载到操作数栈</span></span><br><span class="line"><span class="number">13</span> istore <span class="number">4</span><span class="comment">//存入局部变量表，这个存入没有 _ 符号，_只能到3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);<span class="comment">//11</span></span><br><span class="line">        System.out.println(b);<span class="comment">//34</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); <span class="comment">// 结果是 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>类型转换指令可以将两种不同的数值类型进行相互转换，除了 boolean 之外的七种类型</p><p>宽化类型转换：</p><ul><li><p>JVM 支持以下数值的宽化类型转换（widening numeric conversion），小范围类型到大范围类型的安全转换</p><ul><li>从 int 类型到 long、float 或者 double 类型，对应的指令为 i2l、i2f、i2d</li><li>从 long 类型到 float、 double 类型，对应的指令为 l2f、l2d</li><li>从 float 类型到 double 类型，对应的指令为 f2d</li></ul></li><li><p>精度损失问题</p><ul><li>宽化类型转换是不会因为超过目标类型最大值而丢失信息</li><li>从 int 转换到 float 或者 long 类型转换到 double 时，将可能发生精度丢失</li></ul></li><li><p>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，JVM 把它们当作 int 处理</p></li></ul><p>窄化类型转换：</p><ul><li><p>Java 虚拟机直接支持以下窄化类型转换：</p><ul><li>从 int 类型至 byte、 short 或者 char 类型，对应的指令有 i2b、i2c、i2s</li><li>从 long 类型到 int 类型，对应的指令有 l2i</li><li>从 float 类型到 int 或者 long 类型，对应的指令有:f2i、f2l</li><li>从 double 类型到 int、long 或 float 者类型，对应的指令有 d2i、d2、d2f</li></ul></li><li><p>精度损失问题：</p><ul><li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，转换过程可能会导致数值丢失精度</li><li>将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）时，将遵循以下转换规则：<ul><li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0</li><li>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T 的表示范围之内，那转换结果就是 v，否则将根据 v 的符号，转换为 T 所能表示的最大或者最小正数</li></ul></li></ul></li></ul><hr><h5 id="创建访问"><a href="#创建访问" class="headerlink" title="创建访问"></a>创建访问</h5><p>创建指令：</p><ul><li><p>创建类实例指令：new，接收一个操作数指向常量池的索引，表示要创建的类型，执行完成后将对象的引用压入栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class com/jvm/bytecode/Demo</span></span><br><span class="line"><span class="number">3</span>:  dup</span><br><span class="line"><span class="number">4</span>:  invokespecial   #<span class="number">3</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br></pre></td></tr></table></figure><p><strong>dup 是复制操作数栈栈顶的内容</strong>，需要两份引用原因：</p><ul><li>一个要配合 invokespecial 调用该对象的构造方法 <init>:()V （会消耗掉栈顶一个引用）</li><li>一个要配合 astore_1 赋值给局部变量</li></ul></li><li><p>创建数组的指令：newarray、anewarray、multianewarray</p><ul><li>newarray：创建基本类型数组</li><li>anewarray：创建引用类型数组</li><li>multianewarray：创建多维数组</li></ul></li></ul><p>字段访问指令：对象创建后可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素</p><ul><li>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</li><li>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield</li></ul><p>类型检查指令：检查类实例或数组类型的指令</p><ul><li><p>checkcast：用于检查类型强制转换是否可以进行，如果可以进行 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常</p></li><li><p>instanceof：判断给定对象是否是某一个类的实例，会将判断结果压入操作数栈</p></li></ul><hr><h5 id="方法指令"><a href="#方法指令" class="headerlink" title="方法指令"></a>方法指令</h5><p>方法调用指令：invokevirtual、 invokeinterface、invokespecial、invokestatic、invokedynamic</p><p><strong>方法调用章节详解</strong></p><hr><h5 id="操作数栈-1"><a href="#操作数栈-1" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令</p><ul><li><p>pop、pop2：将一个或两个元素从栈顶弹出，并且直接废弃</p></li><li><p>dup、dup2，dup_x1、dup2_x1，dup_x2、dup2_x2：复制栈顶一个或两个数值并重新压入栈顶</p></li><li><p>swap：将栈最顶端的两个 slot 数值位置交换，JVM 没有提供交换两个 64 位数据类型数值的指令</p></li><li><p>nop：一个非常特殊的指令，字节码为 0x00，和汇编语言中的 nop 一样，表示什么都不做，一般可用于调试、占位等</p></li></ul><hr><h5 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h5><p>比较指令：比较栈顶两个元素的大小，并将比较结果入栈</p><ul><li>lcmp：比较两个 long 类型值</li><li>fcmpl：比较两个 float 类型值（当遇到NaN时，返回-1）</li><li>fcmpg：比较两个 float 类型值（当遇到NaN时，返回1）</li><li>dcmpl：比较两个 double 类型值（当遇到NaN时，返回-1）</li><li>dcmpg：比较两个 double 类型值（当遇到NaN时，返回1）</li></ul><p>条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ifeq</td><td>equals，当栈顶int类型数值等于0时跳转</td></tr><tr><td>ifne</td><td>not equals，当栈顶in类型数值不等于0时跳转</td></tr><tr><td>iflt</td><td>lower than，当栈顶in类型数值小于0时跳转</td></tr><tr><td>ifle</td><td>lower or equals，当栈顶in类型数值小于等于0时跳转</td></tr><tr><td>ifgt</td><td>greater than，当栈顶int类型数组大于0时跳转</td></tr><tr><td>ifge</td><td>greater or equals，当栈顶in类型数值大于等于0时跳转</td></tr><tr><td>ifnull</td><td>为 null 时跳转</td></tr><tr><td>ifnonnull</td><td>不为 null 时跳转</td></tr></tbody></table><p>比较条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>if_icmpeq</td><td>比较栈顶两 int 类型数值大小（下同），当前者等于后者时跳转</td></tr><tr><td>if_icmpne</td><td>当前者不等于后者时跳转</td></tr><tr><td>if_icmplt</td><td>当前者小于后者时跳转</td></tr><tr><td>if_icmple</td><td>当前者小于等于后者时跳转</td></tr><tr><td>if_icmpgt</td><td>当前者大于后者时跳转</td></tr><tr><td>if_icmpge</td><td>当前者大于等于后者时跳转</td></tr><tr><td>if_acmpeq</td><td>当结果相等时跳转</td></tr><tr><td>if_acmpne</td><td>当结果不相等时跳转</td></tr></tbody></table><p>多条件分支跳转指令：</p><ul><li>tableswitch：用于 switch 条件跳转，case 值连续</li><li>lookupswitch：用于 switch 条件跳转，case 值不连续</li></ul><p>无条件跳转指令：</p><ul><li><p>goto：用来进行跳转到指定行号的字节码</p></li><li><p>goto_w：无条件跳转（宽索引）</p></li></ul><hr><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h6 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h6><p>抛出异常指令：athrow 指令</p><p>JVM 处理异常（catch 语句）不是由字节码指令来实现的，而是<strong>采用异常表来完成</strong>的</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        i = <span class="number">10</span>;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">        i = <span class="number">20</span>;   </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><ul><li>多出一个 <strong>Exception table</strong> 的结构，**[from, to) 是前闭后开的检测范围**，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>11 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置，因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: iconst_0</span><br><span class="line">    <span class="number">1</span>: istore_1 <span class="comment">// 0 -&gt; i-&gt;赋值</span></span><br><span class="line">    <span class="number">2</span>: bipush <span class="number">10</span> <span class="comment">// try 10 放入操作数栈顶</span></span><br><span class="line">    <span class="number">4</span>: istore_1 <span class="comment">// 10 -&gt; i 将操作数栈顶数据弹出，存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">5</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】 </span></span><br><span class="line">    <span class="number">7</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">8</span>: goto <span class="number">27</span> <span class="comment">// return -----------------------------------</span></span><br><span class="line">    <span class="number">11</span>: astore_2 <span class="comment">// catch Exceptin -&gt; e ----------------------</span></span><br><span class="line">    <span class="number">12</span>: bipush <span class="number">20</span> <span class="comment">// </span></span><br><span class="line">    <span class="number">14</span>: istore_1 <span class="comment">// 20 -&gt; i </span></span><br><span class="line">    <span class="number">15</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】 </span></span><br><span class="line">    <span class="number">17</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">18</span>: goto <span class="number">27</span> <span class="comment">// return -----------------------------------</span></span><br><span class="line">    <span class="number">21</span>: astore_3 <span class="comment">// catch any -&gt; slot 3 ----------------------</span></span><br><span class="line">    <span class="number">22</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】</span></span><br><span class="line">    <span class="number">24</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">25</span>: aload_3 <span class="comment">// 将局部变量表的slot 3数据弹出，放入操作数栈栈顶</span></span><br><span class="line">    <span class="number">26</span>: athrow <span class="comment">// throw 抛出异常</span></span><br><span class="line">    <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">Exception table:</span><br><span class="line"><span class="comment">// 任何阶段出现任务异常都会执行 finally</span></span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">2</span><span class="number">5</span> <span class="number">11</span> Class java/lang/Exception</span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">21</span> any <span class="comment">// 剩余的异常类型，比如 Error</span></span><br><span class="line"><span class="number">11</span> <span class="number">15</span> <span class="number">21</span> any <span class="comment">// 剩余的异常类型，比如 Error</span></span><br><span class="line">LineNumberTable: ...</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line"><span class="number">12</span> <span class="number">3</span> <span class="number">2</span> e Ljava/lang/Exception;</span><br><span class="line"><span class="number">0</span> <span class="number">28</span> <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line"><span class="number">2</span> <span class="number">26</span> <span class="number">1</span> i I</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h6><p>finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程（上节案例）</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 -&gt; slot 0 【从栈顶移除了】</span></span><br><span class="line">    <span class="number">3</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">5</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">    <span class="number">6</span>: astore_1 <span class="comment">// catch any 存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">7</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">0</span><span class="number">3</span><span class="number">6</span> any      </span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="return"><a href="#return" class="headerlink" title="return"></a>return</h6><ul><li><p>吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 -&gt; slot 0 【从栈顶移除了】</span></span><br><span class="line">    <span class="number">3</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">5</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">    <span class="number">6</span>: astore_1 <span class="comment">// catch any  存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">7</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">0</span><span class="number">3</span><span class="number">6</span> any      </span><br></pre></td></tr></table></figure><ul><li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果以 finally 的为准</li><li>字节码中没有 <strong>athrow</strong> ，表明如果在 finally 中出现了 return，会<strong>吞掉异常</strong></li></ul></li><li><p>不吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">    System.out.println(result);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//返回10</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 赋值给i，放入slot 0</span></span><br><span class="line">    <span class="number">3</span>: iload_0 <span class="comment">// i(10)加载至操作数栈</span></span><br><span class="line">    <span class="number">4</span>: istore_1 <span class="comment">// 10 -&gt; slot 1，【暂存至 slot 1，目的是为了固定返回值】</span></span><br><span class="line">    <span class="number">5</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">7</span>: istore_0 <span class="comment">// 20 slot 0</span></span><br><span class="line">    <span class="number">8</span>: iload_1 <span class="comment">// slot 1(10) 载入 slot 1 暂存的值</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶的 int(10)</span></span><br><span class="line">    <span class="number">10</span>: astore_2<span class="comment">// catch any -&gt; slot 2 存入局部变量表的 slot2</span></span><br><span class="line">    <span class="number">11</span>: bipush <span class="number">20</span></span><br><span class="line">    <span class="number">13</span>: istore_0</span><br><span class="line">    <span class="number">14</span>: aload_2</span><br><span class="line">    <span class="number">15</span>: athrow<span class="comment">// 不会吞掉异常</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line">  <span class="number">3</span>   <span class="number">5</span><span class="number">10</span> any  </span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>方法级的同步：是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法</p><p>方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义</p><ul><li>montiorenter：进入并获取对象监视器，即为栈顶对象加锁</li><li>monitorexit：释放并退出对象监视器，即为栈顶对象解锁</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码指令同步控制.png" style="zoom: 33%;" /><hr><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>原始 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -v Demo.class：省略</p><ul><li><p>常量池载入运行时常量池</p></li><li><p>方法区字节码载入方法区</p></li><li><p>main 线程开始运行，分配栈帧内存：（操作数栈stack&#x3D;2，局部变量表locals&#x3D;4）</p></li><li><p><strong>执行引擎</strong>开始执行字节码</p><p><code>bipush 10</code>：将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li></ul><p><code>istore_1</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1.png"></p><p><code>ldc #3</code>：从常量池加载 #3 数据到操作数栈<br>Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算完成</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png"></p><p><code>istore_2</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 2</p><p><code>iload_1</code>：将局部变量表的 slot 1 数据弹出，放入操作数栈栈顶</p><p><code>iload_2</code>：将局部变量表的 slot 2 数据弹出，放入操作数栈栈顶</p><p><code>iadd</code>：执行相加操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B3.png"></p><p><code>istore_3</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 3</p><p><code>getstatic #4</code>：获取静态字段</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B4.png"></p><p><code>iload_3</code>：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B5.png"></p><p><code>invokevirtual #5</code>：</p><ul><li>找到常量池 #5 项</li><li>定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</li><li><strong>生成新的栈帧</strong>（分配 locals、stack等）</li><li>传递参数，执行新栈帧中的字节码</li><li>执行完毕，弹出栈帧</li><li>清除 main 操作数栈内容</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B6.png"></p><p>return：完成 main 方法调用，弹出 main 栈帧，程序结束</p></li></ul><hr><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>执行引擎：Java 虚拟机的核心组成部分之一，类加载主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，需要执行引擎将<strong>字节码指令解释&#x2F;编译为对应平台上的本地机器指令</strong>，进行执行</p><p>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力：</p><ul><li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上</li><li>虚拟机的执行引擎是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系</li></ul><p>Java 是<strong>半编译半解释型语言</strong>，将解释执行与编译执行二者结合起来进行：</p><ul><li>解释器：根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行</li><li>即时编译器（JIT : Just In Time Compiler）：虚拟机运行时将源代码直接编译成<strong>和本地机器平台相关的机器码</strong>后再执行，并存入 Code Cache，下次遇到相同的代码直接执行，效率高</li></ul><hr><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><p>HotSpot VM 采用<strong>解释器与即时编译器并存的架构</strong>，解释器和即时编译器能够相互协作，去选择最合适的方式来权衡编译本地代码和直接解释执行代码的时间</p><p>HostSpot JVM 的默认执行方式：</p><ul><li>当程序启动后，解释器可以马上发挥作用立即执行，省去编译器编译的时间（解释器存在的<strong>必要性</strong>）</li><li>随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</li></ul><p>HotSpot VM 可以通过 VM 参数设置程序执行方式：</p><ul><li>-Xint：完全采用解释器模式执行程序</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><hr><h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><p>热点代码：被 JIT 编译器编译的字节码，根据代码被调用执行的频率而定，一个被多次调用的方法或者一个循环次数较多的循环体都可以被称之为热点代码</p><p>热点探测：JIT 编译器在运行时会针热点代码做出深度优化，将其直接编译为对应平台的本地机器指令进行缓存，以提升程序执行性能</p><p>JIT 编译在默认情况是异步进行的，当触发某方法或某代码块的优化时，先将其放入编译队列，然后由编译线程进行编译，编译之后的代码放在 CodeCache 中，通过 <code>-XX:-BackgroundCompilation</code> 参数可以关闭异步编译</p><ul><li><strong>CodeCache</strong> 用于缓存编译后的机器码、动态生成的代码和本地方法代码 JNI</li><li>如果 CodeCache 区域被占满，编译器被停用，字节码将不会编译为机器码，应用程序继续运行，但运行性能会降低很多</li></ul><p>HotSpot VM 采用的热点探测方式是基于计数器的热点探测，为每一个方法都建立 2 个不同类型的计数器：方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter）</p><ul><li><p>方法调用计数器：用于统计方法被调用的次数，默认阈值在 Client 模式 下是 1500 次，在 Server 模式下是 10000 次（需要进行激进的优化），超过这个阈值，就会触发 JIT 编译，阈值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 设置</p><p>工作流程：当一个方法被调用时， 会先检查该方法是否存在被 JIT 编译过的版本，存在则使用编译后的本地代码来执行；如果不存在则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果超过阈值会向即时编译器<strong>提交一个该方法的代码编译请求</strong></p></li><li><p>回边计数器：统计一个方法中循环体代码执行的次数，在字节码中控制流向后跳转的指令称为回边</p><p>如果一个方法中的循环体需要执行多次，可以优化为为栈上替换，简称 OSR (On StackReplacement) 编译，<strong>OSR 替换循环代码体的入口，C1、C2 替换的是方法调用的入口</strong>，OSR 编译后会出现方法的整段代码被编译了，但是只有循环体部分才执行编译后的机器码，其他部分仍是解释执行</p></li></ul><hr><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>HotSpot VM 内嵌两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器</p><p>C1 编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度，C1 编译器的优化方法：</p><ul><li><p>方法内联：<strong>将调用的函数代码编译到调用点处</strong>，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p><p>方法内联能够消除方法调用的固定开销，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>square 是热点方法，会进行内联，把方法内代码拷贝粘贴到调用者的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>还能够进行常量折叠（constant folding）的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure></li><li><p>冗余消除：根据运行时状况进行代码折叠或削除</p></li><li><p>内联缓存：是一种加快动态绑定的优化技术（方法调用部分详解）</p></li></ul><p>C2 编译器进行耗时较长的优化以及激进优化，优化的代码执行效率更高，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因</p><p>C2 的优化主要是在全局层面，逃逸分析是优化的基础：标量替换、栈上分配、同步消除</p><p>VM 参数设置：</p><ul><li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器</li><li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器</li><li><code>-server -XX:+TieredCompilation</code>：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启</li></ul><p>分层编译策略 (Tiered Compilation)：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：</p><ul><li><p>0 层，解释执行（Interpreter）</p></li><li><p>1 层，使用 C1 即时编译器编译执行（不带 profiling）</p></li><li><p>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</p></li><li><p>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</p></li><li><p>4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）</p><p>说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p></li></ul><p>参考文章：<a href="https://www.jianshu.com/p/20bd2e9b1f03">https://www.jianshu.com/p/20bd2e9b1f03</a></p><hr><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="方法识别"><a href="#方法识别" class="headerlink" title="方法识别"></a>方法识别</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）</p><ul><li><strong>方法描述符是由方法的参数类型以及返回类型所构成</strong>，Java 层面叫方法特征签名</li><li>在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错</li></ul><p>JVM 根据名字和描述符来判断的，只要返回值不一样（方法描述符不一样），其它完全一样，在 JVM 中是允许的，但 Java 语言不允许</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型不同，编译阶段直接报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">invoke</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">invoke</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="调用机制"><a href="#调用机制" class="headerlink" title="调用机制"></a>调用机制</h4><p>方法调用并不等于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>，不是方法的具体运行过程</p><p>在 JVM 中，将符号引用转换为直接引用有两种机制：</p><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程称之为静态链接（类加载的解析阶段）</li><li>动态链接：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接（初始化后的解析阶段）</li></ul><p>对应方法的绑定（分配）机制：静态绑定和动态绑定。绑定是一个字段、方法或者类从符号引用被替换为直接引用的过程，仅发生一次：</p><ul><li>静态绑定：被调用的目标方法在编译期可知，且运行期保持不变，将这个方法与所属的类型进行绑定</li><li>动态绑定：被调用的目标方法在编译期无法确定，只能在程序运行期根据实际的类型绑定相关的方法</li></ul><ul><li>Java 编译器已经区分了重载的方法（静态绑定和动态绑定），因此可以认为虚拟机中不存在重载</li></ul><p>非虚方法：</p><ul><li>非虚方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</li><li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>所有普通成员方法、实例方法、被重写的方法都是虚方法</li></ul><p>动态类型语言和静态类型语言：</p><ul><li><p>在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言</p></li><li><p>静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</p></li><li><p><strong>Java 是静态类型语言</strong>（尽管 Lambda 表达式为其增加了动态特性），JS，Python 是动态类型语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;   <span class="comment">//Java</span></span><br><span class="line">info = <span class="string">&quot;abc&quot;</span>;       <span class="comment">//Python</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h4><h5 id="五种指令"><a href="#五种指令" class="headerlink" title="五种指令"></a>五种指令</h5><p>普通调用指令：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：调用私有实例方法、构造器，和父类的实例方法或构造器，以及所实现接口的默认方法</li><li>invokevirtual：调用所有虚方法（虚方法分派）</li><li>invokeinterface：调用接口方法</li></ul><p>动态调用指令：</p><ul><li>invokedynamic：动态解析出需要调用的方法<ul><li>Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令</li><li>Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式</li></ul></li></ul><p>指令对比：</p><ul><li>普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法</li><li>动态调用指令支持用户确定方法</li><li>invokestatic 和 invokespecial 指令调用的方法称为非虚方法，虚拟机能够直接识别具体的目标方法</li><li>invokevirtual 和 invokeinterface 指令调用的方法称为虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法</li></ul><p>指令说明：</p><ul><li>如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态</li></ul><hr><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>在编译过程中，虚拟机并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法，这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符</p><ul><li>对于静态绑定的方法调用而言，实际引用是一个指向方法的指针</li><li>对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引</li></ul><p>符号引用存储在方法区常量池中，根据目标方法是否为接口方法，分为接口符号引用和非接口符号引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">...</span><br><span class="line">  #<span class="number">16</span> = InterfaceMethodref #<span class="number">27.</span>#<span class="number">29</span><span class="comment">// 接口</span></span><br><span class="line">...</span><br><span class="line">  #<span class="number">22</span> = Methodref          #<span class="number">1.</span>#<span class="number">33</span><span class="comment">// 非接口</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 C 中查找符合名字及描述符的方法</li><li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类</li><li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果有多个符合条件的目标方法，则任意返回其中一个</li></ol><p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 I 中查找符合名字及描述符的方法</li><li>如果没有找到，在 Object 类中的公有实例方法中搜索</li><li>如果没有找到，则在 I 的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致</li></ol><hr><h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo3_9</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3_9</span>();</span><br><span class="line">        d.test1();</span><br><span class="line">        d.test2();</span><br><span class="line">        d.test3();</span><br><span class="line">        d.test4();</span><br><span class="line">        Demo.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几种不同的方法调用对应的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class cn/jvm/t3/bytecode/Demo</span></span><br><span class="line"><span class="number">3</span>:  dup</span><br><span class="line"><span class="number">4</span>:  invokespecial   #<span class="number">3</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>:  astore_1</span><br><span class="line"><span class="number">8</span>:  aload_1</span><br><span class="line"><span class="number">9</span>:  invokespecial   #<span class="number">4</span> <span class="comment">// Method test1:()V</span></span><br><span class="line"><span class="number">12</span>: aload_1</span><br><span class="line"><span class="number">13</span>: invokespecial   #<span class="number">5</span> <span class="comment">// Method test2:()V</span></span><br><span class="line"><span class="number">16</span>: aload_1</span><br><span class="line"><span class="number">17</span>: invokevirtual   #<span class="number">6</span> <span class="comment">// Method test3:()V</span></span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"><span class="number">21</span>: pop</span><br><span class="line"><span class="number">22</span>: invokestatic    #<span class="number">7</span> <span class="comment">// Method test4:()V</span></span><br><span class="line"><span class="number">25</span>: invokestatic    #<span class="number">7</span> <span class="comment">// Method test4:()V</span></span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>invokespecial 调用该对象的构造方法 <init>:()V </li><li>invokevirtual 调用对象的成员方法</li><li><code>d.test4()</code> 是通过<strong>对象引用</strong>调用一个静态方法，在调用 invokestatic 之前执行了 pop 指令，把对象引用从操作数栈弹掉<ul><li>不建议使用 <code>对象.静态方法()</code> 的方式调用静态方法，多了 aload 和 pop 指令</li><li>成员方法与静态方法调用的区别是：执行方法前是否需要对象引用</li></ul></li></ul><hr><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><h5 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h5><p>Java 虚拟机中关于方法重写的判定基于方法描述符，如果子类定义了与父类中非私有、非静态方法同名的方法，只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写</p><p>理解多态：</p><ul><li>多态有编译时多态和运行时多态，即静态绑定和动态绑定</li><li>前者是通过方法重载实现，后者是通过重写实现（子类覆盖父类方法，虚方法表）</li><li>虚方法：运行时动态绑定的方法，对比静态绑定的非虚方法调用来说，虚方法调用更加耗时</li></ul><p>方法重写的本质：</p><ol><li><p>找到操作数栈的第一个元素<strong>所执行的对象的实际类型</strong>，记作 C</p></li><li><p>如果在类型 C 中找到与描述符和名称都相符的方法，则进行访问<strong>权限校验</strong>（私有的），如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</p><p>IllegalAccessError：表示程序试图访问或修改一个属性或调用一个方法，这个属性或方法没有权限访问，一般会引起编译器异常。如果这个错误发生在运行时，就说明一个类发生了不兼容的改变</p></li><li><p>找不到，就会按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程</p></li><li><p>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</p></li></ol><hr><h5 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h5><p>在虚拟机工作过程中会频繁使用到动态绑定，每次动态绑定的过程中都要重新在类的元数据中搜索合适目标，影响到执行效率。为了提高性能，JVM 采取了一种用<strong>空间换取时间</strong>的策略来实现动态绑定，在每个<strong>类的方法区</strong>建立一个虚方法表（virtual method table），实现使用索引表来代替查找，可以快速定位目标方法</p><ul><li>invokevirtual 所使用的虚方法表（virtual method table，vtable），执行流程<ol><li>先通过栈帧中的对象引用找到对象，分析对象头，找到对象的实际 Class</li><li>Class 结构中有 vtable，查表得到方法的具体地址，执行方法的字节码</li></ol></li><li>invokeinterface 所使用的接口方法表（interface method table，itable）</li></ul><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕</p><p>虚方法表的执行过程：</p><ul><li>对于静态绑定的方法调用而言，实际引用将指向具体的目标方法</li><li>对于动态绑定的方法调用而言，实际引用则是方法表的索引值，也就是方法的间接地址。Java 虚拟机获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法内存偏移量（指针）</li></ul><p>为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表。每个类中都有一个虚方法表，本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法</p><p>方法表满足以下的特质：</p><ul><li>其一，子类方法表中包含父类方法表中的<strong>所有方法</strong>，并且在方法表中的索引值与父类方法表种的索引值相同</li><li>其二，<strong>非重写的方法指向父类的方法表项，与父类共享一个方法表项，重写的方法指向本身自己的实现</strong>。所以这就是为什么多态情况下可以访问父类的方法。</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表.png" style="zoom: 80%;" /><p>Passenger 类的方法表包括两个方法，分别对应 0 号和 1 号。方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致，为了保持简洁，这里不考虑 Object 类中的其他方法。</p><p>虚方法表对性能的影响：</p><ul><li>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者、读取调用者的动态类型、读取该类型的方法表、读取方法表中某个索引值所对应的目标方法，但是相对于创建并初始化 Java 栈帧这操作的开销可以忽略不计</li><li>上述优化的效果看上去不错，但实际上<strong>仅存在于解释执行</strong>中，或者即时编译代码的最坏情况。因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a boy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a girl&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%E6%8C%87%E5%90%91.png"></p><p>参考文档：<a href="https://www.cnblogs.com/kaleidoscope/p/9790766.html">https://www.cnblogs.com/kaleidoscope/p/9790766.html</a></p><hr><h5 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h5><p>内联缓存：是一种加快动态绑定的优化技术，能够缓存虚方法调用中<strong>调用者的动态类型以及该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，便会直接调用该类型所对应的目标方法；反之内联缓存则会退化至使用基于方法表的动态绑定</p><p>多态的三个术语：</p><ul><li>单态 (monomorphic)：指的是仅有一种状态的情况</li><li>多态 (polymorphic)：指的是有限数量种状态的情况，二态（bimorphic）是多态的其中一种</li><li>超多态 (megamorphic)：指的是更多种状态的情况，通常用一个具体数值来区分多态和超多态，在这个数值之下，称之为多态，否则称之为超多态</li></ul><p>对于内联缓存来说，有对应的单态内联缓存、多态内联缓存：</p><ul><li>单态内联缓存：只缓存了一种动态类型以及所对应的目标方法，实现简单，比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</li><li>多态内联缓存：缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法</li></ul><p>为了节省内存空间，<strong>Java 虚拟机只采用单态内联缓存</strong>，没有命中的处理方法：</p><ul><li>替换单态内联缓存中的纪录，类似于 CPU 中的数据缓存，对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存</li><li>劣化为超多态状态，这也是 Java 虚拟机的具体实现方式，这种状态实际上放弃了优化的机会，将直接访问方法表来动态绑定目标方法，但是与替换内联缓存纪录相比节省了写缓存的额外开销</li></ul><p>虽然内联缓存附带内联二字，但是并没有内联目标方法</p><p>参考文章：<a href="https://time.geekbang.org/column/intro/100010301">https://time.geekbang.org/column/intro/100010301</a></p><hr><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>语法糖：指 Java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Candy1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;</span></span><br><span class="line">        &lt;init&gt;<span class="string">&quot;:()V</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="拆装箱"><a href="#拆装箱" class="headerlink" title="拆装箱"></a>拆装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br></pre></td></tr></table></figure><p>JDK5 以后编译阶段自动转换成上述片段</p><hr><h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><p>泛型也是在 JDK 5 开始加入的特性，但 Java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都<strong>当做了 Object 类型</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br></pre></td></tr></table></figure><p>编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure><hr><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数 <code>String... args</code> 其实是 <code>String[] args</code> ， Java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]&#123;&#125;)</code> ，创建了一个空的数组，而不会传递 null 进去</p><hr><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>数组的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 数组赋初值的简化写法也是语法糖</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> e : array) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后为循环取数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> array[i];</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后转换为对迭代器的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> (Integer)iter.next();</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：foreach 循环写法，能够配合数组以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器</p><hr><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>switch 可以作用于字符串和枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>switch 配合 String 和枚举使用时，变量不能为 null</strong></p><p>会被编译器转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">99162322</span>: <span class="comment">// hello 的 hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">113318802</span>: <span class="comment">// world 的 hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较</li><li>hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突</li></ul><hr><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>switch 枚举的例子，原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Sex sex)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译转换后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个合成类（仅 jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">* 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">* 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span></span><br><span class="line"><span class="comment">* 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">    <span class="comment">// 数组大小即为枚举元素个数，里面存储 case 用来对比的数字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    map[Sex.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">    map[Sex.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Sex sex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[sex.ordinal()];</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>JDK 7 新增了枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译转换后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = <span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-w-r"><a href="#try-w-r" class="headerlink" title="try-w-r"></a>try-w-r</h4><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code>，格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象)&#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>( ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中资源对象需要实现 <strong>AutoCloseable</strong> 接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources可以不用写 finally 语句块，编译器会帮助生成关闭资源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>)) &#123;</span><br><span class="line">System.out.println(is);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换成：</p><p><code>addSuppressed(Throwable e)</code>：添加被压制异常，是为了防止异常信息的丢失（<strong>fianlly 中如果抛出了异常</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">    <span class="comment">// t 是我们代码出现的异常</span></span><br><span class="line">    t = e1;</span><br><span class="line">    <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 判断了资源不为空</span></span><br><span class="line">        <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">                    <span class="comment">// 如果 close 出现异常，作为被压制异常添加</span></span><br><span class="line">                    t.addSuppressed(e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span></span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Number <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 子类m方法的返回值是Integer是父类m方法返回值Number的子类</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子类，Java 编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 此方法才是真正重写了父类 public Number m() 方法</span></span><br><span class="line"><span class="keyword">public</span> synthetic bridge Number <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 public Integer m()</span></span><br><span class="line">    <span class="keyword">return</span> m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中桥接方法比较特殊，仅对 Java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突</p><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h5 id="无参优化"><a href="#无参优化" class="headerlink" title="无参优化"></a>无参优化</h5><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    Candy11$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="带参优化"><a href="#带参优化" class="headerlink" title="带参优化"></a>带参优化</h5><p>引用局部变量的匿名内部类，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok:&quot;</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> val$x;</span><br><span class="line">    Candy11$<span class="number">1</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="built_in">this</span>.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量在底层创建为内部类的成员变量，必须是 final 的原因：</p><ul><li><p>在 Java 中方法调用是值传递的，在匿名内部类中对变量的操作都是基于原变量的副本，不会影响到原变量的值，所以<strong>原变量的值的改变也无法同步到副本中</strong></p></li><li><p>外部变量为 final 是在编译期以强制手段确保用户不会在内部类中做修改原变量值的操作，也是<strong>防止外部操作修改了变量而内部类无法随之变化</strong>出现的影响</p><p>在创建 <code>Candy11$1 </code> 对象时，将 x 的值赋值给了 <code>Candy11$1</code> 对象的 val 属性，x 不应该再发生变化了，因为发生变化，this.val$x 属性没有机会再跟着变化</p></li></ul><hr><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Reflect1.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">            foo.invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 0 ~ 15 次调用的是 MethodAccessor 的实现类 <code>NativeMethodAccessorImpl.invoke0()</code>，本地方法执行速度慢；当调用到第 16 次时，会采用运行时生成的类 <code>sun.reflect.GeneratedMethodAccessor1</code> 代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// inflationThreshold 膨胀阈值，默认 15</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">        &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【调用本地方法实现】</span></span><br><span class="line">    <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有参数，那么抛非法参数异常</span></span><br><span class="line">    block4 : &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrobject == <span class="literal">null</span> || arrobject.length == <span class="number">0</span>) <span class="keyword">break</span> block4;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【可以看到，已经是直接调用方法】</span></span><br><span class="line">        Reflect1.foo();</span><br><span class="line">        <span class="comment">// 因为没有返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看 ReflectionFactory 源码可知：</p><ul><li>sun.reflect.noInflation 可以用来禁用膨胀，直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算</li><li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li></ul><hr><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>性能指标主要是吞吐量、响应时间、QPS、TPS 等、并发用户数等，而这些性能指标又依赖于系统服务器的资源，如 CPU、内存、磁盘 IO、网络 IO 等，对于这些指标数据的收集，通常可以根据Java本身的工具或指令进行查询</p><p>几个重要的指标：</p><ol><li>停顿时间（响应时间）：提交请求和返回该请求的响应之间使用的时间，比如垃圾回收中 STW 的时间</li><li>吞吐量：对单位时间内完成的工作量（请求）的量度（可以对比 GC 的性能指标）</li><li>并发数：同一时刻，对服务器有实际交互的请求数</li><li>QPS：Queries Per Second，每秒处理的查询量</li><li>TPS：Transactions Per Second，每秒产生的事务数</li><li>内存占用：Java 堆区所占的内存大小</li></ol><hr><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><p>对于一个系统要部署上线时，则一定会对 JVM 进行调整，不经过任何调整直接上线，容易出现线上系统频繁 FullGC 造成系统卡顿、CPU 使用频率过高、系统无反应等问题</p><ol><li><p>性能监控：通过运行日志、堆栈信息、线程快照等信息监控是否出现 GC 频繁、OOM、内存泄漏、死锁、响应时间过长等情况</p></li><li><p>性能分析：</p><ul><li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li></ul><ul><li><p>运用命令行工具、jstack、jmap、jinfo 等</p></li><li><p>dump 出堆文件，使用内存分析工具分析文件</p></li><li><p>使用阿里 Arthas、jconsole、JVisualVM 来<strong>实时查看 JVM 状态</strong></p></li><li><p>jstack 查看堆栈信息</p></li></ul></li><li><p>性能调优：</p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li></ul><ul><li><p>优化代码，控制内存使用</p></li><li><p>增加机器，分散节点压力</p></li><li><p>合理设置线程池线程数量</p></li><li><p>使用中间件提高程序效率，比如缓存、消息队列等</p></li></ul></li></ol><hr><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>对于 JVM 调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p><ul><li><p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure></li><li><p>设置年轻代中 Eden 区和两个 Survivor 区的大小比例。该值如果不设置，则默认比例为 8:1:1。Java 官方通过增大 Eden 区的大小，来减少 YGC 发生的次数，虽然次数减少了，但 Eden 区满的时候，由于占用的空间较大，导致释放缓慢，此时 STW 的时间较长，因此需要按照程序情况去调优</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio</span><br></pre></td></tr></table></figure></li><li><p>年轻代和老年代默认比例为 1:2，可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure></li><li><p>线程堆栈的设置：<strong>每个线程默认会开启 1M 的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般 256K 就够用，通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure></li><li><p>一般一天超过一次 FullGC 就是有问题，首先通过工具查看是否出现内存泄露，如果出现内存泄露则调整代码，没有的话则调整 JVM 参数</p></li><li><p>系统 CPU 持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决</p></li><li><p>如果数据查询性能很低下的话，如果系统并发量并没有多少，则应更加关注数据库的相关问题</p></li><li><p>如果服务器配置还不错，JDK8 开始尽量使用 G1 或者新生代和老年代组合使用并行垃圾回收器</p></li></ul><hr><h3 id="命令行篇"><a href="#命令行篇" class="headerlink" title="命令行篇"></a>命令行篇</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps（Java Process Statu）：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的</p><p>使用语法：<code>jps [options] [hostid]</code></p><p>options 参数：</p><ul><li><p>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id，不显示主类的名称等</p></li><li><p>-l：输出应用程序主类的全类名或如果进程执行的是 jar 包，则输出 jar 完整路径</p></li><li><p>-m：输出虚拟机进程启动时传递给主类 main()的参数</p></li><li><p>-v：列出虚拟机进程启动时的JVM参数，比如 -Xms20m -Xmx50m是启动程序指定的 jvm 参数</p></li></ul><p>ostid 参数：RMI注册表中注册的主机名，如果想要远程监控主机上的 java 程序，需要安装 jstatd</p><hr><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat（JVM Statistics Monitoring Tool）：用于监视 JVM 各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有 GUI 的图形界面，只提供了纯文本控制台环境的服务器上，它是运行期定位虚拟机性能问题的首选工具，常用于检测垃圾回收问题以及内存泄漏问题</p><p>使用语法：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><p>查看命令相关参数：jstat-h 或 jstat-help</p><ul><li><p>vmid 是进程 id 号</p></li><li><p>option 参数：</p><p>类装载相关：</p><ul><li>-class：显示 ClassLoader 的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p>垃圾回收相关：</p><ul><li><p>-gc：显示与GC相关的堆信息，年轻代、老年代、永久代等的容量、已用空间、GC时间合计等信息</p></li><li><p>-gccapacity：显示内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</p></li><li><p>-gcutil：显示内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</p></li><li><p>-gccause：与 -gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因</p></li><li><p>-gcnew：显示新生代 GC 状况</p></li><li><p>-gcnewcapacity：显示内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-geold：显示老年代 GC 状况</p></li><li><p>-gcoldcapacity：显示内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-gcpermcapacity：显示永久代使用到的最大、最小空间</p></li></ul><p>JIT 相关：</p><ul><li><p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被 JIT 编译的方法</p></li></ul></li></ul><hr><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo（Configuration Info for Java）：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数，开发人员可以很方便地找到 Java 虚拟机参数的当前值</p><p>使用语法：<code>jinfo [options] pid</code></p><p>options 参数：</p><ul><li>no option：输出全部的参数和系统属性</li><li>-flag name：输出对应名称的参数</li><li>-flag [+-]name：开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</li><li>-flag name&#x3D;value：设定对应名称的参数</li><li>-flags：输出全部的参数</li><li>-sysprops：输出系统属性</li></ul><hr><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap（JVM Memory Map）：获取 dump 文件，还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等</p><p>使用语法：</p><ul><li><p><code>jmap [options] &lt;pid&gt;</code></p></li><li><p><code>jmap [options] &lt;executable &lt;core&gt;</code></p></li><li><p><code>jmap [options] [server_id@] &lt;remote server IP or hostname&gt;</code></p></li></ul><p>option 参数：</p><ul><li>-dump：生成 dump 文件（Java堆转储快照，二进制文件），-dump:live 只保存堆中的存活对象</li><li>-heap：输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</li><li>-histo：输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</li><li>-J <flag>：传递参数给 jmap 启动的 jvm</li><li>-finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux&#x2F;solaris 平台有效</li><li>-permstat：以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux&#x2F;solaris 平台有效</li><li>-F：当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux&#x2F;solaris 平台有效</li></ul><hr><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>jhat（JVM Heap Analysis Tool）：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于<strong>分析 jmap 生成的 heap dump 文件</strong>（堆转储快照），jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果</p><p>使用语法：<code>jhat &lt;options&gt; &lt;dumpfile&gt;</code></p><p>options 参数：</p><ul><li>-stack false｜true：关闭｜打开对象分配调用栈跟踪</li><li>-refs false｜true：关闭｜打开对象引用跟踪</li><li>-port port-number：设置 jhat HTTP Server 的端口号，默认 7000</li><li>-exclude exclude-file：执行对象查询时需要排除的数据成员</li><li>-baseline exclude-file：指定一个基准堆转储</li><li>-debug int：设置 debug 级别</li><li>-version：启动后显示版本信息就退出</li><li>-J <flag>：传入启动参数，比如 -J-Xmx512m</li></ul><p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替</p><hr><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪），线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p><p>线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题，用 jstack 显示各个线程调用的堆栈情况</p><p>使用语法：<code>jstack [options] pid</code></p><p>options 参数：</p><ul><li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l：除堆栈外，显示关于锁的附加信息</li><li>-m：如果调用本地方法的话，可以显示 C&#x2F;C++ 的堆栈</li></ul><p>在 thread dump 中的几种状态：</p><ul><li><p>死锁：Deadlock</p></li><li><p>等待资源：Waiting on condition</p></li><li><p>等待获取监视器：Waiting on monitor entry</p></li><li><p>阻塞：Blocked</p></li><li><p>执行中：Runnable</p></li><li><p>暂停：Suspended</p></li><li><p>对象等待中：Object.wait() 或 TIMED＿WAITING</p></li><li><p>停止：Parked</p></li></ul><hr><h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p>jcmd 是一个多功能命令行工具，可以用来实现前面除了 jstat 之外所有命令的功能，比如 dump、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等</p><p>jcmd -l：列出所有的JVM进程</p><p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p><ul><li>Thread.print：可以替换 jstack 指令</li></ul><ul><li><p>GC.class_histogram：可以替换 jmap 中的 -histo 操作</p></li><li><p>GC.heap_dump：可以替换 jmap 中的 -dump 操作</p></li><li><p>GC.run：可以查看GC的执行情况</p></li><li><p>VM.uptime：可以查看程序的总执行时间，可以替换 jstat 指令中的 -t  操作</p></li><li><p>VM.system_properties：可以替换 jinfo -sysprops 进程 id</p></li><li><p>VM.flags：可以获取 JVM 的配置参数信息</p></li></ul><hr><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd 是一个 RMI 服务端程序，相当于代理服务器，建立本地计算机与远程监控工具的通信，jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机</p><p>远程主机信息收集，前面的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat），为了启用远程监控，则需要配合使用 jstatd 工具。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-jstatd%E5%9B%BE%E8%A7%A3.png"></p><hr><h3 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h3><p>工具的使用此处不再多言，推荐一个写的非常好的文章，JVM 调优部分的笔记全部参考此文章编写</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=304">https://www.bilibili.com/video/BV1PJ411n7xZ?p=304</a></p><p>文章链接：<a href="https://www.yuque.com/u21195183/jvm/lv1zot">https://www.yuque.com/u21195183/jvm/lv1zot</a></p><hr><h3 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h3><h4 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h4><p>添加 JVM 参数选项：进入 Run&#x2F;Debug Configurations → VM options 设置参数</p><ul><li><p>标准参数选项：<code>java [-options] class [args...]</code> 或 <code>java [-options] -jar jarfile [args...]</code></p><p>命令：<code>-? -help</code> 可以输出此命令的相关选项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Seazean&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_221&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br><span class="line"><span class="comment"># mixed mode 字样，代表当前系统使用的是混合模式</span></span><br></pre></td></tr></table></figure><p>Hotspot JVM 有两种模式，分别是 Server 和 Client，分别通过 -server 和- client 设置模式：</p><ul><li><p>32 位系统上，默认使用 Client 类型的 JVM，要使用 Server 模式，机器配置至少有 2 个以上的内核和 2G 以上的物理内存，Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</p></li><li><p>64 位系统上，只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</p></li></ul></li><li><p>-X 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed           混合模式执行 (默认)</span><br><span class="line">-Xint             仅解释模式执行</span><br><span class="line">-Xbootclasspath:&lt;用;分隔的目录和zip/jar文件&gt;设置搜索路径以引导类和资源</span><br><span class="line">-Xbootclasspath/a:&lt;用;分隔的目录和zip/jar文件&gt;附加在引导类路径末尾</span><br><span class="line">-Xbootclasspath/p:&lt;用;分隔的目录和zip/jar文件&gt;置于引导类路径之前</span><br><span class="line">-Xdiag            显示附加诊断消息</span><br><span class="line">-Xnoclassgc       禁用类垃圾收集</span><br><span class="line">-Xincgc           启用增量垃圾收集</span><br><span class="line">-Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">-Xbatch           禁用后台编译</span><br><span class="line">-Xprof            输出 cpu 配置文件数据</span><br><span class="line">-Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">-Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">-Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">-Xshare:off       不尝试使用共享类数据</span><br><span class="line">-Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">-Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">-XshowSettings    显示所有设置并继续</span><br><span class="line">-XshowSettings:all显示所有设置并继续</span><br><span class="line">-XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">-XshowSettings:properties显示所有属性设置并继续</span><br><span class="line">-XshowSettings:locale显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure></li><li><p>-XX 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Boolean类型格式</span></span><br><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br><span class="line"><span class="comment">#非Boolean类型格式</span></span><br><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></table></figure></li></ul><p>程序运行中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"><span class="comment"># 设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="打印参数"><a href="#打印参数" class="headerlink" title="打印参数"></a>打印参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure><hr><h4 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M（默认为物理内存的1/64）</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M（默认为物理内存的1/4）</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></table></figure><p>说明：参数前面是<code>+</code>号说明是开启，如果是<code>- </code>号说明是关闭</p><hr><h4 id="OOM参数"><a href="#OOM参数" class="headerlink" title="OOM参数"></a>OOM参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure><hr><h4 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintTenuringDistribution打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure><hr><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k] 指定代码缓存大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br></pre></td></tr></table></figure><hr><h4 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h4><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，允许本地或远程监控和管理运行的 Java 虚拟机。ManagementFactory 类较为常用，Runtime 类可获取内存、CPU 核数等相关的数据，通过使用这些方法，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">memorymbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====通过java来获取相关系统状态====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><h4 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h4><p>HotSpot VM 的 GC 按照回收区域分为两类：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为： </p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代（Eden&#x2F;S0、S1）的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集，只有 CMS GC 会有单独收集老年代的行为</li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，只有 G1 GC 会有这种行为 </p></li><li><p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p></li></ul><p>Minor GC&#x2F;Young GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>Full GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><hr><h4 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h4><p>通过日志看垃圾收集器：</p><ul><li><p>Serial 收集器：新生代显示 <code>[DefNew</code>，即 <code>Default New Generation</code></p></li><li><p>ParNew 收集器：新生代显示 <code>[ParNew</code>，即 <code>Parallel New Generation</code></p></li><li><p>Parallel Scavenge 收集器：新生代显示 <code>[PSYoungGen</code>，JDK1.7 使用的 PSYoungGen </p></li><li><p>Parallel Old 收集器：老年代显示 <code>[ParoldGen</code></p></li><li><p>G1 收集器：显示 <code>garbage-first heap</code></p></li></ul><p>通过日志看 GC 原因：</p><ul><li><p>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</p></li><li><p>Metadata GCThreshold：Metaspace 区不足</p></li><li><p>FErgonomics：JVM 自适应调整导致的 GC</p></li><li><p>System：调用了 System.gc() 方法</p></li></ul><p>通过日志看 GC 前后情况：GC 前内存占用 → GC 后内存占用（该区域内存总大小）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K)] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure><ul><li><p>中括号内：GC 回收前年轻代堆大小 → 回收后大小（年轻代堆总大小） </p></li><li><p>括号外：GC 回收前年轻代和老年代大小 → 回收后大小（年轻代和老年代总大小）</p></li></ul><ul><li>Minor GC 堆内存总容量 &#x3D; 9&#x2F;10 年轻代 + 老年代，Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系：Eden:S0:S1&#x3D;8:1:1</li></ul><p>通过日志看 GC 时间：GC 日志中有三个时间 user、sys、real</p><ul><li><p>user：进程执行用户态代码（核心之外）所使用的时间，这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内，在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</p></li><li><p>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</p></li><li><p>real：程序从开始到结束所用的时钟时间，这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成），对于并行 GC，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</p></li></ul><p>由于多核的原因，一般的 GC 事件中，real time 小于 sys time＋user time，因为是多个线程并发的去做 GC。如果 real＞sys＋user 的话，则说明 IO 负载非常重或 CPU 不够用</p><hr><h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的</p><ul><li>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></li></ul><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>，还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等），当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</p><ul><li><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p></li><li><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p></li></ul><p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/ukmb3k">https://www.yuque.com/u21195183/jvm/ukmb3k</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM概述&quot;&gt;&lt;a href=&quot;#JVM概述&quot; class=&quot;headerlink&quot; title=&quot;JVM概述&quot;&gt;&lt;/a&gt;JVM概述&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/16/hello-world/"/>
    <id>http://example.com/2022/08/16/hello-world/</id>
    <published>2022-08-15T16:58:32.790Z</published>
    <updated>2022-08-15T16:58:32.790Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
