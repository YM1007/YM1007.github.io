<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeMuのBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-18T12:13:45.644Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YeMu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信扫码登录</title>
    <link href="http://example.com/2022/08/18/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2022/08/18/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</id>
    <published>2022-08-18T11:08:11.391Z</published>
    <updated>2022-08-18T12:13:45.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信扫码登录"><a href="#微信扫码登录" class="headerlink" title="微信扫码登录"></a>微信扫码登录</h1><h2 id="登录业务介绍"><a href="#登录业务介绍" class="headerlink" title="登录业务介绍"></a>登录业务介绍</h2><p>  <em>注：代码截取谷粒学院，开发所使用的id为尚硅谷的</em></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  1.前往开发者社区<a href="https://open.weixin.qq.com/">https://open.weixin.qq.com</a><br>  2.邮箱激活<br>  3.完善开发者资料<br>  4.开发者资质认证<br>    <code>准备营业执照 -&gt; 1-2工作日审批-&gt; 300元</code><br>  5.创建网站应用</p><blockquote><p>参考文档：<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=e547653f995d8f402704d5cb2945177dc8aa4e7e&amp;lang=zh_CN">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=e547653f995d8f402704d5cb2945177dc8aa4e7e&amp;lang=zh_CN</a></p></blockquote><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  1.添加配置文件相关信息<br>  2.添加依赖<br>  3.创建Httpclient工具类<br>  4.创建常量类<br>  5.创建controller控制层<br>       1） 生成微信二维码<br>           a. baseUrl：微信开放平台授权baseUrl，%s相当于？代表占位符<br>           b. 对redirect_url进行URLEncoder编码<br>           c. 设置a中的%s所占位置的值<br>           d. 重定向到微信地址里面<br>      2）. 获取用户信息，添加数据<br>           a.  获取code值，临时票据，类似于验证码<br>           b.  拿着code请求 微信固定的地址，得到两个值 accsess_token 和 openid<br>           c.  拼接三个参数 ：id  秘钥 和 code值<br>           d.  从accessTokenInfo字符串获取出来两个值 accsess_token 和 openid<br>           e.  把accessTokenInfo字符串转换map集合，根据map里面key获取对应值<br>           f.  使用json转换工具 Gson<br>           g.  判断数据库中是否有扫描人的信息，如果没有就添加进数据库。<br>           h.  使用jwt根据member对象生成token字符串<br>           i.  返回首页通过路径传递token<br>  6.创建service服务层</p><hr><h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><p>application.properties添加相关配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微信开放平台 appid</span></span><br><span class="line"><span class="attr">wx.open.app_id</span>=<span class="string">你的appid</span></span><br><span class="line"><span class="comment"># 微信开放平台 appsecret</span></span><br><span class="line"><span class="attr">wx.open.app_secret</span>=<span class="string">你的appsecret</span></span><br><span class="line"><span class="comment"># 微信开放平台 重定向url</span></span><br><span class="line"><span class="attr">wx.open.redirect_url</span>=<span class="string">http://你的服务器名称/api/ucenter/wx/callback</span></span><br></pre></td></tr></table></figure><hr><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在pom文件中添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--httpclient--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--commons-io--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--gson--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="创建httpclient工具类"><a href="#创建httpclient工具类" class="headerlink" title="创建httpclient工具类"></a>创建httpclient工具类</h4><p>Utils下创建httpclient工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yemu.eduService.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.Consts;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig.Builder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ConnectTimeoutException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.SSLConnectionSocketFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.SSLContextBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.TrustStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.X509HostnameVerifier;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.ContentType;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.conn.PoolingHttpClientConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLException;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSession;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.security.GeneralSecurityException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  依赖的jar包有：commons-lang-2.6.jar、httpclient-4.3.2.jar、httpcore-4.3.1.jar、commons-io-2.4.jar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientUtils</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> connTimeout=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> readTimeout=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String charset=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line">cm.setMaxTotal(<span class="number">128</span>);</span><br><span class="line">cm.setDefaultMaxPerRoute(<span class="number">128</span>);</span><br><span class="line">client = HttpClients.custom().setConnectionManager(cm).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postParameters</span><span class="params">(String url, String parameterStr)</span> <span class="keyword">throws</span> ConnectTimeoutException, SocketTimeoutException, Exception&#123;</span><br><span class="line"><span class="keyword">return</span> post(url,parameterStr,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,charset,connTimeout,readTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postParameters</span><span class="params">(String url, String parameterStr,String charset, Integer connTimeout, Integer readTimeout)</span> <span class="keyword">throws</span> ConnectTimeoutException, SocketTimeoutException, Exception&#123;</span><br><span class="line"><span class="keyword">return</span> post(url,parameterStr,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,charset,connTimeout,readTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postParameters</span><span class="params">(String url, Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> ConnectTimeoutException,</span><br><span class="line">SocketTimeoutException, Exception &#123;</span><br><span class="line"><span class="keyword">return</span> postForm(url, params, <span class="literal">null</span>, connTimeout, readTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postParameters</span><span class="params">(String url, Map&lt;String, String&gt; params, Integer connTimeout,Integer readTimeout)</span> <span class="keyword">throws</span> ConnectTimeoutException,</span><br><span class="line">SocketTimeoutException, Exception &#123;</span><br><span class="line"><span class="keyword">return</span> postForm(url, params, <span class="literal">null</span>, connTimeout, readTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">(String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> get(url, charset, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">(String url, String charset)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> get(url, charset, connTimeout, readTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一个 Post 请求, 使用指定的字符集编码.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> body RequestBody</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mimeType 例如 application/xml &quot;application/x-www-form-urlencoded&quot; a=1&amp;b=2&amp;c=3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset 编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connTimeout 建立链接超时时间,毫秒.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readTimeout 响应超时时间,毫秒.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ResponseBody, 使用指定的字符集编码.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ConnectTimeoutException 建立链接超时异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SocketTimeoutException  响应超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">post</span><span class="params">(String url, String body, String mimeType,String charset, Integer connTimeout, Integer readTimeout)</span></span><br><span class="line"><span class="keyword">throws</span> ConnectTimeoutException, SocketTimeoutException, Exception &#123;</span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(body)) &#123;</span><br><span class="line"><span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(body, ContentType.create(mimeType, charset));</span><br><span class="line">post.setEntity(entity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">customReqConf</span> <span class="operator">=</span> RequestConfig.custom();</span><br><span class="line"><span class="keyword">if</span> (connTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setConnectTimeout(connTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (readTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setSocketTimeout(readTimeout);</span><br><span class="line">&#125;</span><br><span class="line">post.setConfig(customReqConf.build());</span><br><span class="line"></span><br><span class="line">HttpResponse res;</span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// 执行 Https 请求.</span></span><br><span class="line">client = createSSLInsecureClient();</span><br><span class="line">res = client.execute(post);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 执行 Http 请求.</span></span><br><span class="line">client = HttpClientUtils.client;</span><br><span class="line">res = client.execute(post);</span><br><span class="line">&#125;</span><br><span class="line">result = IOUtils.toString(res.getEntity().getContent(), charset);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">post.releaseConnection();</span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>) &amp;&amp; client != <span class="literal">null</span>&amp;&amp; client <span class="keyword">instanceof</span> CloseableHttpClient) &#123;</span><br><span class="line">((CloseableHttpClient) client).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交form表单</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ConnectTimeoutException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SocketTimeoutException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postForm</span><span class="params">(String url, Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers, Integer connTimeout,Integer readTimeout)</span> <span class="keyword">throws</span> ConnectTimeoutException,</span><br><span class="line">SocketTimeoutException, Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (params != <span class="literal">null</span> &amp;&amp; !params.isEmpty()) &#123;</span><br><span class="line">List&lt;NameValuePair&gt; formParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NameValuePair&gt;();</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet = params.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">formParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UrlEncodedFormEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(formParams, Consts.UTF_8);</span><br><span class="line">post.setEntity(entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (headers != <span class="literal">null</span> &amp;&amp; !headers.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">post.addHeader(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">customReqConf</span> <span class="operator">=</span> RequestConfig.custom();</span><br><span class="line"><span class="keyword">if</span> (connTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setConnectTimeout(connTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (readTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setSocketTimeout(readTimeout);</span><br><span class="line">&#125;</span><br><span class="line">post.setConfig(customReqConf.build());</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// 执行 Https 请求.</span></span><br><span class="line">client = createSSLInsecureClient();</span><br><span class="line">res = client.execute(post);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 执行 Http 请求.</span></span><br><span class="line">client = HttpClientUtils.client;</span><br><span class="line">res = client.execute(post);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> IOUtils.toString(res.getEntity().getContent(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">post.releaseConnection();</span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>) &amp;&amp; client != <span class="literal">null</span></span><br><span class="line">&amp;&amp; client <span class="keyword">instanceof</span> CloseableHttpClient) &#123;</span><br><span class="line">((CloseableHttpClient) client).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一个 GET 请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connTimeout  建立链接超时时间,毫秒.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readTimeout  响应超时时间,毫秒.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ConnectTimeoutException   建立链接超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SocketTimeoutException   响应超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">(String url, String charset, Integer connTimeout,Integer readTimeout)</span></span><br><span class="line"><span class="keyword">throws</span> ConnectTimeoutException,SocketTimeoutException, Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">customReqConf</span> <span class="operator">=</span> RequestConfig.custom();</span><br><span class="line"><span class="keyword">if</span> (connTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setConnectTimeout(connTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (readTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">customReqConf.setSocketTimeout(readTimeout);</span><br><span class="line">&#125;</span><br><span class="line">get.setConfig(customReqConf.build());</span><br><span class="line"></span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// 执行 Https 请求.</span></span><br><span class="line">client = createSSLInsecureClient();</span><br><span class="line">res = client.execute(get);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 执行 Http 请求.</span></span><br><span class="line">client = HttpClientUtils.client;</span><br><span class="line">res = client.execute(get);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = IOUtils.toString(res.getEntity().getContent(), charset);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">get.releaseConnection();</span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;https&quot;</span>) &amp;&amp; client != <span class="literal">null</span> &amp;&amp; client <span class="keyword">instanceof</span> CloseableHttpClient) &#123;</span><br><span class="line">((CloseableHttpClient) client).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 response 里获取 charset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ressponse</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getCharsetFromResponse</span><span class="params">(HttpResponse ressponse)</span> &#123;</span><br><span class="line"><span class="comment">// Content-Type:text/html; charset=GBK</span></span><br><span class="line"><span class="keyword">if</span> (ressponse.getEntity() != <span class="literal">null</span>  &amp;&amp; ressponse.getEntity().getContentType() != <span class="literal">null</span> &amp;&amp; ressponse.getEntity().getContentType().getValue() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> ressponse.getEntity().getContentType().getValue();</span><br><span class="line"><span class="keyword">if</span> (contentType.contains(<span class="string">&quot;charset=&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> contentType.substring(contentType.indexOf(<span class="string">&quot;charset=&quot;</span>) + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 SSL连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> GeneralSecurityException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient <span class="title function_">createSSLInsecureClient</span><span class="params">()</span> <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLContextBuilder</span>().loadTrustMaterial(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TrustStrategy</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrusted</span><span class="params">(X509Certificate[] chain,String authType)</span> <span class="keyword">throws</span> CertificateException &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build();</span><br><span class="line"></span><br><span class="line"><span class="type">SSLConnectionSocketFactory</span> <span class="variable">sslsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLConnectionSocketFactory</span>(sslContext, <span class="keyword">new</span> <span class="title class_">X509HostnameVerifier</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String arg0, SSLSession arg1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verify</span><span class="params">(String host, SSLSocket ssl)</span></span><br><span class="line"><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verify</span><span class="params">(String host, X509Certificate cert)</span></span><br><span class="line"><span class="keyword">throws</span> SSLException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verify</span><span class="params">(String host, String[] cns,</span></span><br><span class="line"><span class="params">   String[] subjectAlts)</span> <span class="keyword">throws</span> SSLException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String str= post(<span class="string">&quot;https://localhost:443/ssl/test.shtml&quot;</span>,<span class="string">&quot;name=12&amp;page=34&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//String str= get(&quot;https://localhost:443/ssl/test.shtml?name=12&amp;page=34&quot;,&quot;GBK&quot;);</span></span><br><span class="line">            <span class="comment">/*Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();</span></span><br><span class="line"><span class="comment">            map.put(&quot;name&quot;, &quot;111&quot;);</span></span><br><span class="line"><span class="comment">            map.put(&quot;page&quot;, &quot;222&quot;);</span></span><br><span class="line"><span class="comment">            String str= postForm(&quot;https://localhost:443/ssl/test.shtml&quot;,map,null, 10000, 10000);*/</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="创建常量类"><a href="#创建常量类" class="headerlink" title="创建常量类"></a>创建常量类</h4><p>创建util包，创建ConstantPropertiesUtil.java常量类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantPropertiesUtil</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.open.app_id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.open.app_secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appSecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redirectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WX_OPEN_APP_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WX_OPEN_APP_SECRET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WX_OPEN_REDIRECT_URL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        WX_OPEN_APP_ID = appId;</span><br><span class="line">        WX_OPEN_APP_SECRET = appSecret;</span><br><span class="line">        WX_OPEN_REDIRECT_URL = redirectUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="创建controller"><a href="#创建controller" class="headerlink" title="创建controller"></a>创建controller</h4><p>创建控制层编写代码<br><em>微信扫码登录是在访问路径中添加token，然后前端从路径中获取token进行用户信息查询</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.yemu.commonUtils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.yemu.eduService.entity.UcenterMember;</span><br><span class="line"><span class="keyword">import</span> com.yemu.eduService.service.UcenterMemberService;</span><br><span class="line"><span class="keyword">import</span> com.yemu.eduService.utils.ConstantPropertiesUtil;</span><br><span class="line"><span class="keyword">import</span> com.yemu.eduService.utils.HttpClientUtils;</span><br><span class="line"><span class="keyword">import</span> com.yemu.servicebase.exceptionhandler.GuliException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.misc.ConstructorUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@Controller</span>  <span class="comment">//只是请求地址，不需要返回数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/ucenter/wx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxApiController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_URL</span> <span class="operator">=</span> <span class="string">&quot;https://open.weixin.qq.com/connect/qrconnect&quot;</span> +</span><br><span class="line">            <span class="string">&quot;?appid=%s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;redirect_uri=%s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;response_type=code&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;scope=snsapi_login&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;state=%s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;#wechat_redirect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UcenterMemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 生成微信扫描二维码</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWxCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//固定地址，后面拼接参数</span></span><br><span class="line"><span class="comment">//        String url = &quot;https://open.weixin.qq.com/&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;connect/qrconnect?appid=&quot;+ ConstantWxUtils.WX_OPEN_APP_ID+&quot;&amp;response_type=code&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//微信开放平台授权baseUrl  %s相当于?代表占位符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> BASE_URL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对redirect_url进行URLEncoder编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> ConstantPropertiesUtil.WX_OPEN_REDIRECT_URL;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redirectUrl = URLEncoder.encode(redirectUrl, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置%s里面值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(</span><br><span class="line">                baseUrl,</span><br><span class="line">                ConstantPropertiesUtil.WX_OPEN_APP_ID,</span><br><span class="line">                redirectUrl,</span><br><span class="line">                <span class="string">&quot;atguigu&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向到请求微信地址里面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 获取扫描人信息，添加数据</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;callback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">callback</span><span class="params">(String code, String state)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 获取code值，临时票据，类似于验证码</span></span><br><span class="line">            <span class="comment">//2 拿着code请求 微信固定的地址，得到两个值 accsess_token 和 openid</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">baseAccessTokenUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;?appid=%s&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&amp;secret=%s&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&amp;code=%s&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line">            <span class="comment">//拼接三个参数 ：id  秘钥 和 code值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">accessTokenUrl</span> <span class="operator">=</span> String.format(</span><br><span class="line">                    baseAccessTokenUrl,</span><br><span class="line">                    ConstantPropertiesUtil.WX_OPEN_APP_ID,</span><br><span class="line">                    ConstantPropertiesUtil.WX_OPEN_APP_SECRET,</span><br><span class="line">                    code</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//请求这个拼接好的地址，得到返回两个值 accsess_token 和 openid</span></span><br><span class="line">            <span class="comment">//使用httpclient发送请求，得到返回结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">accessTokenInfo</span> <span class="operator">=</span> HttpClientUtils.get(accessTokenUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从accessTokenInfo字符串获取出来两个值 accsess_token 和 openid</span></span><br><span class="line">            <span class="comment">//把accessTokenInfo字符串转换map集合，根据map里面key获取对应值</span></span><br><span class="line">            <span class="comment">//使用json转换工具 Gson</span></span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">            <span class="type">HashMap</span> <span class="variable">mapAccessToken</span> <span class="operator">=</span> gson.fromJson(accessTokenInfo, HashMap.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> (String) mapAccessToken.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> (String) mapAccessToken.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把扫描人信息添加数据库里面</span></span><br><span class="line">            <span class="comment">//判断数据表里面是否存在相同微信信息，根据openid判断</span></span><br><span class="line">            <span class="type">UcenterMember</span> <span class="variable">member</span> <span class="operator">=</span> memberService.getOpenIdMember(openid);</span><br><span class="line">            <span class="keyword">if</span> (member == <span class="literal">null</span>) &#123;<span class="comment">//memeber是空，表没有相同微信数据，进行添加</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//3 拿着得到accsess_token 和 openid，再去请求微信提供固定的地址，获取到扫描人信息</span></span><br><span class="line">                <span class="comment">//访问微信的资源服务器，获取用户信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">baseUserInfoUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;?access_token=%s&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&amp;openid=%s&quot;</span>;</span><br><span class="line">                <span class="comment">//拼接两个参数</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userInfoUrl</span> <span class="operator">=</span> String.format(</span><br><span class="line">                        baseUserInfoUrl,</span><br><span class="line">                        access_token,</span><br><span class="line">                        openid</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//发送请求</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> HttpClientUtils.get(userInfoUrl);</span><br><span class="line">                <span class="comment">//获取返回userinfo字符串扫描人信息</span></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">userInfoMap</span> <span class="operator">=</span> gson.fromJson(userInfo, HashMap.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">nickname</span> <span class="operator">=</span> (String) userInfoMap.get(<span class="string">&quot;nickname&quot;</span>);<span class="comment">//昵称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">headimgurl</span> <span class="operator">=</span> (String) userInfoMap.get(<span class="string">&quot;headimgurl&quot;</span>);<span class="comment">//头像</span></span><br><span class="line">                    member = <span class="keyword">new</span> <span class="title class_">UcenterMember</span>();</span><br><span class="line">                    member.setOpenid(openid);</span><br><span class="line">                    member.setNickname(nickname);</span><br><span class="line">                    member.setAvatar(headimgurl);</span><br><span class="line">                    memberService.save(member);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用jwt根据member对象生成token字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JwtUtils.getJwtToken(member.getId(), member.getNickname());</span><br><span class="line">            <span class="comment">//最后：返回首页面，通过路径传递token字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:http://localhost:3000?token=&quot;</span> + jwtToken;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="创建Service层"><a href="#创建Service层" class="headerlink" title="创建Service层"></a>创建Service层</h4><p>创建service接口和服务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UcenterMember <span class="title function_">getOpenIdMember</span><span class="params">(String openid)</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UcenterMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;openid&quot;</span>, openid);</span><br><span class="line">    <span class="type">UcenterMember</span> <span class="variable">member</span> <span class="operator">=</span> baseMapper.selectOne(wrapper);</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信扫码登录&quot;&gt;&lt;a href=&quot;#微信扫码登录&quot; class=&quot;headerlink&quot; title=&quot;微信扫码登录&quot;&gt;&lt;/a&gt;微信扫码登录&lt;/h1&gt;&lt;h2 id=&quot;登录业务介绍&quot;&gt;&lt;a href=&quot;#登录业务介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术点总结" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    <category term="单点登录" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
    
    <category term="技术点总结" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://example.com/2022/08/18/SpringBoot/"/>
    <id>http://example.com/2022/08/18/SpringBoot/</id>
    <published>2022-08-17T16:06:11.302Z</published>
    <updated>2022-08-17T16:06:43.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h3><p>SpringBoot 提供了一种快速使用 Spring 的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率</p><p>SpringBoot 功能：</p><ul><li><p>自动配置，自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素选择使用哪个配置，该过程是SpringBoot 自动完成的</p></li><li><p>起步依赖，起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能</p></li><li><p>辅助功能，提供了一些大型项目中常见的非功能性特性，如内嵌 web 服务器、安全、指标，健康检测、外部配置等</p></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p><hr><h3 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h3><p>普通构建：</p><ol><li><p>创建 Maven 项目</p></li><li><p>导入 SpringBoot 起步依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springboot 工程需要继承的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web 开发的起步依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引导类，SpringBoot项目的入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>快速构建：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-IDEA%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B.png"></p><hr><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在 spring-boot-starter-parent 中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。在各种 starter 中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。工程继承 parent，引入 starter 后，通过依赖传递，就可以简单方便获得需要的 jar 包，并且不会存在版本冲突，自动版本仲裁机制</p><hr><h3 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h3><h4 id="SpringBoot-1"><a href="#SpringBoot-1" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>@SpringBootApplication：启动注解，实现 SpringBoot 的自动部署</p><ul><li>参数 scanBasePackages：可以指定扫描范围</li><li>默认扫描当前引导类所在包及其子包</li></ul><p>假如所在包为 com.example.springbootenable，扫描配置包 com.example.config 的信息，三种解决办法：</p><ol><li><p>使用 @ComponentScan 扫描 com.example.config 包</p></li><li><p>使用 @Import 注解，加载类，这些类都会被 Spring 创建并放入 ioc 容器，默认组件的名字就是<strong>全类名</strong></p></li><li><p>对 @Import 注解进行封装</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.@ComponentScan(&quot;com.example.config&quot;)</span></span><br><span class="line"><span class="comment">//2.@Import(UserConfig.class)</span></span><br><span class="line"><span class="meta">@EnableUser</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootEnableApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringbootEnableApplication.class, args);</span><br><span class="line">    <span class="comment">//获取Bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EnableUser 注解类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(UserConfig.class)</span><span class="comment">//@Import注解实现Bean的动态加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>@Configuration：设置当前类为 SpringBoot 的配置类</p><ul><li>proxyBeanMethods &#x3D; true：Full 全模式，每个 @Bean 方法被调用多少次返回的组件都是单实例的，默认值，类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件</li><li>proxyBeanMethods &#x3D; false：Lite 轻量级模式，每个 @Bean 方法被调用多少次返回的组件都是新创建的，类组件之间<strong>无依赖关系</strong>用 Lite 模式加速容器启动过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的 id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><h5 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h5><p>Condition 是 Spring4.0 后引入的条件化配置接口，通过实现 Condition 接口可以完成有条件的加载相应的 Bean</p><p>注解：@Conditional</p><p>作用：条件装配，满足 Conditional 指定的条件则进行组件注入，加上方法或者类上，作用范围不同</p><p>使用：@Conditional 配合 Condition 的实现类（ClassCondition）进行使用</p><p>ConditionContext 类API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ConfigurableListableBeanFactory  getBeanFactory（）</td><td>获取到 IOC 使用的 beanfactory</td></tr><tr><td>ClassLoader getClassLoader()</td><td>获取类加载器</td></tr><tr><td>Environment getEnvironment()</td><td>获取当前环境信息</td></tr><tr><td>BeanDefinitionRegistry getRegistry()</td><td>获取到 bean 定义的注册类</td></tr></tbody></table><ul><li><p>ClassCondition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * context 上下文对象。用于获取环境，IOC容器，ClassLoader对象</span></span><br><span class="line"><span class="comment">     * metadata 注解元对象。 可以用于获取注解定义的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//1.需求： 导入Jedis坐标后创建Bean</span></span><br><span class="line">        <span class="comment">//思路：判断redis.clients.jedis.Jedis.class文件是否存在</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;redis.clients.jedis.Jedis&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(ClassCondition.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootConditionApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//启动SpringBoot应用，返回Spring的IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringbootConditionApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p>将类的判断定义为动态的，判断哪个字节码文件存在可以动态指定</p><ul><li><p>自定义条件注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(ClassCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassCondition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求：通过注解属性值value指定坐标后创建bean</span></span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes</span><br><span class="line">            (ConditionOnClass.class.getName());</span><br><span class="line">        <span class="comment">//map = &#123;value=&#123;属性值&#125;&#125;</span></span><br><span class="line">        <span class="comment">//获取所有的</span></span><br><span class="line">        String[] value = (String[]) map.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionOnClass(&quot;com.alibaba.fastjson.JSON&quot;)</span><span class="comment">//JSON加载了才注册 User 到容器</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 User 对象的创建</p></li></ul><hr><h5 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h5><p>SpringBoot 提供的常用条件注解：</p><p>@ConditionalOnProperty：判断<strong>配置文件</strong>中是否有对应属性和值才初始化 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name = &quot;it&quot;, havingValue = &quot;seazean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">it</span>=<span class="string">seazean</span></span><br></pre></td></tr></table></figure><p>@ConditionalOnClass：判断环境中是否有对应类文件才初始化 Bean</p><p>@ConditionalOnMissingClass：判断环境中是否有对应类文件才初始化 Bean</p><p>@ConditionalOnMissingBean：判断环境中没有对应Bean才初始化 Bean</p><hr><h4 id="ImportRes"><a href="#ImportRes" class="headerlink" title="ImportRes"></a>ImportRes</h4><p>使用 bean.xml 文件生成配置 bean，如果需要继续复用 bean.xml，@ImportResource 导入配置文件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>@ConfigurationProperties：读取到 properties 文件中的内容，并且封装到 JavaBean 中</p><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">100000</span></span><br></pre></td></tr></table></figure><p>JavaBean 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//导入到容器内</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><span class="comment">//代表配置文件的前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>应用启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动代码</span></span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication 构造方法：</p><ul><li><p><code>this.resourceLoader = resourceLoader</code>：资源加载器，初始为 null</p></li><li><p><code>this.webApplicationType = WebApplicationType.deduceFromClasspath()</code>：判断当前应用的类型，是响应式还是 Web 类</p></li><li><p><code>this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories()</code>：<strong>获取引导器</strong></p><ul><li>去 <strong><code>META-INF/spring.factories</code></strong> 文件中找 org.springframework.boot.Bootstrapper</li><li>寻找的顺序：classpath → spring-beans → boot-devtools → springboot → boot-autoconfigure</li></ul></li><li><p><code>setInitializers(getSpringFactoriesInstances(ApplicationContextInitializer.class))</code>：<strong>获取初始化器</strong></p><ul><li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationContextInitializer</li></ul></li><li><p><code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))</code>：<strong>获取监听器</strong></p><ul><li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationListener</li></ul></li><li><p><code>this.mainApplicationClass = deduceMainApplicationClass()</code>：获取出 main 程序类</p></li></ul><p>SpringApplication#run(String… args)：创建 IOC 容器并实现了自动装配</p><ul><li><p><code>StopWatch stopWatch = new StopWatch()</code>：停止监听器，<strong>监控整个应用的启停</strong></p></li><li><p><code>stopWatch.start()</code>：记录应用的启动时间</p></li><li><p><code>bootstrapContext = createBootstrapContext()</code>：<strong>创建引导上下文环境</strong></p><ul><li><code>bootstrapContext = new DefaultBootstrapContext()</code>：创建默认的引导类环境</li><li><code>this.bootstrapRegistryInitializers.forEach()</code>：遍历所有的引导器调用 initialize 方法完成初始化设置</li></ul></li><li><p><code>configureHeadlessProperty()</code>：让当前应用进入 headless 模式</p></li><li><p><code>listeners = getRunListeners(args)</code>：<strong>获取所有 RunListener（运行监听器）</strong></p><ul><li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.boot.SpringApplicationRunListener</li></ul></li><li><p><code>listeners.starting(bootstrapContext, this.mainApplicationClass)</code>：遍历所有的运行监听器调用 starting 方法</p></li><li><p><code>applicationArguments = new DefaultApplicationArguments(args)</code>：获取所有的命令行参数</p></li><li><p><code>environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments)</code>：<strong>准备环境</strong></p><ul><li><p><code>environment = getOrCreateEnvironment()</code>：返回或创建基础环境信息对象</p><ul><li><code>switch (this.webApplicationType)</code>：<strong>根据当前应用的类型创建环境</strong><ul><li><code>case SERVLET</code>：Web 应用环境对应 ApplicationServletEnvironment</li><li><code>case REACTIVE</code>：响应式编程对应 ApplicationReactiveWebEnvironment</li><li><code>default</code>：默认为 Spring 环境 ApplicationEnvironment</li></ul></li></ul></li><li><p><code>configureEnvironment(environment, applicationArguments.getSourceArgs())</code>：读取所有配置源的属性值配置环境</p></li><li><p><code>ConfigurationPropertySources.attach(environment)</code>：属性值绑定环境信息</p><ul><li><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 放入环境的属性信息头部</li></ul></li><li><p><code>listeners.environmentPrepared(bootstrapContext, environment)</code>：运行监听器调用 environmentPrepared()，EventPublishingRunListener 发布事件通知所有的监听器当前环境准备完成</p></li><li><p><code>DefaultPropertiesPropertySource.moveToEnd(environment)</code>：移动 defaultProperties 属性源到环境中的最后一个源</p></li><li><p><code>bindToSpringApplication(environment)</code>：与容器绑定当前环境</p></li><li><p><code>ConfigurationPropertySources.attach(environment)</code>：重新将属性值绑定环境信息</p></li><li><p><code>sources.remove(ATTACHED_PROPERTY_SOURCE_NAME)</code>：从环境信息中移除 configurationProperties </p></li><li><p><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 重新放入环境信息</p></li></ul></li><li><p><code>configureIgnoreBeanInfo(environment)</code>：<strong>配置忽略的 bean</strong></p></li><li><p><code>printedBanner = printBanner(environment)</code>：打印 SpringBoot 标志</p></li><li><p><code>context = createApplicationContext()</code>：<strong>创建 IOC 容器</strong></p><p><code>switch (this.webApplicationType)</code>：根据当前应用的类型创建 IOC 容器</p><ul><li><code>case SERVLET</code>：Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext</li><li><code>case REACTIVE</code>：响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext</li><li><code>default</code>：默认为 Spring 环境 AnnotationConfigApplicationContext</li></ul></li><li><p><code>context.setApplicationStartup(this.applicationStartup)</code>：设置一个启动器</p></li><li><p><code>prepareContext()</code>：配置 IOC 容器的基本信息</p><ul><li><p><code>postProcessApplicationContext(context)</code>：后置处理流程</p></li><li><p><code>applyInitializers(context)</code>：获取所有的<strong>初始化器调用 initialize() 方法</strong>进行初始化</p></li><li><p><code>listeners.contextPrepared(context)</code>：所有的运行监听器调用 environmentPrepared() 方法，EventPublishingRunListener 发布事件通知 IOC 容器准备完成</p></li><li><p><code>listeners.contextLoaded(context)</code>：所有的运行监听器调用 contextLoaded() 方法，通知 IOC 加载完成</p></li></ul></li><li><p><code>refreshContext(context)</code>：<strong>刷新 IOC 容器</strong></p><ul><li>Spring 的容器启动流程</li><li><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：<strong>实现了自动装配</strong></li><li><code>onRefresh()</code>：<strong>创建 WebServer</strong> 使用该接口</li></ul></li><li><p><code>afterRefresh(context, applicationArguments)</code>：留给用户自定义容器刷新完成后的处理逻辑</p></li><li><p><code>stopWatch.stop()</code>：记录应用启动完成的时间</p></li><li><p><code>callRunners(context, applicationArguments)</code>：调用所有 runners</p></li><li><p><code>listeners.started(context)</code>：所有的运行监听器调用 started() 方法</p></li><li><p><code>listeners.running(context)</code>：所有的运行监听器调用 running() 方法</p><ul><li><p>获取容器中的 ApplicationRunner、CommandLineRunner</p></li><li><p><code>AnnotationAwareOrderComparator.sort(runners)</code>：合并所有 runner 并且按照 @Order 进行排序</p></li><li><p><code>callRunner()</code>：遍历所有的 runner，调用 run 方法</p></li></ul></li><li><p><code>handleRunFailure(context, ex, listeners)</code>：<strong>处理异常</strong>，出现异常进入该逻辑</p><ul><li><code>handleExitCode(context, exception)</code>：处理错误代码</li><li><code>listeners.failed(context, exception)</code>：运行监听器调用 failed() 方法</li><li><code>reportFailure(getExceptionReporters(context), exception)</code>：通知异常</li></ul></li></ul><hr><h4 id="注解分析"><a href="#注解分析" class="headerlink" title="注解分析"></a>注解分析</h4><p>SpringBoot 定义了一套接口规范，这套规范规定 SpringBoot 在启动时会扫描外部引用 jar 包中的 <code>META-INF/spring.factories</code> 文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作，对于外部的 jar 包，直接引入一个 starter 即可</p><p>@SpringBootApplication 注解是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p><ul><li><p>@SpringBootApplication 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//代表 @SpringBootApplication 拥有了该注解的功能</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span><span class="comment">//同理</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="comment">// 扫描被 @Component (@Service,@Controller)注解的 bean，容器中将排除TypeExcludeFilter 和 AutoConfigurationExcludeFilter</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>@SpringBootConfiguration 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">// 代表是配置类</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AliasFor 注解：表示别名，可以注解到自定义注解的两个属性上表示这两个互为别名，两个属性其实是同一个含义相互替代</p></li><li><p>@ComponentScan 注解：默认扫描当前类所在包及其子级包下的所有文件</p></li><li><p><strong>@EnableAutoConfiguration 注解：启用 SpringBoot 的自动配置机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123; </span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;; </span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@AutoConfigurationPackage：<strong>将添加该注解的类所在的 package 作为自动配置 package 进行管理</strong>，把启动类所在的包设置一次，为了给各种自动配置的第三方库扫描用，比如带 @Mapper 注解的类，Spring 自身是不能识别的，但自动配置的 Mybatis 需要扫描用到，而 ComponentScan 只是用来扫描注解类，并没有提供接口给三方使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">// 利用 Registrar 给容器中导入组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123; </span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//自动配置包，指定了配置类的包</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]))</code>：注册 BD</p><ul><li><code>new PackageImports(metadata).getPackageNames()</code>：获取添加当前注解的类的所在包</li><li><code>registry.registerBeanDefinition(BEAN, new BasePackagesBeanDefinition(packageNames))</code>：存放到容器中<ul><li><code>new BasePackagesBeanDefinition(packageNames)</code>：把当前主类所在的包名封装到该对象中</li></ul></li></ul></li><li><p>@Import(AutoConfigurationImportSelector.class)：<strong>自动装配的核心类</strong></p><p>容器刷新时执行：<strong>invokeBeanFactoryPostProcessors()</strong> → invokeBeanDefinitionRegistryPostProcessors() → postProcessBeanDefinitionRegistry() → processConfigBeanDefinitions() → parse() → process() → processGroupImports() → getImports() → process() → <strong>AutoConfigurationImportSelector#getAutoConfigurationEntry()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取注解属性，@SpringBootApplication 注解的 exclude 属性和 excludeName 属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取所有需要自动装配的候选项</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 去除重复的选项</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 获取注解配置的排除的自动装配类</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 移除所有的配置的不需要自动装配的类</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 过滤，条件装配</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    <span class="comment">// 获取 AutoConfigurationImportListener 类的监听器调用 onAutoConfigurationImportEvent 方法</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 包装成 AutoConfigurationEntry 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoConfigurationImportSelector#getCandidateConfigurations：<strong>获取自动配置的候选项</strong></p><ul><li><p><code>List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames()</code>：加载自动配置类</p><p>参数一：<code>getSpringFactoriesLoaderFactoryClass()</code>：获取 @EnableAutoConfiguration 注解类</p><p>参数二：<code>getBeanClassLoader()</code>：获取类加载器</p><ul><li><code>factoryTypeName = factoryType.getName()</code>：@EnableAutoConfiguration 注解的全类名</li><li><code>return loadSpringFactories(classLoaderToUse).getOrDefault()</code>：加载资源<ul><li><code>urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION)</code>：获取资源类</li><li><code>FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;</code>：<strong>加载的资源的位置</strong></li></ul></li></ul></li><li><p><code>return configurations</code>：返回所有自动装配类的候选项</p></li></ul></li><li><p>从 spring-boot-autoconfigure-2.5.3.jar&#x2F;META-INF&#x2F;spring.factories 文件中寻找 EnableAutoConfiguration 字段，获取自动装配类，<strong>进行条件装配，按需装配</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p></li></ul></li></ul><hr><h4 id="装配流程"><a href="#装配流程" class="headerlink" title="装配流程"></a>装配流程</h4><p>Spring Boot 通过 <code>@EnableAutoConfiguration</code> 开启自动装配，通过 SpringFactoriesLoader 加载 <code>META-INF/spring.factories</code> 中的自动配置类实现自动装配，自动配置类其实就是通过 <code>@Conditional</code> 注解按需加载的配置类，想要其生效必须引入 <code>spring-boot-starter-xxx</code> 包实现起步依赖</p><ul><li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li><li>每个自动配置类进行<strong>条件装配</strong>，默认都会绑定配置文件指定的值（xxxProperties 和配置文件进行了绑定）</li><li>SpringBoot 默认会在底层配好所有的组件，如果用户自己配置了<strong>以用户的优先</strong></li><li><strong>定制化配置：</strong><ul><li>用户可以使用 @Bean 新建自己的组件来替换底层的组件</li><li>用户可以去看这个组件是获取的配置文件前缀值，在配置文件中修改</li></ul></li></ul><p>以 DispatcherServletAutoConfiguration 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="comment">// 类中的 Bean 默认不是单例</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 条件装配，环境中有 DispatcherServlet 类才进行自动装配</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> &#123;</span><br><span class="line"><span class="comment">// 注册的 DispatcherServlet 的 BeanName</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;dispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Conditional(DefaultDispatcherServletCondition.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line">    <span class="comment">// 绑定配置文件的属性，从配置文件中获取配置项</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给容器注册一个 DispatcherServlet，起名字为 dispatcherServlet</span></span><br><span class="line"><span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line"><span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个 DispatcherServlet 设置相关属性</span></span><br><span class="line"><span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">            <span class="comment">// spring.mvc 中的配置项获取注入，没有就填充默认值</span></span><br><span class="line">dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">            <span class="comment">// 返回该对象注册到容器内</span></span><br><span class="line"><span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">        <span class="comment">// 容器中有这个类型组件才进行装配</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(MultipartResolver.class)</span></span><br><span class="line">        <span class="comment">// 容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">        <span class="comment">// 方法名就是 BeanName</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line"><span class="comment">// 给 @Bean 标注的方法传入了对象参数，这个参数就会从容器中找，因为用户自定义了该类型，以用户配置的优先</span></span><br><span class="line">            <span class="comment">// 但是名字不符合规范，所以获取到该 Bean 并返回到容器一个规范的名称：multipartResolver</span></span><br><span class="line"><span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将配置文件中的 spring.mvc 前缀的属性与该类绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcProperties</span> &#123; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>SpringBoot 在项目启动时，会对几个监听器进行回调，可以实现监听器接口，在项目启动时完成一些操作</p><p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p><ul><li><p>MyApplicationRunner</p><p><strong>自定义监听器的启动时机</strong>：MyApplicationRunner 和 MyCommandLineRunner 都是当项目启动后执行，使用 @Component 放入容器即可使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当项目启动后执行run方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args.getSourceArgs()));<span class="comment">//properties配置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>MyCommandLineRunner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CommandLineRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MyApplicationContextInitializer 的启用要<strong>在 resource 文件夹下添加 META-INF&#x2F;spring.factories</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.springbootlistener.listener.MyApplicationContextInitializer</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationContextInitializer....initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MySpringApplicationRunListener 的使用要添加<strong>构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySpringApplicationRunListener</span><span class="params">(SpringApplication sa, String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starting...项目启动中&quot;</span>);<span class="comment">//输出SPRING之前</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;environmentPrepared...环境对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextPrepared...上下文对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextLoaded...上下文对象开始加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;started...上下文对象加载完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...项目启动完成，开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;failed...项目启动失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>SpringBoot 是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置，可以使用 application.properties 或者application.yml（application.yaml）进行配置</p><ul><li>默认配置文件名称：application</li><li>在同一级目录下优先级为：properties &gt; yml &gt; yaml</li></ul><p>例如配置内置 Tomcat 的端口</p><ul><li><p>properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure></li><li><p>yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server: port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><p>yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server: port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><p>所有位置的配置文件都会被加载，互补配置，<strong>高优先级配置内容会覆盖低优先级配置内容</strong></p><p>扫描配置文件的位置按优先级<strong>从高到底</strong>：</p><ul><li><p><code>file:./config/</code>：<strong>当前项目</strong>下的 &#x2F;config 目录下</p></li><li><p><code>file:./</code>：当前项目的根目录，Project工程目录</p></li><li><p><code>classpath:/config/</code>：classpath 的 &#x2F;config 目录</p></li><li><p><code>classpath:/</code>：classpath 的根目录，就是 resoureces 目录</p></li></ul><p>项目外部配置文件加载顺序：外部配置文件的使用是为了对内部文件的配合</p><ul><li><p>命令行：在 package 打包后的 target 目录下，使用该命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --server.port=9000</span><br></pre></td></tr></table></figure></li><li><p>指定配置文件位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location=e://application.properties</span><br></pre></td></tr></table></figure></li><li><p>按优先级从高到底选择配置文件的加载命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><p>基本语法：</p><ul><li><p>大小写敏感</p></li><li><p><strong>数据值前边必须有空格，作为分隔符</strong></p></li><li><p>使用缩进表示层级关系</p></li><li><p>缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应空格数目可能不同，导致层次混乱）</p></li><li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p></li><li><p>‘’#” 表示注释，从这个字符一直到行尾，都会被解析器忽略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span>  </span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li></ul><p>数据格式：</p><ul><li><p>纯量：单个的、不可再分的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">msg1:</span> <span class="string">&#x27;hello \n world&#x27;</span>  <span class="comment"># 单引忽略转义字符</span></span><br><span class="line"><span class="attr">msg2:</span> <span class="string">&quot;hello \n world&quot;</span>  <span class="comment"># 双引识别转义字符</span></span><br></pre></td></tr></table></figure></li><li><p>对象：键值对集合，Map、Hash</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span>  </span><br><span class="line">   <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>&#125;</span><br></pre></td></tr></table></figure><p>注意：不建议使用 JSON，应该使用 yaml 语法</p></li><li><p>数组：一组按次序排列的值，List、Array</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">beijing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">shanghai</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">beijing</span>,<span class="string">shanghai</span>]</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">allPerson</span><span class="comment">#List&lt;Person&gt;</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;</span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">allPerson:</span> [&#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;, &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>参数引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lisi</span> </span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 引用上边定义的name值</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><p>三种获取配置文件的方式：</p><ul><li><p>注解 @Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;address[0]&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Evironment 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;person.name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;address[0]&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解 @ConfigurationProperties 配合 @Component 使用</p><p><strong>注意</strong>：参数 prefix 一定要指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//不扫描该组件到容器内，无法完成自动装配</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String[] address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//Person&#123;name=&#x27;zhangsan&#x27;, age=20, address=[beijing, shanghai]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="配置提示"><a href="#配置提示" class="headerlink" title="配置提示"></a>配置提示</h3><p>自定义的类和配置文件绑定一般没有提示，添加如下依赖可以使用提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p>@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p><ul><li>加了环境标识的 bean，只有这个环境被激活的时候才能注册到容器中，默认是 default 环境</li><li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li><li>没有标注环境标识的 bean 在，任何环境下都是加载的</li></ul><p>Profile 的配置：</p><ul><li><p><strong>profile 是用来完成不同环境下，配置动态切换功能</strong></p></li><li><p><strong>profile 配置方式</strong>：多 profile 文件方式，提供多个配置文件，每个代表一种环境</p><ul><li>application-dev.properties&#x2F;yml 开发环境</li><li>application-test.properties&#x2F;yml 测试环境</li><li>sapplication-pro.properties&#x2F;yml 生产环境</li></ul></li><li><p>yml 多文档方式：在 yml 中使用  — 分隔不同配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:dev</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  profiles:test</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles:pro</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p><strong>profile 激活方式</strong></p><ul><li><p>配置文件：在配置文件中配置：spring.profiles.active&#x3D;dev</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>虚拟机参数：在VM options 指定：<code>-Dspring.profiles.active=dev</code></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-profile%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0.png"></p></li><li><p>命令行参数：<code>java –jar xxx.jar  --spring.profiles.active=dev</code></p><p>在 Program arguments 里输入，也可以先 package</p></li></ul></li></ul><hr><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><p>SpringBoot 自动配置了很多约定，大多场景都无需自定义配置</p><ul><li>内容协商视图解析器 ContentNegotiatingViewResolver 和 BeanName 视图解析器 BeanNameViewResolver</li><li>支持静态资源（包括 webjars）和静态 index.html 页支持</li><li>自动注册相关类：Converter、GenericConverter、Formatter</li><li>内容协商处理器：HttpMessageConverters</li><li>国际化：MessageCodesResolver</li></ul><p>开发规范：</p><ul><li>使用 <code>@Configuration</code> + <code>WebMvcConfigurer</code> 自定义规则，不使用 <code>@EnableWebMvc</code> 注解</li><li>声明 <code>WebMvcRegistrations</code> 的实现类改变默认底层组件</li><li>使用 <code>@EnableWebMvc</code> + <code>@Configuration</code> + <code>DelegatingWebMvcConfiguration</code> 全面接管 SpringMVC</li></ul><hr><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><h4 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h4><p>默认的静态资源路径是 classpath 下的，优先级由高到低为：&#x2F;META-INF&#x2F;resources、&#x2F;resources、 &#x2F;static、&#x2F;public  的包内，<code>/</code> 表示当前项目的根路径</p><p>静态映射 <code>/**</code> ，表示请求 <code>/ + 静态资源名</code> 就直接去默认的资源路径寻找请求的资源</p><p>处理原理：静请求去寻找 Controller 处理，不能处理的请求就会交给静态资源处理器，静态资源也找不到就响应 404 页面</p><ul><li><p>修改默认资源路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations::</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure></li><li><p>修改静态资源访问前缀，默认是 <code>/**</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span></span><br></pre></td></tr></table></figure><p>访问 URL：<a href="http://localhost:8080/resources/">http://localhost:8080/resources/</a> + 静态资源名，将所有资源<strong>重定位</strong>到 <code>/resources/</code></p></li><li><p>webjar 访问资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js%EF%BC%8C%E5%90%8E%E9%9D%A2%E5%9C%B0%E5%9D%80%E8%A6%81%E6%8C%89%E7%85%A7%E4%BE%9D%E8%B5%96%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84">http://localhost:8080/webjars/jquery/3.5.1/jquery.js，后面地址要按照依赖里面的包路径</a></p></li></ul><hr><h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>静态资源路径下 index.html 默认作为欢迎页面，访问 <a href="http://localhost:8080/">http://localhost:8080</a> 出现该页面，使用 welcome page 功能不能修改前缀</p><p>网页标签上的小图标可以自定义规则，把资源重命名为 favicon.ico 放在静态资源目录下即可</p><hr><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>SpringMVC 功能的自动配置类 WebMvcAutoConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//当前项目的根路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类 WebMvcAutoConfigurationAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="comment">// 绑定 spring.mvc、spring.web、spring.resources 相关的配置属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class,ResourceProperties.class, WebProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line"><span class="comment">//有参构造器所有参数的值都会从容器中确定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceProperties = resourceProperties.hasBeenCustomized() ? resourceProperties</span><br><span class="line">: webProperties.getResources();</span><br><span class="line"><span class="built_in">this</span>.mvcProperties = mvcProperties;</span><br><span class="line"><span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="built_in">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line"><span class="built_in">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line"><span class="built_in">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line"><span class="built_in">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line"><span class="built_in">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResourceProperties resourceProperties：获取和 spring.resources 绑定的所有的值的对象</li><li>WebMvcProperties mvcProperties：获取和 spring.mvc 绑定的所有的值的对象</li><li>ListableBeanFactory beanFactory：Spring 的 beanFactory</li><li>HttpMessageConverters：找到所有的 HttpMessageConverters</li><li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li><li>DispatcherServletPath：项目路径</li><li>ServletRegistrationBean：给应用注册 Servlet、Filter</li></ul></li><li><p>WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter.addResourceHandler()：两种静态资源映射规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//配置文件设置 spring.resources.add-mappings: false，禁用所有静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);<span class="comment">//被禁用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册webjars静态资源的映射规则映射路径</span></span><br><span class="line">    addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">//注册静态资源路径的映射规则 默认映射 staticPathPattern = &quot;/**&quot; </span></span><br><span class="line">    addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        <span class="comment">//staticLocations = CLASSPATH_RESOURCE_LOCATIONS</span></span><br><span class="line">        registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    <span class="comment">//默认资源路径，优先级从高到低</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">                                                 <span class="string">&quot;classpath:/resources/&quot;</span>, </span><br><span class="line">                                                 <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="comment">//可以进行规则重写</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticLocations</span><span class="params">(String[] staticLocations)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.staticLocations = appendSlashIfNecessary(staticLocations);</span><br><span class="line"><span class="built_in">this</span>.customized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WebMvcAutoConfiguration.EnableWebMvcConfiguration.welcomePageHandlerMapping()：欢迎页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spring.web 属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line">        <span class="type">WelcomePageHandlerMapping</span> <span class="variable">welcomePageHandlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TemplateAvailabilityProviders</span>(applicationContext), </span><br><span class="line">            applicationContext, getWelcomePage(),</span><br><span class="line">            <span class="comment">//staticPathPattern = &quot;/**&quot;</span></span><br><span class="line">            <span class="built_in">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">        <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">WelcomePageHandlerMapping(<span class="comment">/*参数*/</span>) &#123;</span><br><span class="line">    <span class="comment">//所以限制 staticPathPattern 必须为 /** 才能启用该功能</span></span><br><span class="line">    <span class="keyword">if</span> (welcomePage != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">        setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WelcomePageHandlerMapping，访问 &#x2F; 能访问到 index.html</p></li></ul><hr><h3 id="Rest映射"><a href="#Rest映射" class="headerlink" title="Rest映射"></a>Rest映射</h3><p>开启 Rest 功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><p>源码分析，注入了 HiddenHttpMethodFilte 解析 Rest 风格的访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedHiddenHttpMethodFilter</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细源码解析：SpringMVC → 基本操作 → Restful → 识别原理</p><p>Web 部分源码详解：SpringMVC → 运行原理</p><hr><h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>SpringBoot 嵌入式 Servlet 容器，默认支持的 WebServe：Tomcat、Jetty、Undertow</p><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> <span class="comment">&lt;!--必须要把内嵌的 Tomcat 容器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Web 应用启动，SpringBoot 导入 Web 场景包 tomcat，创建一个 Web 版的 IOC 容器：</p><ul><li><p><code>SpringApplication.run(BootApplication.class, args)</code>：应用启动</p></li><li><p><code>ConfigurableApplicationContext.run()</code>：</p><ul><li><p><code>context = createApplicationContext()</code>：<strong>创建容器</strong></p><ul><li><p><code>applicationContextFactory = ApplicationContextFactory.DEFAULT</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContextFactory</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> (webApplicationType) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (webApplicationType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVLET:</span><br><span class="line">                <span class="comment">// Servlet 容器，继承自 ServletWebServerApplicationContext</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">case</span> REACTIVE:</span><br><span class="line">                <span class="comment">// 响应式编程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 普通 Spring 容器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContextFactory.create(this.webApplicationType)</code>：根据应用类型创建容器</p></li></ul></li><li><p><code>refreshContext(context)</code>：容器启动刷新</p></li></ul></li></ul><p>内嵌容器工作流程：</p><ul><li><p>Spring 容器启动逻辑中，在实例化非懒加载的单例 Bean 之前有一个方法 **onRefresh()**，留给子类去扩展，Web 容器就是重写这个方法创建 WebServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">    <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">    createWebServer.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 WebServer 工厂 ServletWebServerFactory，并且获取的数量不等于 1 会报错，Spring 底层有三种：</p><p><code>TomcatServletWebServerFactory</code>、<code>JettyServletWebServerFactory</code>、<code>UndertowServletWebServerFactory</code></p></li><li><p><strong>自动配置类 ServletWebServerFactoryAutoConfiguration</strong> 导入了 ServletWebServerFactoryConfiguration（配置类），根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动</p></li><li><p>默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="type">boolean</span> autoStart, Shutdown shutdown)</span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">   initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法 initialize 中有启动方法：<code>this.tomcat.start()</code></p></li></ul><hr><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="定制规则"><a href="#定制规则" class="headerlink" title="定制规则"></a>定制规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="comment">//进行一些方法重写，来实现自定义的规则</span></span><br><span class="line">            <span class="comment">//比如添加一些解析器和拦截器，就是对原始容器功能的增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以不加 @Bean，直接从这里重写方法进行功能增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="定制容器"><a href="#定制容器" class="headerlink" title="定制容器"></a>定制容器</h4><p>@EnableWebMvc：全面接管 SpringMVC，所有规则全部自己重新配置</p><ul><li><p>@EnableWebMvc + WebMvcConfigurer + @Bean  全面接管SpringMVC</p></li><li><p>@Import(DelegatingWebMvcConfiguration.<strong>class</strong>)，该类继承 WebMvcConfigurationSupport，自动配置了一些非常底层的组件，只能保证 SpringMVC 最基本的使用</p></li></ul><p>原理：自动配置类 <strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效，WebMvcConfigurationSupport 类不能被加载，所以 @EnableWebMvc 导致配置类失效，从而接管了 SpringMVC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：一般不适用此注解</p><hr><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入 starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入 JDBC 场景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入 MySQL 驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本对应你的 MySQL 版本&lt;version&gt;5.1.49&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单独导入 MySQL 驱动是因为不确定用户使用的什么数据库</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.0.107:3306/db1?useSSL=false</span><span class="comment"># 不加 useSSL 会警告</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>测试文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boot05WebAdminApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account_tbl&quot;</span>, Long.class);</span><br><span class="line">        log.info(<span class="string">&quot;记录总数：&#123;&#125;&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>DataSourceAutoConfiguration：数据源的自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Conditional(PooledDataSourceCondition.class)</span> </span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PooledDataSourceConfiguration</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置项</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span>, InitializingBean &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>底层默认配置好的连接池是：<strong>HikariDataSource</strong></li><li>数据库连接池的配置，是容器中没有 DataSource 才自动配置的</li><li>修改数据源相关的配置：spring.datasource</li></ul><p>相关配置：</p><ul><li>DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置</li><li>JdbcTemplateAutoConfiguration： JdbcTemplate 的自动配置<ul><li>可以修改这个配置项 @ConfigurationProperties(prefix &#x3D; <strong>“spring.jdbc”</strong>) 来修改JdbcTemplate</li><li><code>@AutoConfigureAfter(DataSourceAutoConfiguration.class)</code>：在 DataSource 装配后装配</li></ul></li><li>JndiDataSourceAutoConfiguration： jndi 的自动配置</li><li>XADataSourceAutoConfiguration： 分布式事务相关</li></ul><hr><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DruidDataSource.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidSpringAopConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidStatViewServletConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidWebStatFilterConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidFilterConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDataSourceAutoConfigure</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>自动配置：</p><ul><li><p>扩展配置项 <strong>spring.datasource.druid</strong></p></li><li><p>DruidSpringAopConfiguration： 监控 SpringBean，配置项为 <code>spring.datasource.druid.aop-patterns</code></p></li><li><p>DruidStatViewServletConfiguration：监控页的配置项为 <code>spring.datasource.druid.stat-view-servlet</code>，默认开启</p></li><li><p>DruidWebStatFilterConfiguration：Web 监控配置项为 <code>spring.datasource.druid.web-stat-filter</code>，默认开启</p></li><li><p>DruidFilterConfiguration：所有 Druid 自己 filter 的配置</p></li></ul><p>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">aop-patterns:</span> <span class="string">com.atguigu.admin.*</span>  <span class="comment">#监控SpringBean</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span>     <span class="comment"># 底层开启功能，stat（sql监控），wall（防火墙）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">stat-view-servlet:</span>   <span class="comment"># 配置监控页功能</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span><span class="comment">#项目启动访问：http://localhost:8080/druid ，账号和密码是 admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">resetEnable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">web-stat-filter:</span>  <span class="comment"># 监控web</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">urlPattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span>    <span class="comment"># 对上面filters里面的stat的详细配置</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">1000</span></span><br><span class="line">          <span class="attr">logSlowSql:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">wall:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">drop-table-allow:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>配置示例：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p><p>配置项列表：<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p><hr><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>编写 MyBatis 相关配置：application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="comment">#  config-location: classpath:mybatis/mybatis-config.xml  建议不写</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">#可以不写全局配置文件，所有全局配置文件的配置都放在 configuration 配置项中即可</span></span><br></pre></td></tr></table></figure></li><li><p>定义表和实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 dao 和 mapper 文件&#x2F;纯注解开发</p><p>dao：**@Mapper 注解必须加，使用自动装配的 package，否则在启动类指定 @MapperScan() 扫描路径（不建议）**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//必须加Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserXmlMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.seazean.springbootmybatis.mapper.UserXmlMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>纯注解开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="自动配置-1"><a href="#自动配置-1" class="headerlink" title="自动配置"></a>自动配置</h4><p>MybatisAutoConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span><span class="comment">//MyBatis配置项绑定类。</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line">   <span class="meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisProperties</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件：<code>mybatis</code></li><li>自动配置了 SqlSessionFactory</li><li>导入 <code>AutoConfiguredMapperScannerRegistra</code> 实现 @Mapper 的扫描</li></ul><hr><h4 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动配置类：MybatisPlusAutoConfiguration </p><p>只需要 Mapper 继承 <strong>BaseMapper</strong> 就可以拥有 CRUD 功能</p><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置redis相关属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># redis的主机ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></li><li><p>注入 RedisTemplate 模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootRedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).set(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).get();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="自动配置-2"><a href="#自动配置-2" class="headerlink" title="自动配置"></a>自动配置</h4><p>RedisAutoConfiguration 自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>配置项：<code>spring.redis</code></p></li><li><p>自动导入了连接工厂配置类：LettuceConnectionConfiguration、JedisConnectionConfiguration</p></li><li><p>自动注入了模板类：RedisTemplate&lt;Object, Object&gt; 、StringRedisTemplate，k v 都是 String 类型</p></li><li><p>使用 @Autowired 注入模板类就可以操作 redis</p></li></ul><hr><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a>Junit5</h3><p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，由三个不同的子模块组成：</p><ul><li><p>JUnit Platform：在 JVM 上启动测试框架的基础，不仅支持 Junit 自制的测试引擎，其他测试引擎也可以接入</p></li><li><p>JUnit Jupiter：提供了 JUnit5 的新的编程模型，是 JUnit5 新特性的核心，内部包含了一个测试引擎，用于在 Junit Platform 上运行</p></li><li><p>JUnit Vintage：JUnit Vintage 提供了兼容 JUnit4.x、Junit3.x 的测试引擎</p><p>注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，如果需要兼容 Junit4 需要自行引入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boot05WebAdminApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><p>JUnit5 的注解如下：</p><ul><li><p>@Test：表示方法是测试方法，但是与 JUnit4 的 @Test 不同，它的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试，包是 <code>org.junit.jupiter.api.Test</code></p></li><li><p>@ParameterizedTest：表示方法是参数化测试</p></li><li><p>@RepeatedTest：表示方法可重复执行</p></li><li><p>@DisplayName：为测试类或者测试方法设置展示名称</p></li><li><p>@BeforeEach：表示在每个单元测试之前执行</p></li><li><p>@AfterEach：表示在每个单元测试之后执行</p></li><li><p>@BeforeAll：表示在所有单元测试之前执行</p></li><li><p>@AfterAll：表示在所有单元测试之后执行</p></li><li><p>@Tag：表示单元测试类别，类似于 JUnit4 中的 @Categories</p></li><li><p>@Disabled：表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore</p></li><li><p>@Timeout：表示测试方法运行如果超过了指定时间将会返回错误</p></li><li><p>@ExtendWith：为测试类或测试方法提供扩展类引用</p></li></ul><hr><h3 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h3><h4 id="简单断言"><a href="#简单断言" class="headerlink" title="简单断言"></a>简单断言</h4><p>断言（assertions）是测试方法中的核心，用来对测试需要满足的条件进行验证，断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</p><p>用来对单个值进行简单的验证：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;simple assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simple</span><span class="params">()</span> &#123;</span><br><span class="line">     assertEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">2</span>, <span class="string">&quot;simple math&quot;</span>);</span><br><span class="line">     assertNull(<span class="literal">null</span>);</span><br><span class="line">     assertNotNull(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="数组断言"><a href="#数组断言" class="headerlink" title="数组断言"></a>数组断言</h4><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;array assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">array</span><span class="params">()</span> &#123;</span><br><span class="line"> assertArrayEquals(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="组合断言"><a href="#组合断言" class="headerlink" title="组合断言"></a>组合断言</h4><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为验证的断言，可以通过 lambda 表达式提供这些断言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;assert all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">              () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>),</span><br><span class="line">              () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h4><p>Assertions.assertThrows()，配合函数式编程就可以进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ArithmeticException</span> <span class="variable">exception</span> <span class="operator">=</span> Assertions.assertThrows(</span><br><span class="line">        <span class="comment">//扔出断言异常</span></span><br><span class="line">ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="超时断言"><a href="#超时断言" class="headerlink" title="超时断言"></a>超时断言</h4><p>Assertions.assertTimeout() 为测试方法设置了超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeoutTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">    Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>通过 fail 方法直接使得测试失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;fail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldFail</span><span class="params">()</span> &#123;</span><br><span class="line">fail(<span class="string">&quot;This should fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>JUnit 5 中的前置条件（assumptions）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>，前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试前置条件&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testassumptions</span><span class="params">()</span>&#123;</span><br><span class="line">    Assumptions.assumeTrue(<span class="literal">false</span>,<span class="string">&quot;结果不是true&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h3><p>JUnit 5 可以通过 Java 中的内部类和 @Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起，在内部类中可以使用 @BeforeEach 和 @AfterEach 注解，而且嵌套的层次没有限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        assertNull(stack)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参数测试"><a href="#参数测试" class="headerlink" title="参数测试"></a>参数测试</h3><p>参数化测试是 JUnit5 很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能</p><p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><ul><li><p>@ValueSource：为参数化测试指定入参来源，支持八大基础类以及 String 类型、Class 类型</p></li><li><p>@NullSource：表示为参数化测试提供一个 null 的入参</p></li><li><p>@EnumSource：表示为参数化测试提供一个枚举入参</p></li><li><p>@CsvFileSource：表示读取指定 CSV 文件内容作为参数化测试入参</p></li><li><p>@MethodSource：表示读取指定方法的返回值作为参数化测试入参（注意方法返回需要是一个流）</p></li></ul><hr><h2 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h2><h3 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h3><p>每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等，SpringBoot 抽取了 Actuator 场景，使得每个微服务快速引用即可获得生产级别的应用监控、审计等功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暴露所有监控信息为 HTTP：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span> <span class="comment">#暴露所有端点信息</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span>  <span class="comment">#以web方式暴露</span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/actuator/[beans/health/metrics/]">http://localhost:8080/actuator/[beans/health/metrics/]</a></p><p>可视化界面：<a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p><hr><h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>默认所有的 Endpoint 除过 shutdown 都是开启的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span><span class="comment">#禁用所有的</span></span><br><span class="line">  <span class="attr">endpoint:</span><span class="comment">#手动开启一部分</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>端点：</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>auditevents</code></td><td>暴露当前应用程序的审核事件信息。需要一个 <code>AuditEventRepository</code> 组件</td></tr><tr><td><code>beans</code></td><td>显示应用程序中所有 Spring Bean 的完整列表</td></tr><tr><td><code>caches</code></td><td>暴露可用的缓存</td></tr><tr><td><code>conditions</code></td><td>显示自动配置的所有条件信息，包括匹配或不匹配的原因</td></tr><tr><td><code>configprops</code></td><td>显示所有 <code>@ConfigurationProperties</code></td></tr><tr><td><code>env</code></td><td>暴露 Spring 的属性 <code>ConfigurableEnvironment</code></td></tr><tr><td><code>flyway</code></td><td>显示已应用的所有 Flyway 数据库迁移。 需要一个或多个 Flyway 组件。</td></tr><tr><td><code>health</code></td><td>显示应用程序运行状况信息</td></tr><tr><td><code>httptrace</code></td><td>显示 HTTP 跟踪信息，默认情况下 100 个 HTTP 请求-响应需要一个 <code>HttpTraceRepository</code> 组件</td></tr><tr><td><code>info</code></td><td>显示应用程序信息</td></tr><tr><td><code>integrationgraph</code></td><td>显示 Spring integrationgraph，需要依赖 <code>spring-integration-core</code></td></tr><tr><td><code>loggers</code></td><td>显示和修改应用程序中日志的配置</td></tr><tr><td><code>liquibase</code></td><td>显示已应用的所有 Liquibase 数据库迁移，需要一个或多个 Liquibase 组件</td></tr><tr><td><code>metrics</code></td><td>显示当前应用程序的指标信息。</td></tr><tr><td><code>mappings</code></td><td>显示所有 <code>@RequestMapping</code> 路径列表</td></tr><tr><td><code>scheduledtasks</code></td><td>显示应用程序中的计划任务</td></tr><tr><td><code>sessions</code></td><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 的基于 Servlet 的 Web 应用程序</td></tr><tr><td><code>shutdown</code></td><td>使应用程序正常关闭，默认禁用</td></tr><tr><td><code>startup</code></td><td>显示由 <code>ApplicationStartup</code> 收集的启动步骤数据。需要使用 <code>SpringApplication</code> 进行配置 <code>BufferingApplicationStartup</code></td></tr><tr><td><code>threaddump</code></td><td>执行线程转储</td></tr></tbody></table><p>应用程序是 Web 应用程序（Spring MVC，Spring WebFlux 或 Jersey），则可以使用以下附加端点：</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>heapdump</code></td><td>返回 <code>hprof</code> 堆转储文件。</td></tr><tr><td><code>jolokia</code></td><td>通过 HTTP 暴露 JMX bean（需要引入 Jolokia，不适用于 WebFlux），需要引入依赖 <code>jolokia-core</code></td></tr><tr><td><code>logfile</code></td><td>返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性），支持使用 HTTP Range标头来检索部分日志文件的内容。</td></tr><tr><td><code>prometheus</code></td><td>以 Prometheus 服务器可以抓取的格式公开指标，需要依赖 <code>micrometer-registry-prometheus</code></td></tr></tbody></table><p>常用 Endpoint：</p><ul><li><p>Health：监控状况</p></li><li><p>Metrics：运行时指标</p></li><li><p>Loggers：日志记录</p></li></ul><hr><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p><ul><li>jar 包 (官方推荐，默认)</li><li>war 包</li></ul><p><strong>更改 pom 文件中的打包方式为 war</strong></p><ul><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDeployApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.sources(SpringbootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定打包的名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Spring全家桶" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="SpringBoot" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/"/>
    
    
    <category term="Spring全家桶" scheme="http://example.com/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringMvc</title>
    <link href="http://example.com/2022/08/18/SpringMvc/"/>
    <id>http://example.com/2022/08/18/SpringMvc/</id>
    <published>2022-08-17T16:02:15.970Z</published>
    <updated>2022-08-17T16:02:55.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>SpringMVC：是一种基于 Java 实现 MVC 模型的轻量级 Web 框架</p><p>SpringMVC 优点：</p><ul><li>使用简单</li><li>性能突出（对比现有的框架技术）</li><li>灵活性强</li></ul><p>软件开发三层架构：</p><ul><li><p>表现层：负责数据展示</p></li><li><p>业务层：负责业务处理</p></li><li><p>数据层：负责数据操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png"></p></li></ul><p>MVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式</p><ul><li><p>Model（模型）：数据模型，用于封装数据</p></li><li><p>View（视图）：页面视图，用于展示数据</p><ul><li>jsp  </li><li>html</li></ul></li></ul><ul><li><p>Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑</p><ul><li>Servlet</li><li>SpringMVC</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E5%8A%9F%E8%83%BD%E5%9B%BE%E7%A4%BA.png"></p></li></ul><p>参考视频：<a href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p><hr><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>流程分析：</p><ul><li>服务器启动<ol><li>加载 web.xml 中 DispatcherServlet</li><li>读取 spring-mvc.xml 中的配置，加载所有 controller 包中所有标记为 bean 的类</li><li>读取 bean 中方法上方标注 @RequestMapping 的内容</li></ol></li><li>处理请求<ol><li>DispatcherServlet 配置拦截所有请求 &#x2F;</li><li>使用请求路径与所有加载的 @RequestMapping 的内容进行比对</li><li>执行对应的方法</li><li>根据方法的返回值在 webapp 目录中查找对应的页面并展示</li></ol></li></ul><p>代码实现：</p><ul><li><p>pom.xml 导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_base_config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet3.0规范的坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring的坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc的坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体的插件配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设定具体 Controller，控制层 java &#x2F; controller &#x2F; UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  <span class="comment">//@Component衍生注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//设定当前方法的访问映射地址，等同于Servlet在web.xml中的配置</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">        <span class="comment">//设定具体跳转的页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webapp &#x2F; WEB-INF &#x2F; web.xml，配置SpringMVC核心控制器，请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载Spring控制文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>resouces &#x2F; spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描加载所有的控制类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h3><p>Controller 加载控制：SpringMVC 的处理器对应的 bean 必须按照规范格式开发，未避免加入无效的 bean 可通过 bean 加载过滤器进行包含设定或排除设定，表现层 bean 标注通常设定为 @Controller  </p><ul><li><p>resources &#x2F; spring-mvc.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> </span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>静态资源加载（webapp 目录下的相关资源），spring-mvc.xml 配置，开启 mvc 命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--放行指定类型静态资源配置方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span> <span class="comment">&lt;!--webapp/img/资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--SpringMVC 提供的通用资源放行方式，建议选择--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>中文乱码处理 SpringMVC 提供专用的中文字符过滤器，用于处理乱码问题。配置在 web.xml 里面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>WebApplicationContext，生成 Spring 核心容器（主容器&#x2F;父容器&#x2F;根容器）</p><ul><li>父容器：Spring 环境加载后形成的容器，包含 Spring 环境下的所有的 bean</li><li>子容器：当前 mvc 环境加载后形成的容器，不包含 Spring 环境下的 bean</li><li>子容器可以访问父容器中的资源，父容器不可以访问子容器的资源</li></ul><p>EnableWebMvc 注解作用：</p><ul><li>支持 ConversionService 的配置，可以方便配置自定义类型转换器</li><li>支持 @NumberFormat 注解格式化数字类型</li><li>支持 @DateTimeFormat 注解格式化日期数据，日期包括 Date、Calendar</li><li>支持 @Valid 的参数校验（需要导入 JSR-303 规范）</li><li>配合第三方 jar 包和 SpringMVC 提供的注解读写 XML 和 JSON 格式数据</li></ul><p>纯注解开发：</p><ul><li><p>使用注解形式转化 SpringMVC 核心配置文件为配置类 java &#x2F; config &#x2F;  SpringMVCConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.seazean&quot;, includeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">    type=FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">    classes = &#123;Controller.class&#125; )</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="comment">//等同于&lt;mvc:annotation-driven/&gt;，还不完全相同</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="comment">//注解配置通用放行资源的格式 建议使用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于 servlet3.0 规范，自定义 Servlet 容器初始化配置类，加载 SpringMVC 核心配置类  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//创建Servlet容器时，使用注解方式加载SPRINGMVC配置类中的信息，</span></span><br><span class="line">    <span class="comment">//并加载成WEB专用的ApplicationContext对象该对象放入了ServletContext范围，</span></span><br><span class="line">    <span class="comment">//在整个WEB容器中可以随时获取调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        A.C.W.<span class="type">A</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringMVCConfiguration.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乱码处理作为过滤器，在servlet容器启动时进行配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStartup(servletContext);</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">cef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        cef.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        FilterRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addFilter(<span class="string">&quot;characterEncodingFilter&quot;</span>, cef);</span><br><span class="line">        registration.addMappingForUrlPatterns(EnumSet.of(</span><br><span class="line">           DispatcherType.REQUEST,</span><br><span class="line">            DispatcherType.FORWARD,</span><br><span class="line">            DispatcherType.INCLUDE), <span class="literal">false</span>,<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p>名称：@RequestMapping</p><p>类型：方法注解、类注解</p><p>位置：处理器类中的方法定义上方、处理器类定义上方</p><ul><li><p>方法注解</p><p>作用：绑定请求地址与对应处理方法间的关系</p><p>无类映射地址访问格式： <a href="http://localhost/requestURL2">http://localhost/requestURL2</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestURL2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestURL2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类注解</p><p>作用：为当前处理器中所有方法设定公共的访问路径前缀</p><p>带有类映射地址访问格式，将类映射地址作为前缀添加在实际映射地址前面：**&#x2F;user&#x2F;requestURL1**</p><p>最终返回的页面如果未设定绝对访问路径，将从类映射地址所在目录中查找 <strong>webapp&#x2F;user&#x2F;page.jsp</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestURL2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestURL2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>常用属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value=&quot;/requestURL3&quot;, //设定请求路径，与path属性、 value属性相同</span></span><br><span class="line"><span class="meta">    method = RequestMethod.GET, //设定请求方式</span></span><br><span class="line"><span class="meta">    params = &quot;name&quot;, //设定请求参数条件</span></span><br><span class="line"><span class="meta">    headers = &quot;content-type=text/*&quot;, //设定请求消息头条件</span></span><br><span class="line"><span class="meta">    consumes = &quot;text/*&quot;, //用于指定可以接收的请求正文类型（MIME类型）</span></span><br><span class="line"><span class="meta">    produces = &quot;text/*&quot; //用于指定可以生成的响应正文类型（MIME类型）</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestURL3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>SpringMVC 将传递的参数封装到处理器方法的形参中，达到快速访问参数的目的</p><ul><li><p>访问 URL：<a href="http://localhost/requestParam1?name=seazean&amp;age=14">http://localhost/requestParam1?name=seazean&amp;age=14</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestParam1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestParam1</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;请求参数测试页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><p>@RequestParam 的使用：</p><ul><li><p>类型：形参注解</p></li><li><p>位置：处理器类中的方法形参前方</p></li><li><p>作用：绑定请求参数与对应处理方法形参间的关系</p></li><li><p>访问 URL：<a href="http://localhost/requestParam2?userName=Jock">http://localhost/requestParam2?userName=Jock</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam2</span><span class="params">(<span class="meta">@RequestParam(</span></span></span><br><span class="line"><span class="meta"><span class="params">                            name = &quot;userName&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                            required = true,//为true代表必须有参数</span></span></span><br><span class="line"><span class="meta"><span class="params">                            defaultValue = &quot;s&quot;)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="POJO类型"><a href="#POJO类型" class="headerlink" title="POJO类型"></a>POJO类型</h4><h5 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h5><p>当 POJO 中使用简单类型属性时， 参数名称与 POJO 类属性名保持一致  </p><ul><li><p>访问 URL： <a href="http://localhost/requestParam3?name=seazean&amp;age=14">http://localhost/requestParam3?name=seazean&amp;age=14</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam3</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + user.getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="参数冲突"><a href="#参数冲突" class="headerlink" title="参数冲突"></a>参数冲突</h5><p>当 POJO 类型属性与其他形参出现同名问题时，将被<strong>同时赋值</strong>，建议使用 @RequestParam 注解进行区分</p><ul><li><p>访问 URL： <a href="http://localhost/requestParam4?name=seazean&amp;age=14">http://localhost/requestParam4?name=seazean&amp;age=14</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam4</span><span class="params">(User user, String age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.age=&quot;</span> + user.getAge() + <span class="string">&quot;,age=&quot;</span> + age);<span class="comment">//14 14 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h5><p>当 POJO 中出现对象属性时，参数名称与对象层次结构名称保持一致  </p><ul><li><p>访问 URL： <a href="http://localhost/requestParam5?address.province=beijing">http://localhost/requestParam5?address.province=beijing</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam5</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.address=&quot;</span> + user.getAddress().getProvince());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h5><p>POJO 中出现集合类型的处理方式</p><ul><li><p>通过 URL 地址中同名参数，可以为 POJO 中的集合属性进行赋值，集合属性要求保存简单数据</p><p>访问 URL：<a href="http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc">http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam6</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user=&quot;</span> + user);</span><br><span class="line">    <span class="comment">//user = User&#123;name=&#x27;null&#x27;,age=null,nick=&#123;Jock1,Jockme,zahc&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>POJO 中出现 List 保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置访问 URL：<a href="http://localhost/requestParam7?addresses%5B0%5D.province=bj&amp;addresses%5B1%5D.province=tj">http://localhost/requestParam7?addresses[0].province=bj&amp;addresses[1].province=tj</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam7</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.addresses=&quot;</span> + user.getAddress());</span><br><span class="line">    <span class="comment">//&#123;Address&#123;provice=bj,city=&#x27;null&#x27;,address=&#x27;null&#x27;&#125;&#125;,&#123;Address&#123;....&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; addresses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>POJO 中出现 Map 保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象位置</p><p>URL: <a href="http://localhost/requestParam8?addressMap%5B%E2%80%99home%E2%80%99%5D.province=bj&amp;addressMap%5B%E2%80%99job%E2%80%99%5D.province=tj">http://localhost/requestParam8?addressMap[’home’].province=bj&amp;addressMap[’job’].province=tj</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam8</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.addressMap=&quot;</span> + user.getAddressMap());</span><br><span class="line">    <span class="comment">//user.addressMap=&#123;home=Address&#123;p=,c=,a=&#125;,job=Address&#123;....&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Address&gt; addressMap;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h4><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><p>请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  </p><ul><li><p>访问 URL： <a href="http://localhost/requestParam9?nick=Jockme&amp;nick=zahc">http://localhost/requestParam9?nick=Jockme&amp;nick=zahc</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam9&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam9</span><span class="params">(String[] nick)</span>&#123;</span><br><span class="line">    System.out.println(nick[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + nick[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h5><p>保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个</p><ul><li><p>访问 URL： <a href="http://localhost/requestParam10?nick=Jockme&amp;nick=zahc">http://localhost/requestParam10?nick=Jockme&amp;nick=zahc</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam10</span><span class="params">(<span class="meta">@RequestParam(&quot;nick&quot;)</span> List&lt;String&gt; nick)</span>&#123;</span><br><span class="line">    System.out.println(nick);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意： SpringMVC 默认将 List 作为对象处理，赋值前先创建对象，然后将 nick <strong>作为对象的属性</strong>进行处理。List 是接口无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的 ArrayList 类型后，对象可以创建但没有 nick 属性，因此数据为空<br>解决方法：需要告知 SpringMVC 的处理器 nick 是一组数据，而不是一个单一属性。通过 @RequestParam 注解，将数量大于 1 个 names 参数打包成参数数组后， SpringMVC 才能识别该数据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据</p></li></ul><hr><h4 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>开启转换配置：<code>&lt;mvc:annotation-driven /&gt;  </code><br>作用：提供 Controller 请求转发，Json 自动转换等功能</p><p>如果访问 URL：<a href="http://localhost/requestParam1?name=seazean&amp;age=seazean%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%EF%BC%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%BC%82%E5%B8%B8">http://localhost/requestParam1?name=seazean&amp;age=seazean，会出现报错，类型转化异常</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam1</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC 对接收的数据进行自动类型转换，该工作通过 Converter 接口实现：</p><ul><li><p>标量转换器</p></li><li><p>集合、数组相关转换器</p></li><li><p>默认转换器</p></li></ul><hr><h5 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h5><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-date%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></p><p>如果访问 URL：<a href="http://localhost/requestParam11?date=1999-09-09">http://localhost/requestParam11?date=1999-09-09</a> 会报错，所以需要日期类型转换</p><ul><li><p>声明自定义的转换格式并覆盖系统转换格式，配置 resources &#x2F; spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--5.启用自定义Converter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatters&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--4.设置具体的格式类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.datetime.DateFormatter&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--5.类型规则--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@DateTimeFormat<br>类型：形参注解、成员变量注解<br>位置：形参前面 或 成员变量上方<br>作用：为当前参数或变量指定类型转换规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam12</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;date=&quot;</span> + date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure><p>依赖注解驱动支持，xml 开启配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>  </span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h5><p>自定义类型转换器，实现 Converter 接口或者直接容器中注入：</p><ul><li><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">                  registry.addConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, Date&gt;() &#123;</span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="keyword">public</span> Pet <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                      <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                          <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                          <span class="comment">//类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，</span></span><br><span class="line">                          <span class="comment">//不允许抛出，框架无法预计此类异常如何处理</span></span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              date = df.parse(source);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">return</span> date;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">* 方式二：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line">      <span class="comment">//重写接口的抽象方法，参数由泛型决定</span></span><br><span class="line">      <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">          <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">          <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">//类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，</span></span><br><span class="line">          <span class="comment">//不允许抛出，框架无法预计此类异常如何处理</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              date = df.parse(source);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> date;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>配置 resources &#x2F; spring-mvc.xml，注册自定义转换器，将功能加入到 SpringMVC 转换服务 ConverterService 中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.将自定义Converter注册为Bean，受SpringMVC管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDateConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;converter.MyDateConverter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.设定自定义Converter服务bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--4.set保障同类型转换器仅保留一个，去重规则以Converter&lt;S,T&gt;的泛型为准--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--5.具体的类型转换器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam12</span><span class="params">(Date date)</span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>请求转发和重定向：</p><ul><li><p>请求转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showPage1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/page/page.jsp;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>请求重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPage2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/WEB-INF/page/page.jsp&quot;</span>;<span class="comment">//不能访问WEB-INF下的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>页面访问快捷设定（InternalResourceViewResolver）：</p><ul><li><p>展示页面的保存位置通常固定且结构相似，可以设定通用的访问路径简化页面配置，配置 spring-mvc.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPage3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage3</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage4</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:page&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage5</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果未设定了返回值，使用 void 类型，则默认使用访问路径作页面地址的前缀后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简页面配置方式，使用访问路径作为页面名称，省略返回值</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPage6</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="数据跳转"><a href="#数据跳转" class="headerlink" title="数据跳转"></a>数据跳转</h4><p>ModelAndView 是 SpringMVC 提供的一个对象，该对象可以用作控制器方法的返回值（Model 同），实现携带数据跳转</p><p>作用：</p><ul><li>设置数据，向请求域对象中存储数据</li><li>设置视图，逻辑视图</li></ul><p>代码实现：</p><ul><li><p>使用 HttpServletRequest 类型形参进行数据传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showPageAndData1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showPageAndData1</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Model 类型形参进行数据传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPageAndData2</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门实战&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.6d</span>);</span><br><span class="line">    <span class="comment">//添加数据的方式，key对value</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;book&quot;</span>,book);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelAndView 类型形参进行数据传递，将该对象作为返回值传递给调用者  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData3</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    <span class="comment">//ModelAndView mav = new ModelAndView(); 替换形参中的参数</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据的方式，key对value</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;book&quot;</span>,book);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jockme&quot;</span>);</span><br><span class="line">    <span class="comment">//设置页面的方式，该方法最后一次执行的结果生效</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">    <span class="comment">//返回值设定成ModelAndView对象</span></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ModelAndView 扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelAndView对象支持转发的手工设定，该设定不会启用前缀后缀的页面拼接格式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData4</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;forward:/WEB-INF/page/page.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ModelAndView对象支持重定向的手工设定，该设定不会启用前缀后缀的页面拼接格式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData6</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;redirect:page.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>注解：@ResponseBody</p><p>作用：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 Response 的 body 区。如果返回值是字符串，那么直接将字符串返回客户端；如果是一个对象，会<strong>将对象转化为 JSON</strong>，返回客户端</p><p>注意：当方法上面没有写 ResponseBody，底层会将方法的返回值封装为 ModelAndView 对象</p><ul><li><p>使用 HttpServletResponse 对象响应数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showData1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showData1</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>@ResponseBody 将返回的结果作为响应内容</strong>（页面显示），而非响应的页面名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showData2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;Jock&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 jackson 进行 json 数据格式转化</p><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--json相关坐标3个--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData3&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showData3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="keyword">return</span> om.writeValueAsString(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 SpringMVC 提供的消息类型转换器将对象与集合数据自动转换为 JSON 数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showData4&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">showData4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>手工添加信息类型转换器  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.</span></span></span><br><span class="line"><span class="string"><span class="tag">             annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.</span></span></span><br><span class="line"><span class="string"><span class="tag">                      json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure></li><li><p>使用 SpringMVC 注解驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>转换集合类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData5&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">showData5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book1.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book1.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book2.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book2.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    al.add(book1);</span><br><span class="line">    al.add(book2);</span><br><span class="line">    <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Rest（REpresentational State Transfer）：表现层状态转化，定义了<strong>资源在网络传输中以某种表现形式进行状态转移</strong>，即网络资源的访问方式</p><ul><li>资源：把真实的对象数据称为资源，一个资源既可以是一个集合，也可以是单个个体；每一种资源都有特定的 URI（统一资源标识符）与之对应，如果获取这个资源，访问这个 URI 就可以，比如获取特定的班级 <code>/class/12</code>；资源也可以包含子资源，比如 <code>/classes/classId/teachers</code> 某个指定班级的所有老师</li><li>表现形式：资源是一种信息实体，它可以有多种外在表现形式，把资源具体呈现出来的形式比如 json、xml、image、txt 等等叫做它的”表现层&#x2F;表现形式”</li><li>状态转移：描述的服务器端资源的状态，比如增删改查（通过 HTTP 动词实现）引起资源状态的改变，互联网通信协议 HTTP 协议，是一个<strong>无状态协议</strong>，所有的资源状态都保存在服务器端</li></ul><hr><h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p>Restful 是按照 Rest 风格访问网络资源</p><ul><li>传统风格访问路径：<a href="http://localhost/user/get?id=1">http://localhost/user/get?id=1</a></li><li>Rest 风格访问路径：<a href="http://localhost/user/1">http://localhost/user/1</a></li></ul><p>优点：隐藏资源的访问行为，通过地址无法得知做的是何种操作，书写简化</p><p>Restful 请求路径简化配置方式：<code>@RestController = @Controller + @ResponseBody</code></p><p>相关注解：@GetMapping 注解是 @RequestMapping 注解的衍生，所以效果是一样的，建议使用 @GetMapping </p><ul><li><p><code>@GetMapping(&quot;/poll&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/poll&quot;,method = RequestMethod.GET)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET)</span><span class="comment">// @GetMapping 就拥有了 @RequestMapping 的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GetMapping &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = RequestMapping.class)</span><span class="comment">// 与 RequestMapping 相通</span></span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PostMapping(&quot;/push&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/push&quot;,method = RequestMethod.POST)</code></p></li></ul><p>过滤器：HiddenHttpMethodFilter 是 SpringMVC 对 Restful 风格的访问支持的过滤器</p><p>代码实现：</p><ul><li><p>restful.jsp：</p><ul><li><p>页面表单<strong>使用隐藏域提交请求类型</strong>，参数名称固定为 _method，必须配合提交类型 method&#x3D;post 使用</p></li><li><p>GET 请求通过地址栏可以发送，也可以通过设置 form 的请求方式提交</p></li><li><p>POST 请求必须通过 form 的请求方式提交</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>restful风格请求表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切换请求路径为restful风格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一隐藏域，切换为PUT请求或DELETE请求，但是form表单的提交方式method属性必须填写post--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-PUT 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>java &#x2F; controller &#x2F; UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//设置rest风格的控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span><span class="comment">//设置公共访问路径，配合下方访问路径使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">putUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器 web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4><p>Restful 开发中的参数注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @PathVariable 注解获取路径上配置的具名变量，一般在有多个参数的时候添加</p><p>其他注解：</p><ul><li>@RequestHeader：获取请求头</li><li>@RequestParam：获取请求参数（指问号后的参数，url?a&#x3D;1&amp;b&#x3D;2）</li><li>@CookieValue：获取 Cookie 值</li><li>@RequestAttribute：获取 request 域属性</li><li>@RequestBody：获取请求体 [POST]</li><li>@MatrixVariable：矩阵变量</li><li>@ModelAttribute：自定义类型变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//rest风格访问路径简化书写方式，配合类注解@RequestMapping使用</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">restLocation2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....get:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....get:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....post:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....put:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....delete:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="识别原理"><a href="#识别原理" class="headerlink" title="识别原理"></a>识别原理</h4><p>表单提交要使用 REST 时，会带上 <code>_method=PUT</code>，请求过来被 <code>HiddenHttpMethodFilter</code> 拦截，进行过滤操作</p><p>org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容的请求 PUT、DELETE、PATCH</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),</span><br><span class="line">HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line">    <span class="comment">// 隐藏域的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_METHOD_PARAM</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodParam</span> <span class="operator">=</span> DEFAULT_METHOD_PARAM;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="comment">// 请求必须是 POST，</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取标签中 name=&quot;_method&quot; 的 value 值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                <span class="comment">// 转成大写</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">                <span class="comment">// 兼容的请求方式</span></span><br><span class="line">                <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                    <span class="comment">// 包装请求</span></span><br><span class="line">                    requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的</span></span><br><span class="line">        filterChain.doFilter(requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rest 使用客户端工具，如 Postman 可直接发送 put、delete 等方式请求不被过滤</p><p>改变默认的 <code>_method</code> 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span>&#123;</span><br><span class="line">    <span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">methodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="comment">//通过set 方法自定义</span></span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>SpringMVC 提供访问原始 Servlet 接口的功能</p><ul><li><p>SpringMVC 提供访问原始 Servlet 接口 API 的功能，通过形参声明即可 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/servletApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">servletApi</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                         HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    System.out.println(request.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Head 数据获取快捷操作方式<br>名称：@RequestHeader<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求头数据与对应处理方法形参间的关系<br>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快捷操作方式<span class="meta">@RequestMapping(&quot;/headApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headApi</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Language&quot;)</span> String headMsg)</span>&#123;</span><br><span class="line">    System.out.println(headMsg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>Cookie 数据获取快捷操作方式<br>名称：@CookieValue<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求 Cookie 数据与对应处理方法形参间的关系<br>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/cookieApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookieApi</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>Session 数据获取<br>名称：@SessionAttribute<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求Session数据与对应处理方法形参间的关系<br>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sessionApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sessionApi</span><span class="params">(<span class="meta">@SessionAttribute(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于在session中放入数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/setSessionData&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">setSessionData</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Session 数据设置<br>名称：@SessionAttributes<br>类型：类注解<br>位置：处理器类上方<br>作用：声明放入session范围的变量名称，适用于Model类型数据传参<br>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//设定当前类中名称为age和gender的变量放入session范围，不常用</span></span><br><span class="line"><span class="meta">@SessionAttributes(names = &#123;&quot;age&quot;,&quot;gender&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletController</span> &#123;</span><br><span class="line"><span class="comment">//将数据放入session存储范围，Model对象实现数据set，@SessionAttributes注解实现范围设定</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/setSessionData2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setSessionDate2</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;age&quot;</span>,<span class="number">39</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sessionApi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sessionApi</span><span class="params">(<span class="meta">@SessionAttribute(&quot;age&quot;)</span> <span class="type">int</span> age,</span></span><br><span class="line"><span class="params">                             <span class="meta">@SessionAttribute(&quot;gender&quot;)</span> String gender)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>spring-mvc.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h4><p>核心组件：</p><ul><li><p>DispatcherServlet：核心控制器， 是 SpringMVC 的核心，整体流程控制的中心，所有的请求第一步都先到达这里，由其调用其它组件处理用户的请求，它就是在 web.xml 配置的核心 Servlet，有效的降低了组件间的耦合性</p></li><li><p>HandlerMapping：处理器映射器， 负责根据请求找到对应具体的 Handler 处理器，SpringMVC 中针对配置文件方式、注解方式等提供了不同的映射器来处理</p></li><li><p>Handler：处理器，其实就是 Controller，业务处理的核心类，通常由开发者编写，并且必须遵守 Controller 开发的规则，这样适配器才能正确的执行。例如实现 Controller 接口，将 Controller 注册到 IOC 容器中等</p></li><li><p>HandlAdapter：处理器适配器，根据映射器中找到的 Handler，通过 HandlerAdapter 去执行 Handler，这是适配器模式的应用</p></li><li><p>View Resolver：视图解析器， 将 Handler 中返回的逻辑视图（ModelAndView）解析为一个具体的视图（View）对象</p></li><li><p>View：视图， View 最后对页面进行渲染将结果返回给用户，SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png"></p></li></ul><p>优点：</p><ul><li>与 Spring 集成，更好的管理资源</li><li>有很多参数解析器和视图解析器，支持的数据类型丰富</li><li>将映射器、处理器、视图解析器进行解耦，分工明确</li></ul><hr><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>在 Spring 容器初始化时会建立所有的 URL 和 Controller 的对应关系，保存到 Map&lt;URL, Controller&gt; 中，这样 request 就能快速根据 URL 定位到 Controller：</p><ul><li>在 Spring IOC 容器初始化完所有单例 bean 后</li><li>SpringMVC 会遍历所有的 bean，获取 Controller 中对应的 URL（这里获取 URL 的实现类有多个，用于处理不同形式配置的 Controller）</li><li>将每一个 URL 对应一个 Controller 存入 Map&lt;URL, Controller&gt; 中</li></ul><p>注意：将 @Controller 注解换成 @Component，启动时不会报错，但是在浏览器中输入路径时会出现 404，说明 Spring 没有对所有的 bean 进行 URL 映射</p><p><strong>一个 Request 来了：</strong></p><ul><li>监听端口，获得请求：Tomcat 监听 8080 端口的请求处理，根据路径调用了 web.xml 中配置的核心控制器 DispatcherServlet，<code>DispatcherServlet#doDispatch</code> 是<strong>核心调度方法</strong></li><li><strong>首先根据 URI 获取 HandlerMapping 处理器映射器</strong>，RequestMappingHandlerMapping 用来处理 @RequestMapping 注解的映射规则，其中保存了所有 handler 的映射规则，最后包装成一个拦截器链返回，拦截器链对象持有 HandlerMapping。如果没有合适的处理请求的 HandlerMapping，说明请求处理失败，设置响应码 404 返回</li><li>根据映射器获取当前 handler，<strong>处理器适配器执行处理方法</strong>，适配器根据请求的 URL 去 handler 中寻找对应的处理方法：<ul><li>创建 ModelAndViewContainer (mav) 对象，用来填充数据，然后通过不同的<strong>参数解析器</strong>去解析 URL 中的参数，完成数据解析绑定，然后执行真正的 Controller 方法，完成 handle 处理</li><li>方法执行完对<strong>返回值</strong>进行处理，没添加 @ResponseBody 注解的返回值使用视图处理器处理，把视图名称设置进入 mav 中</li><li>对添加了 @ResponseBody 注解的 Controller 的按照普通的返回值进行处理，首先进行内容协商，找到一种浏览器可以接受（请求头 Accept）的并且服务器可以生成的数据类型，选择合适数据转换器，设置响应头中的数据类型，然后写出数据</li><li>最后把 ModelAndViewContainer 和 ModelMap 中的数据<strong>封装到 ModelAndView 对象</strong>返回</li></ul></li><li><strong>视图解析</strong>，根据返回值创建视图，请求转发 View 实例为 InternalResourceView，重定向 View 实例为 RedirectView。最后调用 view.render 进行页面渲染，结果派发<ul><li>请求转发时请求域中的数据不丢失，会把 ModelAndView 的数据设置到请求域中，获取 Servlet 原生的 RequestDispatcher，调用 <code>RequestDispatcher#forward</code> 实现转发</li><li>重定向会造成请求域中的数据丢失，使用 Servlet 原生方式实现重定向 <code>HttpServletResponse#sendRedirect</code></li></ul></li></ul><hr><h3 id="调度函数"><a href="#调度函数" class="headerlink" title="调度函数"></a>调度函数</h3><p>请求进入原生的 HttpServlet 的 doGet() 方法处理，调用子类 FrameworkServlet 的 doGet() 方法，最终调用 DispatcherServlet 的 doService() 方法，为请求设置相关属性后调用 doDispatch()，请求和响应的以参数的形式传入</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8E%9F%E7%90%86.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request 和 response 为 Java 原生的类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 文件上传请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 异步管理器</span></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件上传相关请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到当前请求使用哪个 HandlerMapping （Controller 的方法）处理，返回执行链</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">// 没有合适的处理请求的方式 HandlerMapping，请求失败，直接返回 404</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据映射器获取当前 handler 处理器适配器，用来【处理当前的请求】</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// 获取发出此次请求的方式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="comment">// 判断请求是不是 GET 方法</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 拦截器链的前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行处理方法，返回的是 ModelAndView 对象，封装了所有的返回值数据</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 设置视图名字</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 执行拦截器链中的后置处理方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理程序调用的结果，进行结果派发</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔记参考视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p><hr><h3 id="请求映射-1"><a href="#请求映射-1" class="headerlink" title="请求映射"></a>请求映射</h3><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>doDispatch() 中调用 getHandler 方法获取所有的映射器</p><p>总体流程：</p><ul><li><p>所有的请求映射都在 HandlerMapping 中，<strong>RequestMappingHandlerMapping 处理 @RequestMapping 注解的映射规则</strong></p></li><li><p>遍历所有的 HandlerMapping 看是否可以匹配当前请求，匹配成功后返回，匹配失败设置 HTTP 404 响应码</p></li><li><p>用户可以自定义的映射处理，也可以给容器中放入自定义 HandlerMapping</p></li></ul><p>访问 URL：<a href="http://localhost:8080/user">http://localhost:8080/user</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">postUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//。。。。。</span></span><br></pre></td></tr></table></figure><p>HandlerMapping 处理器映射器，<strong>保存了所有 <code>@RequestMapping</code>  和 <code>handler</code> 的映射规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 HandlerMapping</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 尝试去每个 HandlerMapping 中匹配当前请求的处理</span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%8E%B7%E5%8F%96Controller%E5%A4%84%E7%90%86%E5%99%A8.png"></p><ul><li><p><code>mapping.getHandler(request)</code>：调用 AbstractHandlerMapping#getHandler</p><ul><li><p><code>Object handler = getHandlerInternal(request)</code>：<strong>获取映射器</strong>，底层调用 RequestMappingInfoHandlerMapping 类的方法，又调用 AbstractHandlerMethodMapping#getHandlerInternal</p><ul><li><p><code>String lookupPath = initLookupPath(request)</code>：地址栏的 URI，这里的 lookupPath 为 &#x2F;user</p></li><li><p><code>this.mappingRegistry.acquireReadLock()</code>：加读锁防止其他线程并发修改</p></li><li><p><code>handlerMethod = lookupHandlerMethod(lookupPath, request)</code>：获取当前 HandlerMapping 中的映射规则</p><ul><li><p><code>directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath)</code>：获取当前的映射器与当前<strong>请求的 URI 有关的所有映射规则</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-HandlerMapping%E7%9A%84%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png"></p></li><li><p><code>addMatchingMappings(directPathMatches, matches, request)</code>：<strong>匹配某个映射规则</strong></p><ul><li><code>for (T mapping : mappings)</code>：遍历所有的映射规则</li><li><code>match = getMatchingMapping(mapping, request)</code>：去匹配每一个映射规则，匹配失败返回 null</li><li><code>matches.add(new Match())</code>：匹配成功后封装成匹配器添加到匹配集合中</li></ul></li><li><p><code>matches.sort(comparator)</code>：匹配集合排序</p></li><li><p><code>Match bestMatch = matches.get(0)</code>：匹配完成只剩一个，直接获取返回对应的处理方法</p></li><li><p><code>if (matches.size() &gt; 1)</code>：当有多个映射规则符合请求时，报错</p></li><li><p><code>return bestMatch.getHandlerMethod()</code>：返回匹配器中的处理方法</p></li></ul></li></ul></li><li><p><code>executionChain = getHandlerExecutionChain(handler, request)</code>：<strong>为当前请求和映射器的构建一个拦截器链</strong></p><ul><li><code>for (HandlerInterceptor interceptor : this.adaptedInterceptors)</code>：遍历所有的拦截器</li><li><code>chain.addInterceptor(interceptor)</code>：把所有的拦截器添加到 HandlerExecutionChain 中，形成拦截器链</li></ul></li><li><p><code>return executionChain</code>：<strong>返回拦截器链，HandlerMapping 是链的 handler 成员属性</strong></p></li></ul></li></ul><hr><h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>doDispatch() 中调用 <code>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 HandlerAdapter</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="comment">// 判断当前适配器是否支持当前 handle</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="comment">// 返回的是 【RequestMappingHandlerAdapter】</span></span><br><span class="line">                <span class="comment">// AbstractHandlerMethodAdapter#supports -&gt; RequestMappingHandlerAdapter</span></span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h4><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/params&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">param</span><span class="params">(Map&lt;String, Object&gt; map, Model model, HttpServletRequest request)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);<span class="comment">// 都可以向请求域中添加数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);<span class="comment">// 它们两个都在数据封装在 【BindingAwareModelMap】，继承自 LinkedHashMap</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;m&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-Model%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90.png"></p><p>doDispatch() 中调用 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</code> <strong>使用适配器执行方法</strong></p><p><code>AbstractHandlerMethodAdapter#handle</code> → <code>RequestMappingHandlerAdapter#handleInternal</code> → <code>invokeHandlerMethod</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                           HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                           HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 封装成 SpringMVC 的接口，用于通用 Web 请求拦截器，使能够访问通用请求元数据，而不是用于实际处理请求</span></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// WebDataBinder 用于【从 Web 请求参数到 JavaBean 对象的数据绑定】，获取创建该实例的工厂</span></span><br><span class="line">        <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 创建 Model 实例，用于向模型添加属性</span></span><br><span class="line">        <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"><span class="comment">// 方法执行器</span></span><br><span class="line">        <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数解析器，有很多</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值处理器，也有很多</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置数据绑定器</span></span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">// 设置参数检查器</span></span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 新建一个 ModelAndViewContainer 并进行初始化和一些属性的填充</span></span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 设置一些属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【执行目标方法】</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="comment">// 异步请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 【获取 ModelAndView 对象，封装了 ModelAndViewContainer】</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletInvocableHandlerMethod#invokeAndHandle：执行目标方法</p><ul><li><p><code>returnValue = invokeForRequest(webRequest, mavContainer, providedArgs)</code>：<strong>执行自己写的 controller 方法，返回的就是自定义方法中 return 的值</strong></p><p><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs)</code>：<strong>参数处理的逻辑</strong>，遍历所有的参数解析器解析参数或者将 URI 中的参数进行绑定，绑定完成后开始执行目标方法</p><ul><li><p><code>parameters = getMethodParameters()</code>：获取此处理程序方法的方法参数的详细信息</p></li><li><p><code>Object[] args = new Object[parameters.length]</code>：存放所有的参数</p></li><li><p><code>for (int i = 0; i &lt; parameters.length; i++)</code>：遍历所有的参数</p></li><li><p><code>args[i] = findProvidedArgument(parameter, providedArgs)</code>：获取调用方法时提供的参数，一般是空</p></li><li><p><code>if (!this.resolvers.supportsParameter(parameter))</code>：<strong>获取可以解析当前参数的参数解析器</strong></p><p><code>return getArgumentResolver(parameter) != null</code>：获取参数的解析是否为空</p><ul><li><p><code>for (HandlerMethodArgumentResolver resolver : this.argumentResolvers)</code>：遍历容器内所有的解析器</p><p><code>if (resolver.supportsParameter(parameter))</code>：是否支持当前参数</p><ul><li><code>PathVariableMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @PathVariable 注解的参数</strong></li><li><code>ModelMethodProcessor#supportsParameter</code>：解析 Map 和 Model 类型的参数，Model 和 Map 的作用一样</li><li><code>ExpressionValueMethodArgumentResolver#supportsParameter</code>：解析标注 @Value 注解的参数</li><li><code>RequestParamMapMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @RequestParam 注解</strong></li><li><code>RequestPartMethodArgumentResolver#supportsParameter</code>：解析文件上传的信息</li><li><code>ModelAttributeMethodProcessor#supportsParameter</code>：解析标注 @ModelAttribute 注解或者不是简单类型<ul><li>子类 ServletModelAttributeMethodProcessor 是解析自定义类型 JavaBean 的解析器</li><li>简单类型有 Void、Enum、Number、CharSequence、Date、URI、URL、Locale、Class</li></ul></li></ul></li></ul></li><li><p><code>args[i] = this.resolvers.resolveArgument()</code>：<strong>开始解析参数，每个参数使用的解析器不同</strong></p><p><code>resolver = getArgumentResolver(parameter)</code>：获取参数解析器</p><p><code>return resolver.resolveArgument()</code>：开始解析</p><ul><li><code>PathVariableMapMethodArgumentResolver#resolveArgument</code>：@PathVariable，包装 URI 中的参数为 Map</li><li><code>MapMethodProcessor#resolveArgument</code>：调用 <code>mavContainer.getModel()</code> 返回默认 BindingAwareModelMap 对象</li><li><code>ModelAttributeMethodProcessor#resolveArgument</code>：<strong>自定义的 JavaBean 的绑定封装</strong>，下一小节详解</li></ul></li></ul><p><code>return doInvoke(args)</code>：<strong>真正的执行 Controller 方法</strong></p><ul><li><code>Method method = getBridgedMethod()</code>：从 HandlerMethod 获取要反射执行的方法</li><li><code>ReflectionUtils.makeAccessible(method)</code>：破解权限</li><li><code>method.invoke(getBean(), args)</code>：执行方法，getBean 获取的是标记 @Controller 的 Bean 类，其中包含执行方法</li></ul></li><li><p><strong>进行返回值的处理，响应部分详解</strong>，处理完成进入下面的逻辑</p></li></ul><p>RequestMappingHandlerAdapter#getModelAndView：获取 ModelAndView 对象</p><ul><li><p><code>modelFactory.updateModel(webRequest, mavContainer)</code>：Model 数据升级到会话域（<strong>请求域中的数据在重定向时丢失</strong>）</p><ul><li><code>updateBindingResult(request, defaultModel)</code>：把绑定的数据添加到 BindingAwareModelMap 中</li></ul></li><li><p><code>if (mavContainer.isRequestHandled())</code>：判断请求是否已经处理完成了</p></li><li><p><code>ModelMap model = mavContainer.getModel()</code>：获取<strong>包含 Controller 方法参数</strong>的 BindingAwareModelMap（本节开头）</p></li><li><p><code>mav = new ModelAndView()</code>：<strong>把 ModelAndViewContainer 和 ModelMap 中的数据封装到 ModelAndView</strong> </p></li><li><p><code>if (!mavContainer.isViewReference())</code>：是否是通过名称指定视图引用</p></li><li><p><code>if (model instanceof RedirectAttributes)</code>：判断 model 是否是重定向数据，如果是进行重定向逻辑</p></li><li><p><code>return mav</code>：<strong>任何方法执行都会返回 ModelAndView 对象</strong></p></li></ul><hr><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>解析自定义的 JavaBean 为例，调用 ModelAttributeMethodProcessor#resolveArgument 处理参数的方法，通过合适的类型转换器把 URL 中的参数转换以后，利用反射获取 set 方法，注入到 JavaBean</p><ul><li><p>Person.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//加入到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//返回的数据不是页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterController</span> &#123;</span><br><span class="line">    <span class="comment">// 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/saveuser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">saveuser</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问 URL：<a href="http://localhost:8080/saveuser?userName=zhangsan&amp;age=20">http://localhost:8080/saveuser?userName=zhangsan&amp;age=20</a></p></li></ul><p>进入源码：ModelAttributeMethodProcessor#resolveArgument</p><ul><li><p><code>name = ModelFactory.getNameForParameter(parameter)</code>：获取名字，此例就是 person</p></li><li><p><code>ann = parameter.getParameterAnnotation(ModelAttribute.class)</code>：是否有 ModelAttribute 注解</p></li><li><p><code>if (mavContainer.containsAttribute(name))</code>：ModelAndViewContainer 中是否包含 person 对象</p></li><li><p><code>attribute = createAttribute()</code>：<strong>创建一个实例，空的 Person 对象</strong></p></li><li><p><code>binder = binderFactory.createBinder(webRequest, attribute, name)</code>：Web 数据绑定器，可以利用 Converters 将请求数据转成指定的数据类型，绑定到 JavaBean 中</p></li><li><p><code>bindRequestParameters(binder, webRequest)</code>：<strong>利用反射向目标对象填充数据</strong></p><p><code>servletBinder = (ServletRequestDataBinder) binder</code>：类型强转</p><p><code>servletBinder.bind(servletRequest)</code>：绑定数据</p><ul><li><p><code>mpvs = new MutablePropertyValues(request.getParameterMap())</code>：获取请求 URI 参数中的 k-v 键值对</p></li><li><p><code>addBindValues(mpvs, request)</code>：子类可以用来为请求添加额外绑定值</p></li><li><p><code>doBind(mpvs)</code>：真正的绑定的方法，调用 <code>applyPropertyValues</code> 应用参数值，然后调用 <code>setPropertyValues</code> 方法</p><p><code>AbstractPropertyAccessor#setPropertyValues()</code>：</p><ul><li><p><code>List&lt;PropertyValue&gt; propertyValues</code>：获取到所有的参数的值，就是 URI 上的所有的参数值</p></li><li><p><code>for (PropertyValue pv : propertyValues)</code>：遍历所有的参数值</p></li><li><p><code>setPropertyValue(pv)</code>：<strong>填充到空的 Person 实例中</strong></p><ul><li><p><code>nestedPa = getPropertyAccessorForPropertyPath(propertyName)</code>：获取属性访问器</p></li><li><p><code>tokens = getPropertyNameTokens()</code>：获取元数据的信息</p></li><li><p><code>nestedPa.setPropertyValue(tokens, pv)</code>：填充数据</p></li><li><p><code>processLocalProperty(tokens, pv)</code>：处理属性</p><ul><li><p><code>if (!Boolean.FALSE.equals(pv.conversionNecessary))</code>：数据是否需要转换了</p></li><li><p><code>if (pv.isConverted())</code>：数据已经转换过了，转换了直接赋值，没转换进行转换</p></li><li><p><code>oldValue = ph.getValue()</code>：获取未转换的数据</p></li><li><p><code>valueToApply = convertForProperty()</code>：进行数据转换</p><p><code>TypeConverterDelegate#convertIfNecessary</code>：进入该方法的逻辑</p><ul><li><p><code>if (conversionService.canConvert(sourceTypeDesc, typeDescriptor))</code>：判断能不能转换</p><p><code>GenericConverter converter = getConverter(sourceType, targetType)</code>：<strong>获取类型转换器</strong></p><ul><li><p><code>converter = this.converters.find(sourceType, targetType)</code>：寻找合适的转换器</p><ul><li><p><code>sourceCandidates = getClassHierarchy(sourceType.getType())</code>：原数据类型</p></li><li><p><code>targetCandidates = getClassHierarchy(targetType.getType())</code>：目标数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">    <span class="comment">//双重循环遍历，寻找合适的转换器</span></span><br><span class="line"> <span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br></pre></td></tr></table></figure></li><li><p><code>GenericConverter converter = getRegisteredConverter(..)</code>：匹配类型转换器</p></li><li><p><code>return converter</code>：返回转换器</p></li></ul></li></ul></li><li><p><code>conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)</code>：开始转换</p><ul><li><code>converter = getConverter(sourceType, targetType)</code>：<strong>获取可用的转换器</strong></li><li><code>result = ConversionUtils.invokeConverter()</code>：执行转换方法<ul><li><code>converter.convert()</code>：<strong>调用转换器的转换方法</strong>（GenericConverter#convert）</li></ul></li><li><code>return handleResult(sourceType, targetType, result)</code>：返回结果</li></ul></li></ul></li><li><p><code>ph.setValue(valueToApply)</code>：<strong>设置 JavaBean 属性</strong>（BeanWrapperImpl.BeanPropertyHandler）</p><ul><li><code>Method writeMethod</code>：获取写数据方法<ul><li><code>Class&lt;?&gt; cls = getClass0()</code>：获取 Class 对象</li><li><code>writeMethodName = Introspector.SET_PREFIX + getBaseName()</code>：<strong>set 前缀 + 属性名</strong></li><li><code>writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args)</code>：获取只包含一个参数的 set 方法</li><li><code>setWriteMethod(writeMethod)</code>：加入缓存</li></ul></li><li><code>ReflectionUtils.makeAccessible(writeMethod)</code>：设置访问权限</li><li><code>writeMethod.invoke(getWrappedInstance(), value)</code>：执行方法</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><code>bindingResult = binder.getBindingResult()</code>：获取绑定的结果</p></li><li><p><code>mavContainer.addAllAttributes(bindingResultModel)</code>：<strong>把所有填充的参数放入 ModelAndViewContainer</strong></p></li><li><p><code>return attribute</code>：返回填充后的 Person 对象</p></li></ul><hr><h3 id="响应处理-1"><a href="#响应处理-1" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>以 Person 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">// 利用返回值处理器里面的消息转换器进行处理，而不是视图</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.setAge(<span class="number">28</span>);</span><br><span class="line">    person.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    person.setUserName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入方法执行完后的逻辑 ServletInvocableHandlerMethod#invokeAndHandle：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 【执行目标方法】，return person 对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    <span class="comment">// 设置状态码</span></span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断方法是否有返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 返回值是字符串</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        <span class="comment">// 设置请求处理完成</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 设置请求没有处理完成，还需要进行返回值的逻辑</span></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【返回值的处理】</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>没有加 @ResponseBody 注解的返回数据按照视图处理的逻辑</strong>，ViewNameMethodReturnValueHandler（视图详解）</li><li>此例是加了注解的，返回的数据不是视图，HandlerMethodReturnValueHandlerComposite#handleReturnValue：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span>  &#123;</span><br><span class="line"><span class="comment">// 获取合适的返回值处理器</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用处理器处理返回值（详解源码中的这两个函数）</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerMethodReturnValueHandlerComposite#selectHandler：获取合适的返回值处理器</p><ul><li><p><code>boolean isAsyncValue = isAsyncReturnValue(value, returnType)</code>：是否是异步请求</p></li><li><p><code>for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers)</code>：遍历所有的返回值处理器</p><ul><li><code>RequestResponseBodyMethodProcessor#supportsReturnType</code>：<strong>处理标注 @ResponseBody 注解的返回值</strong></li><li><code>ModelAndViewMethodReturnValueHandler#supportsReturnType</code>：处理返回值类型是 ModelAndView 的处理器</li><li><code>ModelAndViewResolverMethodReturnValueHandler#supportsReturnType</code>：直接返回 true，处理所有数据</li></ul></li></ul><p>RequestResponseBodyMethodProcessor#handleReturnValue：处理返回值，要进行<strong>内容协商</strong></p><ul><li><p><code>mavContainer.setRequestHandled(true)</code>：设置请求处理完成</p></li><li><p><code>inputMessage = createInputMessage(webRequest)</code>：获取输入的数据</p></li><li><p><code>outputMessage = createOutputMessage(webRequest)</code>：获取输出的数据</p></li><li><p><code>writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage)</code>：使用消息转换器进行写出</p><ul><li><p><code>if (value instanceof CharSequence)</code>：判断返回的数据是不是字符类型</p></li><li><p><code>body = value</code>：把 value 赋值给 body，此时 body 中就是自定义方法执行完后的 Person 对象</p></li><li><p><code>if (isResourceType(value, returnType))</code>：当前数据是不是流数据</p></li><li><p><code>MediaType selectedMediaType</code>：<strong>内容协商后选择使用的类型，浏览器和服务器都支持的媒体（数据）类型</strong></p></li><li><p><code>MediaType contentType = outputMessage.getHeaders().getContentType()</code>：获取响应头的数据</p></li><li><p><code>if (contentType != null &amp;&amp; contentType.isConcrete())</code>：判断当前响应头中是否已经有确定的媒体类型</p><p><code>selectedMediaType = contentType</code>：前置处理已经使用了媒体类型，直接继续使用该类型</p></li><li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：<strong>获取浏览器支持的媒体类型，请求头字段</strong></p><ul><li><code>this.contentNegotiationManager.resolveMediaTypes()</code>：调用该方法</li><li><code>for(ContentNegotiationStrategy strategy:this.strategies)</code>：<strong>默认策略是提取请求头的字段的内容</strong>，策略类为HeaderContentNegotiationStrategy，可以配置添加其他类型的策略<ul><li><code>List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request)</code>：解析 Accept 字段存储为 List<ul><li><code>headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT)</code>：获取请求头中 Accept 字段</li><li><code>List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues)</code>：解析成 List 集合</li><li><code>MediaType.sortBySpecificityAndQuality(mediaTypes)</code>：按照相对品质因数 q 降序排序</li></ul></li></ul></li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p></li><li><p><code>producibleTypes = getProducibleMediaTypes(request, valueType, targetType)</code>：<strong>服务器能生成的媒体类型</strong></p><ul><li><code>request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE)</code>：从请求域获取默认的媒体类型<ul><li><code> for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：遍历所有的消息转换器</li><li><code>converter.canWrite(valueClass, null)</code>：是否支持当前的类型</li><li><code> result.addAll(converter.getSupportedMediaTypes())</code>：把当前 MessageConverter 支持的所有类型放入 result</li></ul></li></ul></li><li><p><code>List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;()</code>：存储最佳匹配的集合</p></li><li><p><strong>内容协商：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (MediaType requestedType : acceptableTypes) &#123;<span class="comment">// 遍历所有浏览器能接受的媒体类型</span></span><br><span class="line">    <span class="keyword">for</span> (MediaType producibleType : producibleTypes) &#123;<span class="comment">// 遍历所有服务器能产出的</span></span><br><span class="line">        <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;<span class="comment">// 判断类型是否匹配，最佳匹配</span></span><br><span class="line">            <span class="comment">// 数据协商匹配成功，一般有多种</span></span><br><span class="line">            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>MediaType.sortBySpecificityAndQuality(mediaTypesToUse)</code>：按照相对品质因数 q 排序，降序排序，越大的越好</p></li><li><p><code>for (MediaType mediaType : mediaTypesToUse)</code>：<strong>遍历所有的最佳匹配</strong>，选择一种赋值给选择的类型</p></li><li><p><code>selectedMediaType = selectedMediaType.removeQualityValue()</code>：媒体类型去除相对品质因数</p></li><li><p><code>for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：<strong>遍历所有的 HTTP 数据转换器</strong></p></li><li><p><code>GenericHttpMessageConverter genericConverter</code>：<strong>MappingJackson2HttpMessageConverter 可以将对象写为 JSON</strong></p></li><li><p><code>((GenericHttpMessageConverter) converter).canWrite()</code>：判断转换器是否可以写出给定的类型</p><p><code>AbstractJackson2HttpMessageConverter#canWrit</code></p><ul><li><p><code>if (!canWrite(mediaType))</code>：是否可以写出指定类型</p><ul><li><code>MediaType.ALL.equalsTypeAndSubtype(mediaType)</code>：是不是 <code>*/*</code> 类型</li><li><code>getSupportedMediaTypes()</code>：支持 <code>application/json</code> 和 <code>application/*+json</code> 两种类型<ul><li><code>return true</code>：返回 true</li></ul></li><li><code>objectMapper = selectObjectMapper(clazz, mediaType)</code>：选择可以使用的 objectMapper </li><li><code>causeRef = new AtomicReference&lt;&gt;()</code>：获取并发安全的引用</li><li><code>if (objectMapper.canSerialize(clazz, causeRef))</code>：objectMapper 可以序列化当前类</li><li><code>return true</code>：返回 true</li></ul></li><li><p><code> body = getAdvice().beforeBodyWrite()</code>：<strong>获取要响应的所有数据，就是 Person 对象</strong></p></li></ul></li><li><p><code>addContentDispositionHeader(inputMessage, outputMessage)</code>：检查路径</p></li><li><p><code>genericConverter.write(body, targetType, selectedMediaType, outputMessage)</code>：调用消息转换器的 write 方法</p><p><code>AbstractGenericHttpMessageConverter#write</code>：该类的方法</p><ul><li><p><code>addDefaultHeaders(headers, t, contentType)</code>：<strong>设置响应头中的数据类型</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p></li><li><p><code>writeInternal(t, type, outputMessage)</code>：<strong>数据写出为 JSON 格式</strong></p><ul><li><code>Object value = object</code>：value 引用 Person 对象</li><li><code>ObjectWriter objectWriter = objectMapper.writer()</code>：获取 ObjectWriter 对象</li><li><code>objectWriter.writeValue(generator, value)</code>：使用 ObjectWriter 写出数据为 JSON</li></ul></li></ul></li></ul><hr><h4 id="协商策略"><a href="#协商策略" class="headerlink" title="协商策略"></a>协商策略</h4><p>开启基于请求参数的内容协商模式：（SpringBoot 方式）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.contentnegotiation:favor-parameter:</span> <span class="literal">true</span>  <span class="comment"># 开启请求参数内容协商模式</span></span><br></pre></td></tr></table></figure><p>发请求： <a href="http://localhost:8080/person?format=json%EF%BC%8C%E8%A7%A3%E6%9E%90">http://localhost:8080/person?format=json，解析</a> format</p><p>策略类为 ParameterContentNegotiationStrategy，运行流程如下：</p><ul><li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：获取浏览器支持的媒体类型</p><p><code>mediaTypes = strategy.resolveMediaTypes(request)</code>：解析请求 URL 参数中的数据</p><ul><li><p><code>return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest))</code>：</p><p><code>getMediaTypeKey(webRequest)</code>：</p><ul><li><code>request.getParameter(getParameterName())</code>：获取 URL 中指定的需求的数据类型<ul><li><code>getParameterName()</code>：获取参数的属性名 format</li><li><code>getParameter()</code>：<strong>获取 URL 中 format 对应的数据</strong></li></ul></li></ul><p><code>resolveMediaTypeKey()</code>：解析媒体类型，封装成集合</p></li></ul></li></ul><p>自定义内容协商策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span><span class="comment">//自定义内容协商策略</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> &#123;</span><br><span class="line">                Map&lt;String, MediaType&gt; mediaTypes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;json&quot;</span>, MediaType.APPLICATION_JSON);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;xml&quot;</span>,MediaType.APPLICATION_XML);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;person&quot;</span>,MediaType.parseMediaType(<span class="string">&quot;application/x-person&quot;</span>));</span><br><span class="line">                <span class="comment">// 指定支持解析哪些参数对应的哪些媒体类型</span></span><br><span class="line">                <span class="type">ParameterContentNegotiationStrategy</span> <span class="variable">parameterStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterContentNegotiationStrategy</span>(mediaTypes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求头解析</span></span><br><span class="line">                <span class="type">HeaderContentNegotiationStrategy</span> <span class="variable">headStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderContentNegotiationStrategy</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加到容器中，即可以解析请求头 又可以解析请求参数</span></span><br><span class="line">                configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// 自定义消息转换器</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">                converters.add(<span class="keyword">new</span> <span class="title class_">GuiguMessageConverter</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以自定义 HttpMessageConverter，实现 HttpMessageConverter<T> 接口重写方法即可</p><hr><h3 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h3><h4 id="返回解析"><a href="#返回解析" class="headerlink" title="返回解析"></a>返回解析</h4><p>请求处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/params&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">param</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/success&quot;</span>;</span><br><span class="line">    <span class="comment">//return &quot;redirect:/success&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入执行方法逻辑 ServletInvocableHandlerMethod#invokeAndHandle，进入 <code>this.returnValueHandlers.handleReturnValue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span>  &#123;</span><br><span class="line"><span class="comment">// 获取合适的返回值处理器：调用 if (handler.supportsReturnType(returnType))判断是否支持</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用处理器处理返回值</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ViewNameMethodReturnValueHandler#supportsReturnType：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; paramType = returnType.getParameterType();</span><br><span class="line">    <span class="comment">// 返回值是否是 void 或者是 CharSequence 字符序列，这里是字符序列</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>.class == paramType || CharSequence.class.isAssignableFrom(paramType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewNameMethodReturnValueHandler#handleReturnValue：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, </span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 返回值是字符串，是 return &quot;forward:/success&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> returnValue.toString();</span><br><span class="line">        <span class="comment">// 【把视图名称设置进入 ModelAndViewContainer 中】</span></span><br><span class="line">        mavContainer.setViewName(viewName);</span><br><span class="line">        <span class="comment">// 判断是否是重定向数据 `viewName.startsWith(&quot;redirect:&quot;)`</span></span><br><span class="line">        <span class="keyword">if</span> (isRedirectViewName(viewName)) &#123;</span><br><span class="line">            <span class="comment">// 如果是重定向，设置是重定向指令</span></span><br><span class="line">            mavContainer.setRedirectModelScenario(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (returnValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// should not happen</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="结果派发"><a href="#结果派发" class="headerlink" title="结果派发"></a>结果派发</h4><p>doDispatch() 中的 processDispatchResult：处理派发结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, </span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mv 是 ModelAndValue</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet#render：</p><ul><li><p><code>Locale locale = this.localeResolver.resolveLocale(request)</code>：国际化相关</p></li><li><p><code>String viewName = mv.getViewName()</code>：视图名字，是请求转发 forward:&#x2F;success（响应数据解析并存入 ModelAndView）</p></li><li><p><code>view = resolveViewName(viewName, mv.getModelInternal(), locale, request)</code>：解析视图</p><ul><li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：<strong>遍历所有的视图解析器</strong></p><p><code>view = viewResolver.resolveViewName(viewName, locale)</code>：根据视图名字解析视图，调用内容协商视图处理器 ContentNegotiatingViewResolver 的方法</p><ul><li><p><code>attrs = RequestContextHolder.getRequestAttributes()</code>：获取请求的相关属性信息</p></li><li><p><code>requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest())</code>：获取最佳匹配的媒体类型，函数内进行了匹配的逻辑</p></li><li><p><code>candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes)</code>：获取候选的视图对象</p><ul><li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：遍历所有的视图解析器</p></li><li><p><code>View view = viewResolver.resolveViewName(viewName, locale)</code>：<strong>解析视图</strong></p><p><code>AbstractCachingViewResolver#resolveViewName</code>：</p><ul><li><p><code>returnview = createView(viewName, locale)</code>：UrlBasedViewResolver#createView</p><p><strong>请求转发</strong>：实例为 InternalResourceView</p><ul><li><p><code>if (viewName.startsWith(FORWARD_URL_PREFIX))</code>：视图名字是否是 <strong><code>forward:</code></strong> 的前缀</p></li><li><p><code>forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length())</code>：名字截取前缀</p></li><li><p><code>view = new InternalResourceView(forwardUrl)</code>：新建 InternalResourceView  对象并返回</p></li><li><p><code>return applyLifecycleMethods(FORWARD_URL_PREFIX, view)</code>：Spring 中的初始化操作</p></li></ul><p><strong>重定向</strong>：实例为 RedirectView </p><ul><li><code>if (viewName.startsWith(REDIRECT_URL_PREFIX))</code>：视图名字是否是 <strong><code>redirect:</code></strong> 的前缀</li><li><code>redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length())</code>：名字截取前缀</li><li><code>RedirectView view = new RedirectView()</code>：新建 RedirectView 对象并返回</li></ul></li></ul></li></ul></li><li><p><code>bestView = getBestView(candidateViews, requestedMediaTypes, attrs)</code>：选出最佳匹配的视图对象</p></li></ul></li></ul></li><li><p><code>view.render(mv.getModelInternal(), request, response)</code>：<strong>页面渲染</strong></p><ul><li><p><code>mergedModel = createMergedOutputModel(model, request, response)</code>：把请求域中的数据封装到 model</p></li><li><p><code>prepareResponse(request, response)</code>：响应前的准备工作，设置一些响应头</p></li><li><p><code>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response)</code>：渲染输出的数据</p><p><code>getRequestToExpose(request)</code>：获取 Servlet 原生的方式</p><p><strong>请求转发 InternalResourceView 的逻辑：请求域中的数据不丢失</strong></p><ul><li><code>exposeModelAsRequestAttributes(model, request)</code>：暴露 model 作为请求域的属性<ul><li><code>model.forEach()</code>：遍历 Model 中的数据</li><li><code>request.setAttribute(name, value)</code>：<strong>设置到请求域中</strong></li></ul></li><li><code>exposeHelpers(request)</code>：自定义接口</li><li><code>dispatcherPath = prepareForRendering(request, response)</code>：确定调度分派的路径，此例是 &#x2F;success</li><li><code>rd = getRequestDispatcher(request, dispatcherPath)</code>：<strong>获取 Servlet 原生的 RequestDispatcher 实现转发</strong></li><li><code>rd.forward(request, response)</code>：实现请求转发</li></ul><p><strong>重定向 RedirectView 的逻辑：请求域中的数据会丢失</strong></p><ul><li><code>targetUrl = createTargetUrl(model, request)</code>：获取目标 URL<ul><li><code>enc = request.getCharacterEncoding()</code>：设置编码 UTF-8</li><li><code>appendQueryProperties(targetUrl, model, enc)</code>：添加一些属性，比如 <code>url + ?name=123&amp;&amp;age=324</code></li></ul></li><li><code>sendRedirect(request, response, targetUrl, this.http10Compatible)</code>：重定向<ul><li><code>response.sendRedirect(encodedURL)</code>：<strong>使用 Servlet 原生方法实现重定向</strong></li></ul></li></ul></li></ul></li></ul><hr><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>名称：@RequestBody</p><p>类型：形参注解</p><p>位置：处理器类中的方法形参前方</p><p>作用：将异步提交数据<strong>转换</strong>成标准请求参数格式，并赋值给形参<br>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">//控制层</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ajaxController&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ajaxController</span><span class="params">(<span class="meta">@RequestBody</span> String message)</span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解添加到 POJO  参数前方时，封装的异步提交数据按照 POJO  的属性格式进行关系映射<ul><li>POJO 中的属性如果请求数据中没有，属性值为 null</li><li>POJO 中没有的属性如果请求数据中有，不进行映射</li></ul></li><li>注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxPojoToController&quot;)</span></span><br><span class="line"><span class="comment">//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中</span></span><br><span class="line"><span class="keyword">public</span> String  <span class="title function_">ajaxPojoToController</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller pojo :&quot;</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxListToController&quot;)</span></span><br><span class="line"><span class="comment">//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式，数据将自动映射到集合参数</span></span><br><span class="line"><span class="keyword">public</span> String  <span class="title function_">ajaxListToController</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller list :&quot;</span>+userList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ajax.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page pageEncoding=&quot;UTF-8&quot; language=&quot;java&quot; contentType=&quot;text/html;UTF-8&quot; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>访问springmvc后台controller<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjaxPojo&quot;</span>&gt;</span>传递Json格式POJO<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjaxList&quot;</span>&gt;</span>传递Json格式List<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testAjax&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjax&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//发送异步调用</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求方式：POST请求</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求的地址</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;ajaxController&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求参数（也就是请求内容）</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;ajax message&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//响应正文类型</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求正文的MIME类型</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">contentType</span>:<span class="string">&quot;application/text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//为id=&quot;testAjaxPojo&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjaxPojo&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;ajaxPojoToController&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">contentType</span>:<span class="string">&quot;application/json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testAjaxList&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjaxList&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;<span class="comment">//.....</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;[&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;,&#123;&quot;name&quot;:&quot;Jockme&quot;,&quot;age&quot;:40&#125;]&#x27;</span>&#125;)&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>web.xml配置：请求响应章节请求中的web.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharacterEncodingFilter + DispatcherServlet</span><br></pre></td></tr></table></figure><p>spring-mvc.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller,domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h3><p>注解：@ResponseBody</p><p>作用：将 Java 对象转为 json 格式的数据</p><p>方法返回值为 POJO 时，自动封装数据成 Json 对象数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxReturnJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">ajaxReturnJson</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller return json pojo...&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jockme&quot;</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>方法返回值为 List 时，自动封装数据成 json 对象数组数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxReturnJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">ajaxReturnJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller return json list...&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    al.add(user1);</span><br><span class="line">    al.add(user2);</span><br><span class="line">    <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AJAX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为id=&quot;testAjaxReturnString&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnString&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送异步调用</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnString&quot;</span>,</span><br><span class="line">        <span class="comment">//回调函数</span></span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="comment">//打印返回结果</span></span><br><span class="line">            <span class="title function_">alert</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为id=&quot;testAjaxReturnJson&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnJson&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnJson&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="string">&#x27;name&#x27;</span>]+<span class="string">&quot; ,  &quot;</span>+data[<span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为id=&quot;testAjaxReturnJsonList&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnJsonList&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnJsonList&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(data);</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>跨域访问：当通过域名 A 下的操作访问域名 B 下的资源时，称为跨域访问，跨域访问时，会出现无法访问的现象</p><p>环境搭建：</p><ul><li>为当前主机添加备用域名<ul><li>修改 windows 安装目录中的 host 文件</li><li>格式： ip 域名</li></ul></li><li>动态刷新 DNS<ul><li>命令： ipconfig &#x2F;displaydns</li><li>命令： ipconfig &#x2F;flushdns</li></ul></li></ul><p>跨域访问支持：</p><ul><li>名称：@CrossOrigin</li><li>类型：方法注解 、 类注解</li><li>位置：处理器类中的方法上方或类上方</li><li>作用：设置当前处理器方法 &#x2F; 处理器类中所有方法支持跨域访问</li><li>范例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/cross&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//使用@CrossOrigin开启跨域访问</span></span><br><span class="line"><span class="comment">//标注在处理器方法上方表示该方法支持跨域访问</span></span><br><span class="line"><span class="comment">//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">cross</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller cross...&quot;</span> + request.getRequestURL());</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jockme&quot;</span>,<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>jsp 文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testCross&quot;</span>&gt;</span>跨域访问<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testCross&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testCross&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//发送异步调用</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;http://127.0.0.1/cross&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="title function_">alert</span>(<span class="string">&quot;跨域调用信息反馈:&quot;</span> + data[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&quot;,&quot;</span> + data[<span class="string">&#x27;age&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>拦截器（Interceptor）是一种动态拦截方法调用的机制</p><p>作用：</p><ol><li>在指定的方法调用前后执行预先设定后的的代码</li><li>阻止原始方法的执行</li></ol><p>核心原理：AOP 思想</p><p>拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  </p><p>拦截器和过滤器对比：</p><ol><li><p>归属不同： Filter 属于 Servlet 技术， Interceptor 属于 SpringMVC 技术</p></li><li><p>拦截内容不同： Filter 对所有访问进行增强， Interceptor 仅针对 SpringMVC 的访问进行增强  </p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-过滤器和拦截器的运行机制.png" style="zoom:67%;" /></li></ol><hr><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="前置处理"><a href="#前置处理" class="headerlink" title="前置处理"></a>前置处理</h4><p>原始方法之前运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                         Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>request：请求对象</li><li>response：响应对象</li><li>handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装<ul><li>handler：public String controller.InterceptorController.handleRun</li><li>handler.getClass()：org.springframework.web.method.HandlerMethod</li></ul></li></ul></li><li>返回值：<ul><li>返回值为 false，被拦截的处理器将不执行</li></ul></li></ul><hr><h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>原始方法运行后运行，如果原始方法被拦截，则不执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                       Object handler,</span></span><br><span class="line"><span class="params">                       ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整</li></ul><hr><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>拦截器最后执行的方法，无论原始方法是否执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response,</span></span><br><span class="line"><span class="params">                            Object handler,</span></span><br><span class="line"><span class="params">                            Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</li></ul><hr><h3 id="拦截配置"><a href="#拦截配置" class="headerlink" title="拦截配置"></a>拦截配置</h3><p>拦截路径：</p><ul><li><code>/**</code>：表示拦截所有映射</li><li><code>/* </code>：表示拦截所有&#x2F;开头的映射</li><li><code>/user/*</code>：表示拦截所有 &#x2F;user&#x2F; 开头的映射</li><li><code>/user/add*</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 add 开头的映射</li><li><code>/user/*All</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 All 结尾的映射</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启具体的拦截器的使用，可以配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置拦截器的拦截路径，支持*通配--&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/handleRun*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/b*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定具体的拦截器类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p><strong>责任链模式</strong>：责任链模式是一种行为模式</p><p>特点：沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务<br>优势：</p><ul><li>独立性：只关注当前节点的任务，对其他任务直接放行到下一节点</li><li>隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可</li><li>灵活性：可以任意修改链路结构动态新增或删减整体链路责任</li><li>解耦：将动态任务与原始任务解耦</li></ul><p>缺点：</p><ul><li>链路过长时，处理效率低下</li><li>可能存在节点上的循环引用现象，造成死循环，导致系统崩溃</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-多拦截器配置.png" style="zoom:67%;" /><hr><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>DispatcherServlet#doDispatch 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取映射器以及映射器的所有拦截器（运行原理部分详解了源码）</span></span><br><span class="line">        mappedHandler = getHandler(processedRequest);</span><br><span class="line">        <span class="comment">// 前置处理，返回 false 代表条件成立</span></span><br><span class="line">        <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="comment">//请求从这里直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有拦截器都返回 true，执行目标方法</span></span><br><span class="line">        mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</span><br><span class="line">        <span class="comment">// 倒序执行所有拦截器的后置处理方法</span></span><br><span class="line">        mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">//异常处理机制</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerExecutionChain#applyPreHandle：前置处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//遍历所有的拦截器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); i++) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="comment">//执行前置处理，如果拦截器返回 false，则条件成立，不在执行其他的拦截器，直接返回 false，请求直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">            triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerExecutionChain#applyPostHandle：后置处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet#triggerAfterCompletion 底层调用 HandlerExecutionChain#triggerAfterCompletion：</p><ul><li><p>前面的步骤有任何异常都会直接倒序触发 afterCompletion</p></li><li><p>页面成功渲染有异常，也会倒序触发 afterCompletion</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行异常处理的方法</span></span><br><span class="line">            interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器的执行流程：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-拦截器工作流程.png" style="zoom: 50%;" /><p>参考文章：<a href="https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU">https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU</a></p><hr><h3 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h3><ul><li><p>Contoller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handleRun&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务处理器运行------------main&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义拦截器需要实现 HandleInterceptor 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器需要实现HandleInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//处理器运行之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置运行----a1&quot;</span>);</span><br><span class="line">        <span class="comment">//返回值为false将拦截原始处理器的运行</span></span><br><span class="line">        <span class="comment">//如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理器运行之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                           HttpServletResponse response,</span></span><br><span class="line"><span class="params">                           Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置运行----b1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有拦截器的后置执行全部结束后，执行该操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler,</span></span><br><span class="line"><span class="params">                                Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成运行----c1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：三个方法的运行顺序为    preHandle → postHandle → afterCompletion，如果 preHandle 返回值为 false，三个方法仅运行preHandle</p></li><li><p>web.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharacterEncodingFilter + DispatcherServlet</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器：spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;interceptor,controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/handleRun&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：配置顺序为<strong>先配置执行位置，后配置执行类</strong></p></li></ul><hr><h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>异常处理器： <strong>HandlerExceptionResolver</strong> 接口</p><p>类继承该接口的以后，当开发出现异常后会执行指定的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                         Object handler,</span></span><br><span class="line"><span class="params">                                         Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常处理器正在执行中&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//定义异常现象出现后，反馈给用户查看的信息</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;出错啦！ &quot;</span>);</span><br><span class="line">        <span class="comment">//定义异常现象出现后，反馈给用户查看的页面</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据异常的种类不同，进行分门别类的管理，返回不同的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                         Object handler,</span></span><br><span class="line"><span class="params">                                         Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my exception is running ....&quot;</span> + ex);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="keyword">if</span>( ex <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( ex <span class="keyword">instanceof</span>  ArithmeticException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;算数运算异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;未知的异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟业务层发起调用产生了异常</span></span><br><span class="line"><span class="comment">//        int i = 1/0;</span></span><br><span class="line"><span class="comment">//        String str = null;</span></span><br><span class="line"><span class="comment">//        str.length();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>使用注解实现异常分类管理，开发异常处理器</p><p>@ControllerAdvice 注解：</p><ul><li><p>类型：类注解</p></li><li><p>位置：异常处理器类上方</p></li><li><p>作用：设置当前类为异常处理器类</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//声明该类是一个Controller的通知类，声明后该类就会被加载成异常处理器</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><p>@ExceptionHandler 注解：</p><ul><li><p>类型：方法注解</p></li><li><p>位置：异常处理器类中针对指定异常进行处理的方法上方</p></li><li><p>作用：设置指定异常的处理方式</p></li><li><p>说明：处理器方法可以设定多个</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//类中定义的方法携带@ExceptionHandler注解的会被作为异常处理器，后面添加实际处理的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doNullException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;空指针异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;all Exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>@ResponseStatus 注解：</p><ul><li><p>类型：类注解、方法注解</p></li><li><p>位置：异常处理器类、方法上方</p></li><li><p>参数：</p><p>value：出现错误指定返回状态码</p><p>reason：出现错误返回的错误信息</p></li></ul><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>web.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet + CharacterEncodingFilter</span><br></pre></td></tr></table></figure></li><li><p>ajax.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0);&quot;</span> id=<span class="string">&quot;testException&quot;</span>&gt;点击&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        $(<span class="string">&quot;#testException&quot;</span>).click(function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">                type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                url:<span class="string">&quot;save&quot;</span>,</span><br><span class="line">                <span class="comment">/*通过修改参数，激活自定义异常的出现*/</span></span><br><span class="line">                <span class="comment">// name长度低于8位出现业务异常</span></span><br><span class="line">                <span class="comment">// age小于0出现业务异常</span></span><br><span class="line">                <span class="comment">// age大于100出现系统异常</span></span><br><span class="line">                <span class="comment">// age类型如果无法匹配将转入其他类别异常</span></span><br><span class="line">                data:<span class="string">&#x27;&#123;&quot;name&quot;:&quot;JockSuperMan&quot;,&quot;age&quot;:&quot;-1&quot;&#125;&#x27;</span>,</span><br><span class="line">                dataType:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="comment">//回调函数</span></span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>java &#x2F; controller &#x2F; UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user controller save is running ...&quot;</span>);</span><br><span class="line">        <span class="comment">//对用户的非法操作进行判定，并包装成异常对象进行处理，便于统一管理</span></span><br><span class="line">        <span class="keyword">if</span>(user.getName().trim().length() &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;对不起，用户名长度不满足要求，请重新输入！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user.getAge() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;对不起，年龄必须是0到100之间的数字！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user.getAge() &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;服务器连接失败，请尽快检查处理！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;User&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        al.add(u1);al.add(u2);</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常继承RuntimeException，覆盖父类所有的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;覆盖父类所有的构造方法&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doBusinessException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        <span class="comment">//使用参数Model将要保存的数据传递到页面上，功能等同于ModelAndView</span></span><br><span class="line">        <span class="comment">//业务异常出现的消息要发送给用户查看</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSystemException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        <span class="comment">//系统异常出现的消息不要发送给用户查看，发送统一的信息给用户看</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;服务器出现问题，请联系管理员！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="comment">//将ex对象保存起来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h3><p>上传文件过程：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png"></p><p>MultipartResolver接口：</p><ul><li>MultipartResolver 接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装</li><li>MultipartResolver 接口底层实现类 CommonsMultipartResovler</li><li>CommonsMultipartResovler 并未自主实现文件上传下载对应的功能，而是调用了 apache 文件上传下载组件</li></ul><p>文件上传下载实现：</p><ul><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>页面表单 fileupload.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet + CharacterEncodingFilter</span><br></pre></td></tr></table></figure></li><li><p>控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!headerImg.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//保存到文件服务器，OSS服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> headerImg.getOriginalFilename();</span><br><span class="line">        headerImg.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:\\cache\\&quot;</span> + originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h3><p>MultipartFile 参数中封装了上传的文件的相关信息。</p><ol><li><p>文件命名问题， 获取上传文件名，并解析文件名与扩展名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.getOriginalFilename();</span><br></pre></td></tr></table></figure></li><li><p>文件名过长问题</p></li><li><p>文件保存路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath + <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file.exists()) file.mkdirs();</span><br></pre></td></tr></table></figure></li><li><p>重名问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID.toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/fileupload&quot;)</span></span><br><span class="line"><span class="comment">//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，表单名称与参数名相同</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileupload</span><span class="params">(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;file upload is running ...&quot;</span>+file);</span><br><span class="line"><span class="comment">//        MultipartFile参数中封装了上传的文件的相关信息</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getSize());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getBytes().length);</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getContentType());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getName());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getOriginalFilename());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isEmpty());</span></span><br><span class="line">        <span class="comment">//首先判断是否是空文件，也就是存储空间占用为0的文件</span></span><br><span class="line">        <span class="keyword">if</span>(!file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）</span></span><br><span class="line">            <span class="comment">//获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//设置保存的路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            <span class="comment">//保存文件的方法，通常文件名使用随机生成策略产生，避免文件名冲突问题</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试一次性上传多个文件</span></span><br><span class="line">        <span class="keyword">if</span>(!file1.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file1.getOriginalFilename();</span><br><span class="line">            <span class="comment">//可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            file1.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file1.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!file2.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file2.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            file2.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file2.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h3><p>StandardServletMultipartResolver 是文件上传解析器</p><p>DispatcherServlet#doDispatch：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是不是文件上传请求</span></span><br><span class="line">    processedRequest = checkMultipart(request);</span><br><span class="line">    <span class="comment">// 文件上传请求会对 request 进行包装，导致两者不相等，此处赋值为 true，代表已经被解析</span></span><br><span class="line">    multipartRequestParsed = (processedRequest != request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet#checkMultipart：</p><ul><li><code>if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request))</code>：判断是否是文件请求<ul><li><code>StandardServletMultipartResolver#isMultipart</code>：根据开头是否符合 multipart&#x2F;form-data 或者 multipart&#x2F;</li></ul></li><li><code>return this.multipartResolver.resolveMultipart(request)</code>：把请求封装成 StandardMultipartHttpServletRequest 对象</li></ul><p>开始执行 ha.handle() 目标方法进行数据的解析</p><ul><li><p>RequestPartMethodArgumentResolver#supportsParameter：支持解析文件上传数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数上有 @RequestPart 注解</span></span><br><span class="line">    <span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RequestPartMethodArgumentResolver#resolveArgument：解析参数数据，封装成 MultipartFile 对象</p><ul><li><code>RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class)</code>：获取注解的相关信息</li><li><code>String name = getPartName(parameter, requestPart)</code>：获取上传文件的名字</li><li><code>Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument()</code>：解析参数<ul><li><code>List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name)</code>：获取文件的所有数据</li></ul></li></ul></li><li><p><code>return doInvoke(args)</code>：解析完成执行自定义的方法，完成上传功能</p></li></ul><hr><h2 id="实用技术"><a href="#实用技术" class="headerlink" title="实用技术"></a>实用技术</h2><h3 id="校验框架"><a href="#校验框架" class="headerlink" title="校验框架"></a>校验框架</h3><h4 id="校验概述"><a href="#校验概述" class="headerlink" title="校验概述"></a>校验概述</h4><p>表单校验保障了数据有效性、安全性  </p><p>校验分类：客户端校验和服务端校验</p><ul><li>格式校验<ul><li>客户端：使用 js 技术，利用正则表达式校验</li><li>服务端：使用校验框架</li></ul></li><li>逻辑校验<ul><li>客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果</li><li>服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验</li></ul></li></ul><p>表单校验框架：</p><ul><li><p>JSR（Java Specification Requests）：Java 规范提案 </p></li><li><p>303：提供bean属性相关校验规则</p></li><li><p>JCP（Java Community Process）：Java社区</p></li><li><p>Hibernate框架中包含一套独立的校验框架hibernate-validator </p></li><li><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入校验的jsr303规范--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入校验框架实现技术--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><ul><li>tomcat7：搭配 hibernate-validator 版本 5.<em>.</em>.Final</li><li>tomcat8.5：搭配 hibernate-validator 版本 6.<em>.</em>.Final</li></ul><hr><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="开启校验"><a href="#开启校验" class="headerlink" title="开启校验"></a>开启校验</h5><p>名称：@Valid、@Validated</p><p>类型：形参注解</p><p>位置：处理器类中的实体类类型的方法形参前方</p><p>作用：设定对当前实体类类型参数进行校验</p><p>范例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Valid</span> Employee employee)</span> &#123;</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h5><p>名称：@NotNull</p><p>类型：属性注解等</p><p>位置：实体类属性上方</p><p>作用：设定当前属性校验规则</p><p>范例：每个校验规则所携带的参数不同，根据校验规则进行相应的调整，具体的校验规则查看对应的校验框架进行获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line"><span class="comment">//Errors对象用于封装校验结果，如果不满足校验规则，对应的校验结果封装到该对象中，包含校验的属性名和校验不通过返回的消息</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Valid</span> Employee employee, Errors errors, Model model)</span>&#123;</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">    <span class="comment">//判定Errors对象中是否存在未通过校验的字段</span></span><br><span class="line">    <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">        <span class="keyword">for</span>(FieldError error : errors.getFieldErrors())&#123;</span><br><span class="line">        <span class="comment">//将校验结果添加到Model对象中，用于页面显示，返回json数据即可</span></span><br><span class="line">            model.addAttribute(error.getField(),error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当出现未通过校验的字段时，跳转页面到原始页面，进行数据回显</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addemployee.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示，页面获取后台封装的校验结果信息  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/addemployee&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    员工姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    员工年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;age&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="多规则校验"><a href="#多规则校验" class="headerlink" title="多规则校验"></a>多规则校验</h4><ul><li><p>同一个属性可以添加多个校验器  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请输入年龄&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 60,message = &quot;年龄最大值60&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18,message = &quot;年龄最小值18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">//员工年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三种判定空校验器的区别<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%89%E7%A7%8D%E5%88%A4%E5%AE%9A%E7%A9%BA%E6%A3%80%E9%AA%8C%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p></li></ul><hr><h4 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h4><p>名称：@Valid</p><p>类型：属性注解</p><p>位置：实体类中的引用类型属性上方</p><p>作用：设定当前应用类型属性中的属性开启校验</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//嵌套校验的实体中，对每个属性正常添加校验规则即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请输入省份名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String provinceName;<span class="comment">//省份名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请输入邮政编码&quot;)</span></span><br><span class="line">    <span class="meta">@Size(max = 6,min = 6,message = &quot;邮政编码由6位组成&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zipCode;<span class="comment">//邮政编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h4><p>分组校验的介绍</p><ul><li>同一个模块，根据执行的业务不同，需要校验的属性会有不同<ul><li>新增用户</li><li>修改用户</li></ul></li><li>对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别<ul><li>定义组（通用）</li><li>为属性设置所属组，可以设置多个</li><li>开启组校验</li></ul></li></ul><p>domain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于设定分组校验中的组名，当前接口仅提供字节码，用于识别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupOne</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请输入年龄&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="meta">@Max(value = 60,message = &quot;年龄最大值60&quot;)</span><span class="comment">//不加Group的校验不生效</span></span><br><span class="line">    <span class="meta">@Min(value = 18,message = &quot;年龄最小值18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">//员工年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Validated(&#123;GroupA.class&#125;)</span> Employee employee, Errors errors, Model m)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">            List&lt;FieldError&gt; fieldErrors = errors.getFieldErrors();</span><br><span class="line">            System.out.println(fieldErrors.size());</span><br><span class="line">            <span class="keyword">for</span>(FieldError error : fieldErrors)&#123;</span><br><span class="line">                m.addAttribute(error.getField(),error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;addemployee.jsp&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsp：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/addemployee&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>&lt;%--页面使用$&#123;&#125;获取后台传递的校验信息--%&gt;</span><br><span class="line">    员工姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    员工年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;age&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    &lt;%--注意，引用类型的校验未通过信息不是通过对象进行封装的，直接使用对象名.属性名的格式作为整体属性字符串进行保存的，和使用者的属性传递方式有关，不具有通用性，仅适用于本案例--%&gt;</span><br><span class="line">    省：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address.provinceName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;requestScope[&#x27;address.provinceName&#x27;]&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">/form&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok 用标签方式代替构造器、getter&#x2F;setter、toString() 等方法</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下载插件：IDEA 中 File → Settings → Plugins，搜索安装 Lombok 插件</p><p>常用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span><span class="comment">// 无参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">// 全参构造</span></span><br><span class="line"><span class="meta">@Data</span><span class="comment">// set + get</span></span><br><span class="line"><span class="meta">@ToString</span><span class="comment">// toString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">// hashConde + equals</span></span><br></pre></td></tr></table></figure><p>简化日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring!&quot;</span> + <span class="string">&quot;你好：&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介</summary>
      
    
    
    
    <category term="Spring全家桶" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="SSM框架" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SSM%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring全家桶" scheme="http://example.com/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://example.com/2022/08/17/Mybatis/"/>
    <id>http://example.com/2022/08/17/Mybatis/</id>
    <published>2022-08-17T15:58:10.788Z</published>
    <updated>2022-08-17T16:00:33.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-ORM%E4%BB%8B%E7%BB%8D.png"></p><p><strong>MyBatis</strong>：</p><ul><li><p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程。</p></li><li><p>MyBatis 通过 XML 或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句。</p></li><li><p>MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC 底层 API 的调用细节，使我们不用操作 JDBC API，就可以完成对数据库的持久化操作。</p></li></ul><p>MyBatis 官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p><p>参考视频：<a href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Resources：加载资源的工具类</p><ul><li><code>InputStream getResourceAsStream(String fileName)</code>：通过类加载器返回指定资源的字节流<ul><li>参数 fileName 是放在 src 的核心配置文件名：MyBatisConfig.xml</li></ul></li></ul><p>SqlSessionFactoryBuilder：构建器，用来获取 SqlSessionFactory 工厂对象</p><ul><li><code>SqlSessionFactory build(InputStream is)</code>：通过指定资源的字节输入流获取 SqlSession 工厂对象</li></ul><p>SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口</p><ul><li><code>SqlSession openSession()</code>：获取 SqlSession 构建者对象，并开启手动提交事务</li><li><code>SqlSession openSession(boolean)</code>：获取 SqlSession 构建者对象，参数为 true 开启自动提交事务</li></ul><p>SqlSession：构建者对象接口，用于执行 SQL、管理事务、接口代理</p><ul><li>SqlSession <strong>代表和数据库的一次会话</strong>，用完必须关闭</li><li>SqlSession 和 Connection 一样都是非线程安全，每次使用都应该去获取新的对象</li></ul><p>注：<strong>update 数据需要提交事务，或开启默认提交</strong></p><p>SqlSession 常用 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>List<E> selectList(String statement,Object parameter)</td><td>执行查询语句，返回List集合</td></tr><tr><td>T selectOne(String statement,Object parameter)</td><td>执行查询语句，返回一个结果对象</td></tr><tr><td>int insert(String statement,Object parameter)</td><td>执行新增语句，返回影响行数</td></tr><tr><td>int update(String statement,Object parameter)</td><td>执行删除语句，返回影响行数</td></tr><tr><td>int delete(String statement,Object parameter)</td><td>执行修改语句，返回影响行数</td></tr><tr><td>void commit()</td><td>提交事务</td></tr><tr><td>void rollback()</td><td>回滚事务</td></tr><tr><td>T getMapper(Class<T> cls)</td><td>获取指定接口的代理实现类对象</td></tr><tr><td>void close()</td><td>释放资源</td></tr></tbody></table><hr><h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h3><p>映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句，放在 src 目录下</p><p>命名：StudentMapper.xml</p><ul><li><p>映射配置文件的文件头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>根标签：</p><ul><li><mapper>：核心根标签</li><li>namespace：属性，名称空间</li></ul></li><li><p>功能标签：</p><ul><li>&lt; select &gt;：查询功能标签</li><li><insert>：新增功能标签</li><li><update>：修改功能标签</li><li><delete>：删除功能标签<ul><li>id：属性，唯一标识，配合名称空间使用</li><li>resultType：指定结果映射对象类型，和对应的方法的返回值类型（全限定名）保持一致，但是如果返回值是 List 则和其泛型保持一致</li><li>parameterType：指定参数映射对象类型，必须和对应的方法的参数类型（全限定名）保持一致</li><li><strong>statementType</strong>：可选 STATEMENT，PREPARED 或 CALLABLE，默认值：PREPARED<ul><li>STATEMENT：直接操作 SQL，使用 Statement 不进行预编译，获取数据：$</li><li>PREPARED：预处理参数，使用 PreparedStatement 进行预编译，获取数据：#</li><li>CALLABLE：执行存储过程，CallableStatement</li></ul></li></ul></li></ul></li><li><p>参数获取方式：</p><ul><li><p>SQL 获取参数：<code>#&#123;属性名&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;StudentMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectById&quot; resultType=&quot;student&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">SELECT * FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;mapper/&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>强烈推荐官方文档：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p><hr><h3 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h3><p>核心配置文件包含了 MyBatis 最核心的设置和属性信息，如数据库的连接、事务、连接池信息等</p><p>命名：MyBatisConfig.xml</p><ul><li><p>核心配置文件的文件头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>根标签：</p><ul><li><configuration>：核心根标签</li></ul></li><li><p>引入连接配置文件：</p><ul><li><p><properties>： 引入数据库连接配置文件标签</p><ul><li>resource：属性，指定配置文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>调整设置</p><ul><li><settings>：可以改变 Mybatis 运行时行为</li></ul></li><li><p>起别名：</p><ul><li><p><typeAliases>：为全类名起别名的父标签</p><ul><li><p><typeAlias>：为全类名起别名的子标签</p><ul><li>type：指定全类名      </li><li>alias：指定别名</li></ul></li><li><p><package>：为指定包下所有类起别名的子标签，别名就是类名，首字母小写</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--起别名--&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;typeAlias type=&quot;bean.Student&quot; alias=&quot;student&quot;/&gt;</span><br><span class="line">&lt;package name=&quot;com.seazean.bean&quot;/&gt;</span><br><span class="line">&lt;!--二选一--&gt;</span><br><span class="line">&lt;/typeAliase&gt;</span><br></pre></td></tr></table></figure></li><li><p>自带别名：</p><table><thead><tr><th>别名</th><th>数据类型</th></tr></thead><tbody><tr><td>string</td><td>java.lang.String</td></tr><tr><td>long</td><td>java.lang.Lang</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td></tr><tr><td>….</td><td>……</td></tr></tbody></table></li></ul></li><li><p>配置环境，可以配置多个标签</p><ul><li><environments>：配置数据库环境标签，default 属性指定哪个 environment</li><li><environment>：配置数据库环境子标签，id 属性是唯一标识，与 default 对应</li><li><transactionManager>：事务管理标签，type 属性默认 JDBC 事务</li><li><dataSoure>：数据源标签<ul><li>type 属性：POOLED 使用连接池（MyBatis 内置），UNPOOLED 不使用连接池</li></ul></li><li><property>：数据库连接信息标签。<ul><li>name 属性取值：driver，url，username，password</li><li>value 属性取值：与 name 对应</li></ul></li></ul></li><li><p>引入映射配置文件</p><ul><li><mappers>：引入映射配置文件标签</li><li><mapper>：引入映射配置文件子标签<ul><li>resource：属性指定映射配置文件的名称</li><li>url：引用网路路径或者磁盘路径下的 sql 映射文件</li><li>class：指定映射配置类</li></ul></li><li><package>：批量注册</li></ul></li></ul><p>参考官方文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p><hr><h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p><strong>#{}：</strong>占位符，传入的内容会作为字符串<strong>加上引号</strong>，以<strong>预编译</strong>的方式传入，将 sql 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值，有效的防止 SQL 注入，提高系统安全性</p><p><strong>${}：</strong>拼接符，传入的内容会<strong>直接替换</strong>拼接，不会加上引号，可能存在 sql 注入的安全隐患</p><ul><li><p>能用 #{} 的地方就用 #{}，不用或少用 ${}</p></li><li><p>必须使用 ${} 的情况：</p><ul><li>表名作参数时，如：<code>SELECT * FROM $&#123;tableName&#125;</code></li><li>order by 时，如：<code>SELECT * FROM t_user ORDER BY $&#123;columnName&#125;</code></li></ul></li><li><p>sql 语句使用 #{}，properties 文件内容获取使用 ${}</p></li></ul><hr><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>在日常开发过程中，排查问题时需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，就可以借助 log4j 的功能来实现执行信息的输出。</p><ul><li><p>在核心配置文件根标签内配置 log4j</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置LOG4J--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 src 目录下创建 log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#输出到日志文件</span></span><br><span class="line"><span class="comment">  #log4j.appender.file=org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.File=../logs/iask.log</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125;  %l  %m%n</span></span><br></pre></td></tr></table></figure></li><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StudentMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Student <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>config.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db1</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>MyBatisConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入数据库连接的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置LOG4J--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;bean.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;student&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;package name=&quot;bean&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据库环境，可以多个环境，default指定哪个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--id属性唯一标识--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理，type属性，默认JDBC事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据源信息   type属性连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--property获取数据库连接的配置信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入映射配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;StudentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>StudentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        UPDATE student SET name = #&#123;name&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制层测试代码：根据 id 查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectById</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行映射配置文件中的sql语句，并接收结果</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;StudentMapper.selectById&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.处理结果</span></span><br><span class="line">    System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制层测试代码：新增功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行映射配置文件中的sql语句，并接收结果</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;周七&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;StudentMapper.insert&quot;</span>, stu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.提交事务</span></span><br><span class="line">    <span class="comment">//sqlSession.commit();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.处理结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>三种方式实现批量操作：</p><ul><li><p><settings> 标签属性：这种方式属于<strong>全局批量</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>defaultExecutorType：配置默认的执行器</p><ul><li>SIMPLE 就是普通的执行器（默认，每次执行都要重新设置参数）</li><li>REUSE 执行器会重用预处理语句（只预设置一次参数，多次执行）</li><li>BATCH 执行器不仅重用语句还会执行批量更新（只针对<strong>修改操作</strong>）</li></ul></li><li><p>SqlSession <strong>会话内批量</strong>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以执行批量操作的sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> <span class="title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量：（预编译sql一次==&gt;设置参数===&gt;10000次===&gt;执行1次（类似管道））</span></span><br><span class="line">        <span class="comment">// 非批量：（预编译sql=设置参数=执行）==》10000   耗时更多</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (end - start));</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring 配置文件方式（applicationContext.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个可以进行批量执行的sqlSession  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="代理开发"><a href="#代理开发" class="headerlink" title="代理开发"></a>代理开发</h2><h3 id="代理规则"><a href="#代理规则" class="headerlink" title="代理规则"></a>代理规则</h3><p>分层思想：控制层（controller）、业务层（service）、持久层（dao）</p><p>调用流程：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p><p>传统方式实现 DAO 层，需要写接口和实现类。采用 Mybatis 的代理开发方式实现 DAO 层的开发，只需要编写 Mapper 接口（相当于 Dao 接口），由 Mybatis 框架根据接口定义创建接口的<strong>动态代理对象</strong></p><p>接口开发方式：</p><ol><li>定义接口</li><li>操作数据库，MyBatis 框架根据接口，通过动态代理的方式生成代理对象，负责数据库的操作</li></ol><p>Mapper 接口开发需要遵循以下规范：</p><ul><li><p>Mapper.xml 文件中的 namespace 与 DAO 层 mapper 接口的全类名相同</p></li><li><p>Mapper.xml 文件中的增删改查标签的id属性和 DAO 层 Mapper 接口方法名相同</p></li><li><p>Mapper.xml 文件中的增删改查标签的 parameterType 属性和 DAO 层 Mapper 接口方法的参数相同</p></li><li><p>Mapper.xml 文件中的增删改查标签的 resultType 属性和 DAO 层 Mapper 接口方法的返回值相同</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0DAO%E5%B1%82.png"></p></li></ul><hr><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过动态代理开发模式，只编写一个接口不写实现类，通过 <strong>getMapper()</strong> 方法最终获取到 MapperProxy 代理对象，而这个代理对象是 MyBatis 使用了 JDK 的动态代理技术生成的</p><p>动态代理实现类对象在执行方法时最终调用了 <strong>MapperMethod.execute()</strong> 方法，这个方法中通过 switch case 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 <strong>SqlSession 方式来执行增删改查</strong></p><ul><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Student <span class="title function_">selectById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        is = Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        sqlSession = s.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.通过实现类对象调用方法，接收结果</span></span><br><span class="line">        stu = mapper.selectById(id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.getMessage();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><h3 id="相关标签"><a href="#相关标签" class="headerlink" title="相关标签"></a>相关标签</h3><p><resultType>：返回结果映射对象类型，和对应方法的返回值类型保持一致，但是如果返回值是 List 则和其泛型保持一致</p><p><resultMap>：返回一条记录的 Map，key 是列名，value 是对应的值，用来配置<strong>字段和对象属性</strong>的映射关系标签，结果映射（和 resultType 二选一）</p><ul><li>id 属性：唯一标识</li><li>type 属性：实体对象类型</li><li>autoMapping 属性：结果自动映射</li></ul><p><resultMap> 内的核心配置文件标签：</p><ul><li><p><id>：配置主键映射关系标签</p></li><li><p><result>：配置非主键映射关系标签</p><ul><li>column 属性：表中字段名称</li><li>property 属性： 实体对象变量名称</li></ul></li><li><p><association>：配置被包含<strong>单个对象</strong>的映射关系标签，嵌套封装结果集（多对一、一对一）</p><ul><li>property 属性：被包含对象的变量名，要进行映射的属性名</li><li>javaType 属性：被包含对象的数据类型，要进行映射的属性的类型（Java 中的 Bean 类）</li><li>select 属性：加载复杂类型属性的映射语句的 ID，会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句</li></ul></li><li><p><collection>：配置被包含<strong>集合对象</strong>的映射关系标签，嵌套封装结果集（一对多、多对多）</p><ul><li>property 属性：被包含集合对象的变量名</li><li>ofType 属性：集合中保存的对象数据类型</li></ul></li><li><p><discriminator>：鉴别器，用来判断某列的值，根据得到某列的不同值做出不同自定义的封装行为</p></li></ul><p>自定义封装规则可以将数据库中比较复杂的数据类型映射为 JavaBean 中的属性</p><hr><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>子查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">    <span class="comment">// set + get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>循环引用：通过缓存解决</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;blog&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>/&gt;</span><span class="comment">&lt;!--y--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">&lt;/resultMap</span><br></pre></td></tr></table></figure><hr><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一实现：</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(20),</span><br><span class="line">age INT</span><br><span class="line">);</span><br><span class="line">INSERT INTO person VALUES (NULL,&#x27;张三&#x27;,23),(NULL,&#x27;李四&#x27;,24),(NULL,&#x27;王五&#x27;,25);</span><br><span class="line"></span><br><span class="line">CREATE TABLE card(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">number VARCHAR(30),</span><br><span class="line">pid INT,</span><br><span class="line">CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;23456&#x27;,2),(NULL,&#x27;34567&#x27;,3);</span><br></pre></td></tr></table></figure></li><li><p>bean 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String number;  <span class="comment">//身份证号</span></span><br><span class="line">    <span class="keyword">private</span> Person p;       <span class="comment">//所属人的对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//人的年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件 OneToOneMapper.xml，MyBatisConfig.xml 需要引入（可以把 bean 包下起别名）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToOneMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置字段和实体对象属性的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--column 表中字段名称，property 实体对象变量名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            association：配置被包含对象的映射关系</span></span><br><span class="line"><span class="comment">            property：被包含对象的变量名</span></span><br><span class="line"><span class="comment">            javaType：被包含对象的数据类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;p&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;bean.Person&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToOne&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>核心配置文件 MyBatisConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mappers引入映射配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;one_to_one/OneToOneMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;one_to_many/OneToManyMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;many_to_many/ManyToManyMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取OneToOneMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">OneToOneMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToOneMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Card&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (Card c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>一对多实现：</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE classes(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO classes VALUES (NULL,&#x27;程序一班&#x27;),(NULL,&#x27;程序二班&#x27;)</span><br><span class="line"></span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(30),</span><br><span class="line">age INT,</span><br><span class="line">cid INT,</span><br><span class="line">CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,1),(NULL,&#x27;李四&#x27;,24,1),(NULL,&#x27;王五&#x27;,25,2);</span><br></pre></td></tr></table></figure></li><li><p>bean 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Classes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//班级名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students; <span class="comment">//班级中所有学生对象</span></span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//学生年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--collection：配置被包含的集合对象映射关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;bean.Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sage&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToMany&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码实现片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.获取OneToManyMapper接口的实现类对象</span></span><br><span class="line"><span class="type">OneToManyMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToManyMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">List&lt;Classes&gt; classes = mapper.selectAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.处理结果</span></span><br><span class="line"><span class="keyword">for</span> (Classes cls : classes) &#123;</span><br><span class="line">    System.out.println(cls.getId() + <span class="string">&quot;,&quot;</span> + cls.getName());</span><br><span class="line">    List&lt;Student&gt; students = cls.getStudents();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\t&quot;</span> + student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>学生课程例子，中间表不需要 bean 实体类</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE course(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu_cr(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sid INT,</span><br><span class="line">cid INT,</span><br><span class="line">CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),</span><br><span class="line">CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO stu_cr VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);</span><br></pre></td></tr></table></figure></li><li><p>bean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//学生年龄</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;   <span class="comment">// 学生所选择的课程集合</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//课程名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;ManyToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;manyToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Bean.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sage&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;courses&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Bean.Course&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;manyToMany&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h3><p>需求：如果查询结果是女性，则把部门信息查询出来，否则不查询 ；如果是男性，把 last_name 这一列的值赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    column：指定要判断的列名 </span></span><br><span class="line"><span class="comment">    javaType：列值对应的java类型</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 女生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType不可缺少，也可以使用resutlMap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;com.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 男生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h4 id="两种加载"><a href="#两种加载" class="headerlink" title="两种加载"></a>两种加载</h4><p>立即加载：只要调用方法，马上发起查询</p><p>延迟加载：在需要用到数据时才进行加载，不需要用到数据时就不加载数据，延迟加载也称懒加载</p><p>优点： 先从单表查询，需要时再从关联表去关联查询，提高数据库性能，因为查询单表要比关联查询多张表速度要快，节省资源</p><p>坏处：只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降</p><p>核心配置文件：</p><table><thead><tr><th>标签名</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载，特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td><td>false</td></tr><tr><td>aggressiveLazyLoading</td><td>开启时，任一方法的调用都会加载该对象的所有延迟加载属性。否则每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods）</td><td>false</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="assocation"><a href="#assocation" class="headerlink" title="assocation"></a>assocation</h4><p>分布查询：先按照身份 id 查询所属人的 id、然后根据所属人的 id 去查询人的全部信息，这就是分步查询</p><ul><li><p>映射配置文件 OneToOneMapper.xml </p><p>一对一映射：</p><ul><li>column 属性表示给要调用的其它的 select 标签传入的参数</li><li>select 属性表示调用其它的 select 标签</li><li>fetchType&#x3D;”lazy” 表示延迟加载（局部配置，只有配置了这个的地方才会延迟加载）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToOneMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置字段和实体对象属性的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;p&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;bean.Person&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> </span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;one_to_one.PersonMapper.findPersonByid&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--需要配置新的映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToOne&quot;</span>&gt;</span> </span><br><span class="line">        SELECT * FROM card <span class="comment">&lt;!--查询全部，负责根据条件直接全部加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>PersonMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;one_to_one.PersonMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findPersonByid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM person WHERE id=#&#123;pid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>PersonMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findPersonByid</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">OneToOneMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToOneMapper.class);</span><br><span class="line">        <span class="comment">// 调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Card&gt; list = mapper.selectAll();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不能遍历，遍历就是相当于使用了该数据，需要加载，不遍历就是没有使用。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p>同样在一对多关系配置的 <collection> 结点中配置延迟加载策略，<collection> 结点中也有 select 属性和 column 属性</p><ul><li><p>映射配置文件 OneToManyMapper.xml</p><p>一对多映射：</p><ul><li>column 是用于指定使用哪个字段的值作为条件查询</li><li>select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--collection：配置被包含的集合对象映射关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;bean.Student&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;one_to_one.StudentMapper.findStudentByCid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToMany&quot;</span>&gt;</span></span><br><span class="line">      SELECT * FROM classes</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>StudentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;one_to_one.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findPersonByCid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM person WHERE cid=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>注解可以简化开发操作，省略映射配置文件的编写</p><p>常用注解：</p><ul><li>@Select(“查询的 SQL 语句”)：执行查询操作注解</li><li>@Insert(“插入的 SQL 语句”)：执行新增操作注解</li><li>@Update(“修改的 SQL 语句”)：执行修改操作注解</li><li>@Delete(“删除的 SQL 语句”)：执行删除操作注解</li></ul><p>参数注解：</p><ul><li>@Param：当 SQL 语句需要<strong>多个（大于1）参数</strong>时，用来指定参数的对应规则</li></ul><p>核心配置文件配置映射关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;使用了注解的Mapper接口所在包&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;包名.Mapper名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本增删改查：</p><ul><li><p>创建 Mapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 MyBatis 的核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>bean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">    <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">    List&lt;Student&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.处理结果</span></span><br><span class="line">    <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><p>实现复杂关系映射之前我们可以在映射文件中通过配置 <resultMap> 来实现，使用注解开发后，可以使用 @Results 注解，@Result 注解，@One 注解，@Many 注解组合完成复杂关系的配置</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Results</td><td>代替 <resultMap> 标签，注解中使用单个 @Result 注解或者 @Result 集合<br/>使用格式：@Results({ @Result(), @Result() })或@Results({ @Result() })</td></tr><tr><td>@Result</td><td>代替&lt; id&gt; 和 <result> 标签，@Result 中属性介绍：<br />column：数据库的列名      property：封装类的变量名<br />one：需要使用 @One 注解（@Result(one &#x3D; @One)）<br />Many：需要使用 @Many 注解（@Result(many&#x3D; @Many)）</td></tr><tr><td>@One(一对一)</td><td>代替 <association> 标签，多表查询的关键，用来指定子查询返回单一对象<br/>select：指定调用 Mapper 接口中的某个方法<br />使用格式：@Result(column&#x3D;””, property&#x3D;””, one&#x3D;@One(select&#x3D;””))</td></tr><tr><td>@Many(多对一)</td><td>代替 <collection> 标签，多表查询的关键，用来指定子查询返回对象集合<br />select：指定调用 Mapper 接口中的某个方法<br />使用格式：@Result(column&#x3D;””, property&#x3D;””, many&#x3D;@Many(select&#x3D;””))</td></tr></tbody></table><hr><h4 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h4><p>身份证对人</p><ul><li><p>PersonMapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Person <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CardMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM card&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;number&quot;,property = &quot;number&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;p&quot;,             // 被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = Person.class,    // 被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;pid&quot;,  // 根据查询出的card表中的pid字段来查询person表</span></span><br><span class="line"><span class="meta">                     /* </span></span><br><span class="line"><span class="meta">                     one、@One 一对一固定写法</span></span><br><span class="line"><span class="meta">                        select属性：指定调用哪个接口中的哪个方法</span></span><br><span class="line"><span class="meta">                     */</span></span><br><span class="line"><span class="meta">                    one = @One(select = &quot;one_to_one.PersonMapper.selectById&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Card&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类（详细代码参考单表操作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加载核心配置文件</span></span><br><span class="line"><span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line"><span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">CardMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CardMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Card&gt; list = mapper.selectAll();</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h4><p>班级和学生</p><ul><li><p>StudentMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据cid查询student表  cid是外键约束列</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectByCid</span><span class="params">(Integer cid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassesMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassesMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM classes&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;students&quot;,  //被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = List.class,  //被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;id&quot;,          //根据id字段查询student表</span></span><br><span class="line"><span class="meta">                    many = @Many(select = &quot;one_to_many.StudentMapper.selectByCid&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Classes&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">ClassesMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ClassesMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Classes&gt; classes = mapper.selectAll();</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h4><p>学生和课程</p><ul><li><p>SQL 查询语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id</span><br><span class="line">SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;</span><br></pre></td></tr></table></figure></li><li><p>CourseMapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CourseMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据学生id查询所选课程</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Course&gt; <span class="title function_">selectBySid</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StudentMapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;name&quot;,property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;age&quot;,property = &quot;age&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;courses&quot;,    //被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = List.class,  //被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;id&quot;, //根据查询出的student表中的id字段查询中间表和课程表</span></span><br><span class="line"><span class="meta">                    many = @Many(select = &quot;many_to_many.CourseMapper.selectBySid&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Student&gt; students = mapper.selectAll();</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><h3 id="缓存概述"><a href="#缓存概述" class="headerlink" title="缓存概述"></a>缓存概述</h3><p>缓存：缓存就是一块内存空间，保存临时数据</p><p>作用：将数据源（数据库或者文件）中的数据读取出来存放到缓存中，再次获取时直接从缓存中获取，可以减少和数据库交互的次数，提升程序的性能</p><p>缓存适用：</p><ul><li>适用于缓存的：经常查询但不经常修改的，数据的正确与否对最终结果影响不大的</li><li>不适用缓存的：经常改变的数据 , 敏感数据（例如：股市的牌价，银行的汇率，银行卡里面的钱）等等</li></ul><p>缓存类别：</p><ul><li>一级缓存：SqlSession 级别的缓存，又叫本地会话缓存，自带的（不需要配置），一级缓存的生命周期与 SqlSession 一致。在操作数据库时需要构造 SqlSession 对象，<strong>在对象中有一个数据结构（HashMap）用于存储缓存数据</strong>，不同的 SqlSession 之间的缓存数据区域是互相不影响的</li><li>二级缓存：mapper（namespace）级别的缓存，二级缓存的使用，需要手动开启（需要配置）。多个 SqlSession 去操作同一个 Mapper 的 SQL 可以共用二级缓存，二级缓存是跨 SqlSession 的</li></ul><p>开启缓存：配置核心配置文件中 <settings> 标签</p><ul><li>cacheEnabled：true 表示全局性地开启所有映射器配置文件中已配置的任何缓存，默认 true</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7342498.html">https://www.cnblogs.com/ysocean/p/7342498.html</a></p><hr><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是 SqlSession 级别的缓存</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-一级缓存.png" style="zoom: 67%;" /><p>工作流程：第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息，得到用户信息，将用户信息存储到一级缓存中；第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</p><p>一级缓存的失效：</p><ul><li>SqlSession 不同</li><li>SqlSession 相同，查询条件不同时（还未缓存该数据）</li><li>SqlSession 相同，手动清除了一级缓存，调用 <code>sqlSession.clearCache()</code></li><li>SqlSession 相同，执行 commit 操作或者执行插入、更新、删除，清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，<strong>避免脏读</strong></li></ul><p>Spring 整合 MyBatis 后，一级缓存作用：</p><ul><li>未开启事务的情况，每次查询 Spring 都会创建新的 SqlSession，因此一级缓存失效</li><li>开启事务的情况，Spring 使用 ThreadLocal 获取当前资源绑定同一个 SqlSession，因此此时一级缓存是有效的</li></ul><p>测试一级缓存存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFirstLevelCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取sqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionFactoryUtils.openSession();</span><br><span class="line">    <span class="comment">//2. 通过sqlSession对象获取UserDao接口的代理对象</span></span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="comment">//3. 调用UserDao接口的代理对象的findById方法获取信息</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userDao1.findById(<span class="number">1</span>);</span><br><span class="line">System.out.println(user1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sqlSession.clearCache() 清空缓存</span></span><br><span class="line">    </span><br><span class="line">   <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.测试两次结果是否一样</span></span><br><span class="line">    System.out.println(user1 == user2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 提交事务关闭资源</span></span><br><span class="line">    SqlSessionFactoryUtils.commitAndClose(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>二级缓存是 mapper 的缓存，只要是同一个命名空间（namespace）的 SqlSession 就共享二级缓存的内容，并且可以操作二级缓存</p><p>作用：作用范围是整个应用，可以跨线程使用，适合缓存一些修改较少的数据</p><p>工作流程：一个会话查询数据，这个数据就会被放在当前会话的一级缓存中，如果<strong>会话关闭或提交</strong>一级缓存中的数据会保存到二级缓存</p><p>二级缓存的基本使用：</p><ol><li><p>在 MyBatisConfig.xml 文件开启二级缓存，<strong>cacheEnabled 默认值为 true</strong>，所以这一步可以省略不配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 Mapper 映射文件</p><p><code>&lt;cache&gt;</code> 标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启user支持二级缓存--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;6000&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span> <span class="comment">&lt;!--则表示所有属性使用默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>eviction（清除策略）：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象，默认</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象</li></ul><p>flushInterval（刷新间隔）：可以设置为任意的正整数， 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</p><p>size（引用数目）：缓存存放多少元素，默认值是 1024</p><p>readOnly（只读）：可以被设置为 true 或 false</p><ul><li>只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，促进了性能提升</li><li>可读写的缓存会（通过序列化）返回缓存对象的拷贝， 速度上会慢一些，但是更安全，因此默认值是 false</li></ul><p>type：指定自定义缓存的全类名，实现 Cache 接口即可</p></li><li><p>要进行二级缓存的类必须实现 java.io.Serializable 接口，可以使用序列化方式来保存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><ol><li><p>select 标签的 useCache 属性</p><p>映射文件中的 <code>&lt;select&gt;</code> 标签中设置 <code>useCache=&quot;true&quot;</code> 代表当前 statement 要使用二级缓存（默认）</p><p>注意：如果每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>每个增删改标签都有 flushCache 属性，默认为 true，代表在<strong>执行增删改之后就会清除一、二级缓存</strong>，保证缓存的一致性；而查询标签默认值为 false，所以查询不会清空缓存</p></li><li><p>localCacheScope：本地缓存作用域，<settings> 中的配置项，默认值为 SESSION，当前会话的所有数据保存在会话缓存中，设置为 STATEMENT 禁用一级缓存</p></li></ol><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>事务提交二级缓存才生效：DefaultSqlSession 调用 commit() 时会回调 <code>executor.commit()</code></p><ul><li><p>CachingExecutor#query()：执行查询方法，查询出的数据会先放入 entriesToAddOnCommit 集合暂存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二缓存中获取数据，获取不到去一级缓存获取</span></span><br><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#query</span></span><br><span class="line">    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    <span class="comment">// 将数据放入 entriesToAddOnCommit 集合暂存，此时还没放入二级缓存</span></span><br><span class="line">    tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>commit()：事务提交，<strong>清空一级缓存，放入二级缓存</strong>，二级缓存使用 TransactionalCacheManager（tcm）管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 首先调用 BaseExecutor#commit 方法，【清空一级缓存】</span></span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TransactionalCacheManager#commit：查询出的数据放入二级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有的缓存事务，挨着进行提交</span></span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">        txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 entriesToAddOnCommit 中的数据放入二级缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">// 清空相关集合</span></span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushPendingEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 将数据放入二级缓存</span></span><br><span class="line">        delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>增删改操作会清空缓存：</p><ul><li><p>update()：CachingExecutor 的更新操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#update 方法，也会清空一级缓存</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flushCacheIfRequired()：判断是否需要清空二级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">// 判断二级缓存是否存在，然后判断标签的 flushCache 的值，增删改操作的 flushCache 属性默认为 true</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        <span class="comment">// 清空二级缓存</span></span><br><span class="line">        tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>自定义缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">  Object <span class="title function_">getObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(Object key)</span>;</span><br><span class="line">  Object <span class="title function_">removeObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存的配置，只需要在缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如在缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/tmp/my-custom-cache.tmp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。</li><li>可以使用占位符（如 <code>$&#123;cache.file&#125;</code>），以便替换成在配置文件属性中定义的值</li></ul><p>MyBatis 支持在所有属性设置完毕之后，调用一个初始化方法， 如果想要使用这个特性，可以在自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingObject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存</p><p>对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新，在多个命名空间中共享相同的缓存配置和实例，可以使用 cache-ref 元素来引用另一个缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="构造语句"><a href="#构造语句" class="headerlink" title="构造语句"></a>构造语句</h2><h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>动态 SQL 是 MyBatis 强大特性之一，逻辑复杂时，MyBatis 映射配置文件中，SQL 是动态变化的，所以引入动态 SQL 简化拼装 SQL 的操作</p><p>DynamicSQL 包含的标签：</p><ul><li>if</li><li>where</li><li>set</li><li>choose (when、otherwise)</li><li>trim</li><li>foreach</li></ul><p>各个标签都可以进行灵活嵌套和组合</p><p>OGNL：Object Graphic Navigation Language（对象图导航语言），用于对数据进行访问</p><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7289529.html">https://www.cnblogs.com/ysocean/p/7289529.html</a></p><hr><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p><where>：条件标签，有动态条件则使用该标签代替 WHERE 关键字，封装查询条件</p><p>作用：如果标签返回的内容是以 AND 或 OR 开头的，标签内会剔除掉</p><p>表结构：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E5%8A%A8%E6%80%81sql%E7%94%A8%E6%88%B7%E8%A1%A8.png"></p><hr><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>基本格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">“条件判断”</span>&gt;</span></span><br><span class="line">查询条件拼接</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果username 不同空时还要加入用户名作为条件，这种情况在我们的多条件组合查询中经常会碰到。</p><ul><li><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null &quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null &quot;</span>&gt;</span></span><br><span class="line">                AND username = #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null &quot;</span>&gt;</span></span><br><span class="line">                AND sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>MyBatisConfig.xml，引入映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO 层 Mapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//多条件查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;User&gt; <span class="title function_">selectCondition</span><span class="params">(Student stu)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCondition</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">2</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//user.setSex(男); AND 后会自动剔除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectCondition(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><set>：进行更新操作的时候，含有 set 关键词，使用该标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.username = #&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">     WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex&#x3D;? where id&#x3D;?</li><li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username &#x3D; ? ,u.sex &#x3D; ? where id&#x3D;?</li></ul><hr><h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>假如不想用到所有的查询条件，只要查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p><p>标签：<when>，<otherwise></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id !=&#x27;&#x27; and id != null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;username !=&#x27;&#x27; and username != null&quot;</span>&gt;</span></span><br><span class="line">                AND username=#&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND sex=#&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有三个条件，id、username、sex，只能选择一个作为查询条件</p><ul><li><p>如果 id 不为空，那么查询语句为：select * from user where  id&#x3D;?</p></li><li><p>如果 id 为空，那么看 username 是否为空</p><ul><li>如果不为空，那么语句为：select * from user where username&#x3D;?</li><li>如果 username 为空，那么查询语句为 select * from user where sex&#x3D;?</li></ul></li></ul><hr><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>trim 标记是一个格式化的标记，可以完成 set 或者是 where 标记的功能，自定义字符串截取</p><ul><li>prefix：给拼串后的整个字符串加一个前缀，trim 标签体中是整个字符串拼串后的结果</li><li>prefixOverrides：去掉整个字符串前面多余的字符</li><li>suffix：给拼串后的整个字符串加一个后缀</li><li>suffixOverrides：去掉整个字符串后面多余的字符</li></ul><p>改写 if + where 语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUsernameAndSex&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and | or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            AND username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span></span><br><span class="line">            AND sex=#&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改写 if + set 语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.sex = #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>基本格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span>&gt;</span>：循环遍历标签。适用于多个参数或者的关系。</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">“”open</span>=<span class="string">“”close</span>=<span class="string">“”item</span>=<span class="string">“”separator</span>=<span class="string">“”</span>&gt;</span></span><br><span class="line">获取参数</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>collection：参数容器类型， (list-集合， array-数组)</li><li>open：开始的 SQL 语句</li><li>close：结束的 SQL 语句</li><li>item：参数变量名</li><li>separator：分隔符</li></ul><p>需求：循环执行 sql 的拼接操作，<code>SELECT * FROM user WHERE id IN (1,2,5)</code></p><ul><li><p>UserMapper.xml片段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">List&lt;User&gt; list = mapper.selectByIds(ids);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h4><p>将一些重复性的 SQL 语句进行抽取，以达到复用的效果</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">“片段唯一标识”</span>&gt;</span>抽取的SQL语句<span class="tag">&lt;/<span class="name">sql</span>&gt;</span><span class="comment">&lt;!--抽取标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">“片段唯一标识”/</span>&gt;</span><span class="comment">&lt;!--引入标签--&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span>&gt;</span>SELECT * FROM user<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;select&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 逆向工程，可以针对<strong>单表</strong>自动生成 MyBatis 执行所需要的代码（mapper.java、mapper.xml、pojo…）</p><p>generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisrelation&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:生成PO类的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.po&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orderdetail&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//指向逆向工程配置文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(GeneratorTest.class.</span><br><span class="line">                               getResource(<span class="string">&quot;/generatorConfig.xml&quot;</span>).getFile());</span><br><span class="line">    <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line">    <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">    <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config,</span><br><span class="line">                                                             callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7360409.html">https://www.cnblogs.com/ysocean/p/7360409.html</a></p><hr><h3 id="构建-SQL"><a href="#构建-SQL" class="headerlink" title="构建 SQL"></a>构建 SQL</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>MyBatis 提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句    </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SELECT(String… columns)</td><td>根据字段拼接查询语句</td></tr><tr><td>FROM(String… tables)</td><td>根据表名拼接语句</td></tr><tr><td>WHERE(String… conditions)</td><td>根据条件拼接语句</td></tr><tr><td>INSERT_INTO(String tableName)</td><td>根据表名拼接新增语句</td></tr><tr><td>INTO_VALUES(String… values)</td><td>根据值拼接新增语句</td></tr><tr><td>UPDATE(String table)</td><td>根据表名拼接修改语句</td></tr><tr><td>DELETE_FROM(String table)</td><td>根据表名拼接删除语句</td></tr></tbody></table><p>增删改查注解：</p><ul><li>@SelectProvider：生成查询用的 SQL 语句</li><li>@InsertProvider：生成新增用的 SQL 语句</li><li>@UpdateProvider：生成修改用的 SQL 语句注解</li><li>@DeleteProvider：生成删除用的 SQL 语句注解。<ul><li>type 属性：生成 SQL 语句功能类对象 </li><li>method 属性：指定调用方法</li></ul></li></ul><hr><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>MyBatisConfig.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- mappers引入映射配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = ReturnSql.class, method = &quot;getSelectAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="meta">@InsertProvider(type = ReturnSql.class, method = &quot;getInsert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="meta">@UpdateProvider(type = ReturnSql.class, method = &quot;getUpdate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="meta">@DeleteProvider(type = ReturnSql.class, method = &quot;getDelete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReturnSQL 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnSql</span> &#123;</span><br><span class="line">    <span class="comment">//定义方法，返回查询的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回新增的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInsert</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                INSERT_INTO(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                INTO_VALUES(<span class="string">&quot;#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回修改的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUpdate</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                UPDATE(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>,<span class="string">&quot;age=#&#123;age&#125;&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回删除的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDelete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                DELETE_FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>功能实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span>  <span class="comment">//查询全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果 -&gt;6 7</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insert(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5调用实现类对象中的方法，接收结果 -&gt;6 7 </span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六wq&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.update(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.delete(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><p>MyBatis 运行过程：</p><ol><li><p>加载 MyBatis 全局配置文件，通过 XPath 方式解析 XML 配置文件，首先解析核心配置文件，<settings> 标签中配置属性项有 defaultExecutorType，用来配置指定 Executor 类型，将配置文件的信息填充到 Configuration对象。最后解析映射器配置的映射文件，并<strong>构建 MappedStatement 对象填充至 Configuration</strong>，将解析后的映射器添加到 mapperRegistry 中，用于获取代理</p></li><li><p>创建一个 DefaultSqlSession 对象，<strong>根据参数创建指定类型的 Executor</strong>，二级缓存默认开启，把 Executor 包装成缓存执行器</p></li><li><p>DefaulSqlSession 调用 getMapper()，通过 JDK 动态代理获取 Mapper 接口的代理对象 MapperProxy </p></li><li><p>执行 SQL 语句：</p><ul><li>MapperProxy.invoke() 执行代理方法，通过 MapperMethod#execute 判断执行的是增删改查中的哪个方法</li><li>查询方法调用 sqlSession.selectOne()，从 Configuration 中获取执行者对象 MappedStatement，然后 Executor 调用 executor.query 开始执行查询方法</li><li>首先通过 CachingExecutor 去二级缓存查询，查询不到去一级缓存查询，<strong>最后去数据库查询并放入一级缓存</strong></li><li>Configuration 对象根据 <select> 标签的 statementType 属性创建 StatementHandler 对象，在 StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</li><li>最后获取 <strong>JDBC 原生的</strong> Connection 数据库连接对象，创建 Statement 执行者对象，然后通过 ParameterHandler 设置预编译参数，底层是 TypeHandler#setParameter 方法，然后通过 StatementHandler 回调执行者对象执行增删改查，最后调用 ResultsetHandler 处理查询结果</li></ul></li></ol><p><strong>四大对象</strong>：</p><ul><li>StatementHandler：执行 SQL 语句的对象</li><li>ParameterHandler：设置预编译参数用的</li><li>ResultHandler：处理结果集</li><li>Executor：执行器，真正进行 Java 与数据库交互的对象</li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1mW411M737?p=71">https://www.bilibili.com/video/BV1mW411M737?p=71</a></p><hr><h3 id="获取工厂"><a href="#获取工厂" class="headerlink" title="获取工厂"></a>获取工厂</h3><p>SqlSessionFactoryBuilder.build(InputStream, String,  Properties)：构建工厂</p><p>XMLConfigBuilder.parse()：解析核心配置文件每个标签的信息（<strong>XPath</strong>）</p><ul><li><p><code>parseConfiguration(parser.evalNode(&quot;/configuration&quot;))</code>：读取节点内数据，<configuration> 是 MyBatis 配置文件中的顶层标签</p><p><code>settings = settingsAsProperties(root.evalNode(&quot;settings&quot;))</code>：读取核心配置文件中的 <settings> 标签</p><p><code>settingsElement(settings)</code>：设置框架相关的属性</p><ul><li><code>configuration.setCacheEnabled()</code>：<strong>设置缓存属性，默认是 true</strong></li><li><code>configuration.setDefaultExecutorType()</code>：<strong>设置 Executor 类型到 configuration，默认是 SIMPLE</strong></li></ul><p><code>mapperElement(root.evalNode(&quot;mappers&quot;))</code>：解析 mappers 信息，分为 package 和 单个注册两种</p><ul><li><p><code>if...else...</code>：根据映射方法选择合适的读取方式</p></li><li><p><code>XMLMapperBuilder.parse()</code>：解析 mapper 的标签的信息</p><ul><li><p><code>configurationElement(parser.evalNode(&quot;/mapper&quot;))</code>：解析 mapper 文件，顶层节点 <mapper></p><ul><li><p><code>buildStatementFromContext(context.evalNodes(&quot;select...&quot;))</code>：解析<strong>每个操作标签</strong></p><p><code>XMLStatementBuilder.parseStatementNode()</code>：解析<strong>操作标签</strong>的所有的属性</p><p><code>builderAssistant.addMappedStatement(...)</code>：<strong>封装成 MappedStatement 对象加入 Configuration 对象</strong>，代表一个增删改查的标签</p></li></ul></li></ul></li><li><p><code>Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass)</code>：加载 Mapper 接口</p></li><li><p><code>Configuration.addMappers()</code>：将核心配置文件配置的映射器添加到 mapperRegistry 中，用来<strong>获取代理对象</strong></p><ul><li><p><code>MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type)</code>：创建<strong>注解</strong>解析器</p></li><li><p><code>parser.parse()</code>：解析 Mapper 接口</p><ul><li><p><code>SqlSource sqlSource = getSqlSourceFromAnnotations()</code>：获取 SQL 的资源对象</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-SQL%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.png"></p></li><li><p><code>builderAssistant.addMappedStatement(...)</code>：封装成 MappedStatement 对象加入 Configuration 对象</p></li></ul></li></ul></li></ul></li><li><p><code>return configuration</code>：返回配置完成的 configuration 对象</p></li></ul><p>return new DefaultSqlSessionFactory(config)：返回工厂对象，包含 Configuration 对象</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82%E5%AF%B9%E8%B1%A1.png"></p><p>总结：解析 XML 是对 Configuration 中的属性进行填充，那么可以在一个类中创建 Configuration 对象，自定义其中属性的值来达到配置的效果</p><hr><h3 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h3><p>DefaultSqlSessionFactory.openSession()：获取 Session 对象，并且创建 Executor 对象</p><p>DefaultSqlSessionFactory.openSessionFromDataSource(…)：ExecutorType 为 Executor 的类型，TransactionIsolationLevel 为事务隔离级别，autoCommit 是否开启事务</p><ul><li><p><code>transactionFactory.newTransaction(DataSource, IsolationLevel, boolean</code>：事务对象</p></li><li><p><code>configuration.newExecutor(tx, execType)</code>：<strong>根据参数创建指定类型的 Executor</strong></p><ul><li>批量操作笔记的部分有讲解到 <setting> 的属性 defaultExecutorType，根据配置创建对象</li><li><strong>二级缓存默认开启</strong>，会包装 Executor 对象 <code>new CachingExecutor(executor)</code></li></ul></li></ul><p> return new DefaultSqlSession(configuration, executor, autoCommit)：返回 DefaultSqlSession 对象</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1.png"></p><hr><h3 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h3><p>Configuration.getMapper(Class, SqlSession)：获取代理的 mapper 对象</p><p>MapperRegistry.getMapper(Class, SqlSession)：MapperRegistry 是 Configuration 属性，在获取工厂对象时初始化</p><ul><li><code>(MapperProxyFactory&lt;T&gt;) knownMappers.get(type)</code>：获取接口信息封装为 MapperProxyFactory 对象</li><li><code>mapperProxyFactory.newInstance(sqlSession)</code>：<strong>创建代理对象</strong><ul><li><code>new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache)</code>：包装对象<ul><li>methodCache 是并发安全的 ConcurrentHashMap 集合，存放要执行的方法</li><li><code>MapperProxy&lt;T&gt; implements InvocationHandler</code> 说明 MapperProxy 默认是一个 InvocationHandler 对象</li></ul></li><li><code>Proxy.newProxyInstance()</code>：<strong>JDK 动态代理</strong>创建 MapperProxy 对象</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png"></p><hr><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><p>MapperProxy.invoke()：执行 SQL 语句，Object 类的方法直接执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前方法是否是属于 Object 类中的方法</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">            <span class="comment">// 当前方法是否是默认方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 包装成一个 MapperMethod 对象并初始化该对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">// 【根据 switch-case 判断使用的什么类型的 SQL 进行逻辑处理】，此处分析查询语句的查询操作</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sqlSession.selectOne(String, Object)：查询数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">// 解析传入的参数</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultSqlSession.selectList(String, Object)</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取执行者对象</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 开始执行查询语句，参数通过 wrapCollection() 包装成集合类</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor#query()：</p><ul><li><p><code>CachingExecutor.query()</code>：先执行 CachingExecutor 去二级缓存获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;<span class="comment">// 包装了 BaseExecutor，二级缓存不存在数据调用 BaseExecutor 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>MappedStatement.getBoundSql(parameterObject)</code>：<strong>把 parameterObject 封装成 BoundSql</strong></p><p>构造函数中有：<code>this.parameterObject = parameterObject</code></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-boundSql%E5%AF%B9%E8%B1%A1.png"></p></li><li><p><code>CachingExecutor.createCacheKey()</code>：创建缓存对象</p></li><li><p><code>ms.getCache()</code>：获取二级缓存</p></li><li><p><code>tcm.getObject(cache, key)</code>：尝试从<strong>二级缓存</strong>中获取数据</p></li></ul></li><li><p><code>BaseExecutor.query()</code>：二级缓存不存在该数据，调用该方法</p><ul><li><code>localCache.getObject(key) </code>：尝试从<strong>本地缓存（一级缓存</strong>）获取数据</li></ul></li><li><p><code>BaseExecutor.queryFromDatabase()</code>：缓存获取数据失败，<strong>开始从数据库获取数据，并放入本地缓存</strong></p><ul><li><p><code>SimpleExecutor.doQuery()</code>：执行 query</p><ul><li><p><code>configuration.newStatementHandler()</code>：创建 StatementHandler 对象</p><ul><li>根据 <select> 标签的 statementType 属性，根据属性选择创建哪种对象</li><li>判断 BoundSql 是否被创建，没有创建会重新封装参数信息到 BoundSql</li><li><strong>StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</strong></li><li><code>interceptorChain.pluginAll(statementHandler)</code>：拦截器链</li></ul></li><li><p><code>prepareStatement()</code>：通过 StatementHandler 创建 JDBC 原生的 Statement 对象</p><ul><li><code>getConnection()</code>：<strong>获取 JDBC 的 Connection 对象</strong></li><li><code>handler.prepare()</code>：初始化 Statement 对象<ul><li><code>instantiateStatement(Connection connection)</code>：Connection  中的方法实例化对象<ul><li>获取普通执行者对象：<code>Connection.createStatement()</code></li><li><strong>获取预编译执行者对象</strong>：<code>Connection.prepareStatement()</code></li></ul></li></ul></li><li><code>handler.parameterize()</code>：进行参数的设置<ul><li><code>ParameterHandler.setParameters()</code>：<strong>通过 ParameterHandler 设置参数</strong><ul><li><code>typeHandler.setParameter()</code>：底层通过 TypeHandler 实现，回调 JDBC 的接口进行设置</li></ul></li></ul></li></ul></li><li><p><code>StatementHandler.query()</code>：<strong>调用 JDBC 原生的 PreparedStatement 执行 SQL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 SQL 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">    statement.execute(sql);</span><br><span class="line">    <span class="comment">// 通过 ResultSetHandler 对象封装结果集，映射成 JavaBean</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>resultSetHandler.handleResultSets(statement)</code>：处理结果集</p><ul><li><p><code>handleResultSet(rsw, resultMap, multipleResults, null)</code>：底层回调</p><ul><li><p><code>handleRowValues()</code>：逐行处理数据，根据是否配置了 <resultMap> 属性选择是否使用简单结果集映射</p><ul><li><p>首先判断数据是否被限制行数，然后进行结果集的映射</p></li><li><p>最后将数据存入 ResultHandler 对象，底层就是 List 集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultResultHandler</span> <span class="keyword">implements</span> <span class="title class_">ResultHandler</span>&lt;Object&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; list;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(ResultContext&lt;?&gt; context)</span> &#123;</span><br><span class="line">    list.add(context.getResultObject());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>return collapseSingleResultList(multipleResults)</code>：可能存在多个结果集的情况</p></li></ul></li></ul></li><li><p><code>localCache.putObject(key, list)</code>：<strong>放入一级（本地）缓存</strong></p></li></ul></li></ul><p><code>return list.get(0)</code>：返回结果集的第一个数据</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8CSQL%E8%BF%87%E7%A8%8B.png"></p><hr><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><h3 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h3><p>实现原理：插件是按照插件配置顺序创建层层包装对象，执行目标方法的之后，按照逆向顺序执行（栈）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-插件原理.png" style="zoom:50%;" /><p>在四大对象创建时：</p><ul><li>每个创建出来的对象不是直接返回的，而是 <code>interceptorChain.pluginAll(parameterHandler)</code></li><li>获取到所有 Interceptor（插件需要实现的接口），调用 <code>interceptor.plugin(target)</code>返回 target 包装后的对象</li><li>插件机制可以使用插件为目标对象创建一个代理对象，代理对象可以<strong>拦截到四大对象的每一个执行</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">&#123;</span></span><br><span class="line"><span class="meta">@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//intercept：拦截目标对象的目标方法的执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyFirstPlugin...intercept:&quot;</span> + invocation.getMethod());</span><br><span class="line"><span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询11号员工</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> invocation.getTarget();</span><br><span class="line">System.out.println(<span class="string">&quot;当前拦截到的对象：&quot;</span> + target);</span><br><span class="line"><span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line"><span class="comment">//拿到target的元数据</span></span><br><span class="line"><span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(target);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> metaObject.getValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sql语句用的参数是：&quot;</span> + value);</span><br><span class="line"><span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">metaObject.setValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="number">11</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line"><span class="comment">//返回执行后的返回值</span></span><br><span class="line"><span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugin：包装目标对象的，为目标对象创建一个代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"><span class="comment">//可以借助 Plugin 的 wrap 方法来使用当前 Interceptor 包装我们目标对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot;</span> + target);</span><br><span class="line"><span class="type">Object</span> <span class="variable">wrap</span> <span class="operator">=</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//返回为当前target创建的动态代理</span></span><br><span class="line"><span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setProperties：将插件注册时的property属性设置进来</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;插件配置的信息：&quot;</span> + properties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--plugins：注册插件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;mybatis.dao.MyFirstPlugin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D.png"></p><ul><li>分页可以将很多条结果进行分页显示。如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页，需要明确当前是第几页，这一页中显示多少条结果。  </li><li>MyBatis 是不带分页功能的，如果想实现分页功能，需要手动编写 LIMIT 语句，不同的数据库实现分页的 SQL 语句也是不同，手写分页 成本较高。</li><li>PageHelper：第三方分页助手，将复杂的分页操作进行封装，从而让分页功能变得非常简单</li></ul><hr><h3 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h3><p>开发步骤：</p><ol><li><p>导入 PageHelper 的 Maven 坐标</p></li><li><p>在 MyBatis 核心配置文件中配置 PageHelper 插件</p><p>注意：分页助手的插件配置在通用 Mapper 之前</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>与 MySQL 分页查询页数计算公式不同</p><p><code>static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)</code>：pageNum第几页，pageSize页面大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一页：显示2条数据</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    List&lt;Student&gt; students = sqlSession.selectList(<span class="string">&quot;StudentMapper.selectAll&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><p>PageInfo构造方法：</p><ul><li><code>PageInfo&lt;Student&gt; info = new PageInfo&lt;&gt;(list)</code> : list 是 SQL 执行返回的结果集合，参考上一节</li></ul><p>PageInfo相关API：</p><ol><li>startPage()：设置分页参数 </li><li>PageInfo：分页相关参数功能类。 </li><li>getTotal()：获取总条数 </li><li>getPages()：获取总页数</li><li>getPageNum()：获取当前页</li><li>getPageSize()：获取每页显示条数</li><li>getPrePage()：获取上一页 </li><li>getNextPage()：获取下一页 </li><li>isIsFirstPage()：获取是否是第一页 </li><li>isIsLastPage()：获取是否是最后一页</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;MyBatis&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Spring全家桶" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="SSM框架" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SSM%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring全家桶" scheme="http://example.com/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>单点登录代码</title>
    <link href="http://example.com/2022/08/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2022/08/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%BB%A3%E7%A0%81/</id>
    <published>2022-08-17T15:48:39.274Z</published>
    <updated>2022-08-18T11:07:26.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录代码"><a href="#单点登录代码" class="headerlink" title="单点登录代码"></a>单点登录代码</h1><p><em><strong>注：该代码是从谷粒学院中截取</strong></em></p><ul><li>整合JWT</li><li>整合短信服务</li><li>登录注册</li></ul><hr><h2 id="整合JWT"><a href="#整合JWT" class="headerlink" title="整合JWT"></a>整合JWT</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- JWT--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="创建JWT工具类"><a href="#创建JWT工具类" class="headerlink" title="创建JWT工具类"></a>创建JWT工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yemu.commonUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jws;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> helen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/10/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>; <span class="comment">//token过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_SECRET</span> <span class="operator">=</span> <span class="string">&quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;</span>; <span class="comment">//秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token字符串的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJwtToken</span><span class="params">(String id, String nickname)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>)</span><br><span class="line"></span><br><span class="line">                .setSubject(<span class="string">&quot;yemu&quot;</span>)</span><br><span class="line">                <span class="comment">//设置过期时间</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE))</span><br><span class="line"></span><br><span class="line">                .claim(<span class="string">&quot;id&quot;</span>, id)  <span class="comment">//设置token主体部分 ，存储用户信息</span></span><br><span class="line">                .claim(<span class="string">&quot;nickname&quot;</span>, nickname)</span><br><span class="line"></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, APP_SECRET)</span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据token字符串获取会员id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMemberIdByJwtToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line">        <span class="keyword">return</span> (String)claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="整合短信服务"><a href="#整合短信服务" class="headerlink" title="整合短信服务"></a>整合短信服务</h2><p><em>注：由于阿里云短信服务需要备案，这里使用的是阿里市场购买的第三方短信服务-国阳云</em></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>  1.整合JWT<br>  2.整合Utils<br>  3.编写Controller层<br>  4.编写Service层</p><hr><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">4.5</span><span class="number">.13</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;httpcore&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">4.4</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">2.6</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;jetty-util&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">9.3</span><span class="number">.7</span>.v20160115&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">4.5</span>&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><em>注：httpcore与httpclient如果版本过低会造成版本冲突</em></p><hr><h3 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8005</span></span><br><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-msm</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># mysql数据库连接</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">8.130.50.16</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#最小空闲</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#返回json的全局时间格式</span></span><br><span class="line"><span class="attr">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="attr">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="编写utils工具类"><a href="#编写utils工具类" class="headerlink" title="编写utils工具类"></a>编写utils工具类</h3><p>HttpUtils-国阳云发送短信所需</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyManagementException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpDelete;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPut;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ClientConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.scheme.Scheme;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.scheme.SchemeRegistry;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.ByteArrayEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doGet</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; querys)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * post form</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bodys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doPost</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; querys,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; bodys)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bodys != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;NameValuePair&gt; nameValuePairList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NameValuePair&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String key : bodys.keySet()) &#123;</span><br><span class="line">                nameValuePairList.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(key, bodys.get(key)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">UrlEncodedFormEntity</span> <span class="variable">formEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(nameValuePairList, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            formEntity.setContentType(<span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>);</span><br><span class="line">            request.setEntity(formEntity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Post String</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doPost</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; querys,</span></span><br><span class="line"><span class="params">                                      String body)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(body)) &#123;</span><br><span class="line">            request.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(body, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Post stream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doPost</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, String&gt; querys,</span></span><br><span class="line"><span class="params">                                      <span class="type">byte</span>[] body)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setEntity(<span class="keyword">new</span> <span class="title class_">ByteArrayEntity</span>(body));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Put String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doPut</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; querys,</span></span><br><span class="line"><span class="params">                                     String body)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPut</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPut</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(body)) &#123;</span><br><span class="line">            request.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(body, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Put stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doPut</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                     Map&lt;String, String&gt; querys,</span></span><br><span class="line"><span class="params">                                     <span class="type">byte</span>[] body)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPut</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPut</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setEntity(<span class="keyword">new</span> <span class="title class_">ByteArrayEntity</span>(body));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delete</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> querys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpResponse <span class="title function_">doDelete</span><span class="params">(String host, String path, String method,</span></span><br><span class="line"><span class="params">                                        Map&lt;String, String&gt; headers,</span></span><br><span class="line"><span class="params">                                        Map&lt;String, String&gt; querys)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> wrapClient(host);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpDelete</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpDelete</span>(buildUrl(host, path, querys));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;</span><br><span class="line">            request.addHeader(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">buildUrl</span><span class="params">(String host, String path, Map&lt;String, String&gt; querys)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sbUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sbUrl.append(host);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isBlank(path)) &#123;</span><br><span class="line">            sbUrl.append(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != querys) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sbQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; query : querys.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; sbQuery.length()) &#123;</span><br><span class="line">                    sbQuery.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(query.getKey()) &amp;&amp; !StringUtils.isBlank(query.getValue())) &#123;</span><br><span class="line">                    sbQuery.append(query.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isBlank(query.getKey())) &#123;</span><br><span class="line">                    sbQuery.append(query.getKey());</span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isBlank(query.getValue())) &#123;</span><br><span class="line">                        sbQuery.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        sbQuery.append(URLEncoder.encode(query.getValue(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; sbQuery.length()) &#123;</span><br><span class="line">                sbUrl.append(<span class="string">&quot;?&quot;</span>).append(sbQuery);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sbUrl.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HttpClient <span class="title function_">wrapClient</span><span class="params">(String host)</span> &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();</span><br><span class="line">        <span class="keyword">if</span> (host.startsWith(<span class="string">&quot;https://&quot;</span>)) &#123;</span><br><span class="line">            sslClient(httpClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sslClient</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SSLContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            <span class="type">X509TrustManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509TrustManager</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkClientTrusted</span><span class="params">(X509Certificate[] xcs, String str)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServerTrusted</span><span class="params">(X509Certificate[] xcs, String str)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ctx.init(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TrustManager</span>[] &#123; tm &#125;, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">SSLSocketFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLSocketFactory</span>(ctx);</span><br><span class="line">            ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line">            <span class="type">ClientConnectionManager</span> <span class="variable">ccm</span> <span class="operator">=</span> httpClient.getConnectionManager();</span><br><span class="line">            <span class="type">SchemeRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> ccm.getSchemeRegistry();</span><br><span class="line">            registry.register(<span class="keyword">new</span> <span class="title class_">Scheme</span>(<span class="string">&quot;https&quot;</span>, <span class="number">443</span>, ssf));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RandomUtils-生成随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取随机数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianyi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomUtil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DecimalFormat</span> <span class="variable">fourdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DecimalFormat</span> <span class="variable">sixdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机生成4个数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFourBitRandom</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fourdf.format(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSixBitRandom</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sixdf.format(random.nextInt(<span class="number">1000000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定数组，抽取n个数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">getRandom</span><span class="params">(List list, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机数字并存入HashMap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashMap.put(number, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从HashMap导入数组</span></span><br><span class="line">Object[] robjs = hashMap.values().toArray();</span><br><span class="line"></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组并打印数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">r.add(list.get((<span class="type">int</span>) robjs[i]));</span><br><span class="line">System.out.print(list.get((<span class="type">int</span>) robjs[i]) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="编写Controller层"><a href="#编写Controller层" class="headerlink" title="编写Controller层"></a>编写Controller层</h3><ul><li>注入Service服务</li><li>创建方法</li><li>判断-如果Redis中有值就直接返回</li><li>根据RandomUtil.getFourBitRandom();获取随机四位数作为验证码</li><li>提升短信生效时间String minute&#x3D;”5”;</li><li>将验证码与提示时间放入Map中调</li><li>调用service中的服务，用Boolean类型判断是否发送成功<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/edumsm/msm&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsmController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsmService msmService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;send/&#123;phone&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">sendMsm</span><span class="params">(<span class="meta">@PathVariable</span> String phone)</span>&#123;</span><br><span class="line">        <span class="comment">//从Redis获取验证码，如果获取到直接返回</span></span><br><span class="line">        String code=redisTemplate.opsForValue().get(phone);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(code))&#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机生成4位数数字</span></span><br><span class="line">        code= RandomUtil.getFourBitRandom();</span><br><span class="line">        System.out.println(<span class="string">&quot;code:&quot;</span>+code);</span><br><span class="line">        <span class="comment">//提示时间</span></span><br><span class="line">        String minute=<span class="string">&quot;5&quot;</span>;</span><br><span class="line">        Map&lt;String,Object&gt; param=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        param.put(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">        param.put(<span class="string">&quot;minute&quot;</span>,minute);</span><br><span class="line">        <span class="comment">//调用Service发送断行</span></span><br><span class="line">        Boolean isSend=msmService.send(param,phone);</span><br><span class="line">        <span class="keyword">if</span> (isSend)&#123;</span><br><span class="line">            <span class="comment">//发送成功，可以把验证码放到Redis中</span></span><br><span class="line">            <span class="comment">//设置时间,set(手机号，验证码，时间，时间单位)</span></span><br><span class="line">            redisTemplate.opsForValue().set(phone,code,<span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> R.ok();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error().message(<span class="string">&quot;短信发送失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="编写Service层"><a href="#编写Service层" class="headerlink" title="编写Service层"></a>编写Service层</h3><ul><li>判断手机号是否为空，如果是直接返回false</li><li>将地址、国阳云的密钥、格式等放入map中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Boolean <span class="title function_">send</span><span class="params">(Map&lt;String, Object&gt; param, String phone)</span> &#123;</span><br><span class="line">       <span class="comment">//判断手机号是否为空，为空直接返回false</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(phone)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;https://gyytz.market.alicloudapi.com&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/sms/smsSend&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">appcode</span> <span class="operator">=</span> <span class="string">&quot;购买国阳云后发送的密钥&quot;</span>;</span><br><span class="line">       Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">       <span class="comment">//最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105</span></span><br><span class="line">       headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + appcode);</span><br><span class="line">       Map&lt;String, String&gt; querys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">       querys.put(<span class="string">&quot;mobile&quot;</span>, phone);</span><br><span class="line">       <span class="comment">//JSONObject.toJSONString将MAP转换成json</span></span><br><span class="line">       querys.put(<span class="string">&quot;param&quot;</span>, JSONObject.toJSONString(param));</span><br><span class="line">       querys.put(<span class="string">&quot;smsSignId&quot;</span>, <span class="string">&quot;********&quot;</span>);</span><br><span class="line">       querys.put(<span class="string">&quot;templateId&quot;</span>, <span class="string">&quot;********&quot;</span>);</span><br><span class="line">       Map&lt;String, String&gt; bodys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 重要提示如下:</span></span><br><span class="line"><span class="comment">            * HttpUtils请从</span></span><br><span class="line"><span class="comment">            * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">            * 下载</span></span><br><span class="line"><span class="comment">            * 相应的依赖请参照</span></span><br><span class="line"><span class="comment">            * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpUtils.doPost(host, path, method, headers, querys, bodys);</span><br><span class="line">           <span class="comment">//获取response的body</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="登录注册接口"><a href="#登录注册接口" class="headerlink" title="登录注册接口"></a>登录注册接口</h2><h3 id="编写配置类-1"><a href="#编写配置类-1" class="headerlink" title="编写配置类"></a>编写配置类</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8160</span></span><br><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-ucenter</span></span><br><span class="line"><span class="comment"># mysql数据库连接</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">8.130.50.16</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#最小空闲</span></span><br><span class="line"><span class="comment">#返回json的全局时间格式</span></span><br><span class="line"><span class="attr">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="attr">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br><span class="line"><span class="comment">#配置mapper xml文件的路径</span></span><br><span class="line"><span class="attr">mybatis-plus.mapper-locations</span>=<span class="string">classpath:com/yemu/eduService/mapper/xml/*.xml</span></span><br><span class="line"><span class="comment">#mybatis日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="创建Vo用于封装登录和注册"><a href="#创建Vo用于封装登录和注册" class="headerlink" title="创建Vo用于封装登录和注册"></a>创建Vo用于封装登录和注册</h3><p>*LoginVo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value=&quot;登录对象&quot;, description=&quot;登录对象&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;手机号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*RegisterVo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value=&quot;注册对象&quot;, description=&quot;注册对象&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;手机号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;验证码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="编写登录和注册方法"><a href="#编写登录和注册方法" class="headerlink" title="编写登录和注册方法"></a>编写登录和注册方法</h3><p>登录：</p><ul><li>获取前端传入的数据调用service方法</li></ul><p>注册：</p><ul><li>获取前端数据调用service方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/educenter/member&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UcenterMemberController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UcenterMemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">loginUser</span><span class="params">(<span class="meta">@RequestBody</span> LoginVo loginVo)</span>&#123;</span><br><span class="line">        <span class="comment">//调用service方法实现登录、</span></span><br><span class="line">        <span class="comment">//返回token值，使用jwt生成</span></span><br><span class="line">        String token=memberService.login(loginVo);</span><br><span class="line">        <span class="keyword">return</span> R.ok().data(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">registerUser</span><span class="params">(<span class="meta">@RequestBody</span> RegisterVo registerVo)</span>&#123;</span><br><span class="line">        memberService.register(registerVo);</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 创建service接口和实现类</span><br><span class="line"></span><br><span class="line">登录：</span><br><span class="line">* 获取手机号和密码</span><br><span class="line">* 进行数据校验</span><br><span class="line">* 校验成功根据JWT生成token字符串</span><br><span class="line"></span><br><span class="line">注册：</span><br><span class="line">* 获取注册数据</span><br><span class="line">* 对数据进行校验</span><br><span class="line">* 将数据添加进数据库</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UcenterMemberServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UcenterMemberMapper, UcenterMember&gt; <span class="keyword">implements</span> <span class="title class_">UcenterMemberService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(LoginVo loginVo)</span> &#123;</span><br><span class="line">        <span class="comment">//获取手机号和密码</span></span><br><span class="line">        String mobile=loginVo.getMobile();</span><br><span class="line">        String password=loginVo.getPassword();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手机号和密码非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断手机号是否正确</span></span><br><span class="line">        QueryWrapper&lt;UcenterMember&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">&quot;mobile&quot;</span>,mobile);</span><br><span class="line">        UcenterMember mobileMember=baseMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="comment">//判断查询对象是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (mobileMember==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断密码</span></span><br><span class="line">        <span class="comment">//数据库中的密码都是加密后的，因此需要对密码进行加密然后比较</span></span><br><span class="line">        <span class="comment">//加密方式MD</span></span><br><span class="line">        <span class="keyword">if</span> (!MD5.encrypt(password).equals(mobileMember.getPassword()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否被禁用</span></span><br><span class="line">        <span class="keyword">if</span> (mobileMember.getIsDeleted())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">        <span class="comment">//生成token字符串，使用Jwt工具类</span></span><br><span class="line">        String token=JwtUtils.getJwtToken(mobileMember.getId(),mobileMember.getNickname());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(RegisterVo registerVo)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注册数据</span></span><br><span class="line">        String code=registerVo.getCode();<span class="comment">//验证码</span></span><br><span class="line">        String mobile=registerVo.getMobile();<span class="comment">//手机号</span></span><br><span class="line">        String nickname=registerVo.getNickname();<span class="comment">//昵称</span></span><br><span class="line">        String password=registerVo.getPassword();<span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(mobile)||</span><br><span class="line">            StringUtils.isEmpty(code)||</span><br><span class="line">            StringUtils.isEmpty(nickname)||</span><br><span class="line">            StringUtils.isEmpty(password))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;注册失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验验证码</span></span><br><span class="line">        <span class="comment">//从redis获取发送的验证码</span></span><br><span class="line">        String mobileCode=redisTemplate.opsForValue().get(mobile);</span><br><span class="line">        <span class="keyword">if</span> (!code.equals(mobileCode))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;注册失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断手机号是否重复</span></span><br><span class="line">        Integer count=baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UcenterMember&gt;().eq(<span class="string">&quot;mobile&quot;</span>,mobile));</span><br><span class="line">        <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuliException</span>(<span class="number">20001</span>,<span class="string">&quot;注册失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加信息到数据库</span></span><br><span class="line">        UcenterMember member=<span class="keyword">new</span> <span class="title class_">UcenterMember</span>();</span><br><span class="line">        member.setNickname(nickname);</span><br><span class="line">        member.setMobile(mobile);</span><br><span class="line">        member.setPassword(MD5.encrypt(password));<span class="comment">//对密码进行加密</span></span><br><span class="line">        member.setIsDisabled(<span class="literal">false</span>);</span><br><span class="line">        member.setAvatar(<span class="string">&quot;http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoj0hHXhgJNOTSOFsS4uZs8x1ConecaVOB8eIl115xmJZcT4oCicvia7wMEufibKtTLqiaJeanU2Lpg3w/132&quot;</span>);</span><br><span class="line">        baseMapper.insert(member);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UcenterMember <span class="title function_">getOpenIdMember</span><span class="params">(String openid)</span> &#123;</span><br><span class="line">        QueryWrapper&lt;UcenterMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;openid&quot;</span>, openid);</span><br><span class="line">        <span class="type">UcenterMember</span> <span class="variable">member</span> <span class="operator">=</span> baseMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">return</span> member;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="创建接口根据token获取用户数据"><a href="#创建接口根据token获取用户数据" class="headerlink" title="创建接口根据token获取用户数据"></a>创建接口根据token获取用户数据</h3><ul><li>调用JWT工具方法获取request对象头信息返回用户ID</li><li>根据用户ID调用service方法进行查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据token获取用户信息</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getMember&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getMemberInfo</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">//调用JWT工具类的方法，获取request对象获取头信息，返回用户id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">memberId</span> <span class="operator">=</span> JwtUtils.getMemberIdByJwtToken(request);</span><br><span class="line">    <span class="comment">//查询数据库根据用户ID查询信息</span></span><br><span class="line">    UcenterMember member=memberService.getById(memberId);</span><br><span class="line">    <span class="keyword">return</span> R.ok().data(<span class="string">&quot;userInfo&quot;</span>,member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="创建token方法的service"><a href="#创建token方法的service" class="headerlink" title="创建token方法的service"></a>创建token方法的service</h3><ul><li>查询数据进行返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UcenterMember <span class="title function_">getOpenIdMember</span><span class="params">(String openid)</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UcenterMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;openid&quot;</span>, openid);</span><br><span class="line">    <span class="type">UcenterMember</span> <span class="variable">member</span> <span class="operator">=</span> baseMapper.selectOne(wrapper);</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录代码&quot;&gt;&lt;a href=&quot;#单点登录代码&quot; class=&quot;headerlink&quot; title=&quot;单点登录代码&quot;&gt;&lt;/a&gt;单点登录代码&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;注：该代码是从谷粒学院中截取&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="技术点总结" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    <category term="单点登录" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
    
    <category term="技术点总结" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>单点登录（SSO）概要</title>
    <link href="http://example.com/2022/08/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/08/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-08-17T12:11:30.025Z</published>
    <updated>2022-08-18T11:07:42.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录知识点"><a href="#单点登录知识点" class="headerlink" title="单点登录知识点"></a>单点登录知识点</h1><h2 id="登录业务介绍"><a href="#登录业务介绍" class="headerlink" title="登录业务介绍"></a>登录业务介绍</h2><h3 id="单一服务器模式"><a href="#单一服务器模式" class="headerlink" title="单一服务器模式"></a>单一服务器模式</h3><p>流程图：<br><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/%E4%BC%A0%E7%BB%9F%E7%99%BB%E5%BD%95?Expires=1660739749&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=P49vryu4p4ohbZCux9BGI8UW1kk="></p><ul><li>简介：早期单一服务器，用户认证。</li><li>缺点：单点性能压力，无法扩展。</li></ul><h3 id="SSO（single-sign-on）模式"><a href="#SSO（single-sign-on）模式" class="headerlink" title="SSO（single sign on）模式"></a>SSO（single sign on）模式</h3><p>流程图：<br><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/SSO?Expires=1660739798&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=6OutxwKTY56jAoE6gdm6uSyWvUc="></p><p><strong>实现方式：</strong></p><ul><li>token登录</li><li>cookie+redis</li><li>session广播机制</li></ul><p>优点：</p><ul><li>用户身份信息独立管理，更好的分布式管理。</li><li>可以自己扩展安全策略。</li></ul><p>缺点：</p><ul><li>认证服务器访问压力大</li></ul><p> </p><h4 id="Token模式"><a href="#Token模式" class="headerlink" title="Token模式"></a>Token模式</h4><p>流程图：<br><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/Token?Expires=1660739809&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=X7wmmugyKNSdcjxG1siuer1tfYs="></p><ul><li>优点：<ul><li>无状态：token无状态，session有状态</li><li>基于标准化：你的API可以采用标准化的JSONwebToken（JWT）</li></ul></li><li>缺点：<ul><li>占用宽带</li><li>无法在服务端销毁</li></ul></li></ul><p><strong><em>注：基于微服务开发，选择token的形式相对较多</em>。</strong> </p><hr><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="JWT进行跨域身份验证"><a href="#JWT进行跨域身份验证" class="headerlink" title="JWT进行跨域身份验证"></a>JWT进行跨域身份验证</h3><h4 id="传统身份验证"><a href="#传统身份验证" class="headerlink" title="传统身份验证"></a>传统身份验证</h4><p><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/%E4%BC%A0%E7%BB%9F%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81?Expires=1660739924&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=IIH/xilBGbjf0402G5CL+S7xBug="></p><p>Internet服务无法与用户身份验证分开。一般过程如下：<br>    1.用户向服务器发送用户名和密码。<br>    2.验证服务器后，相关数据（如用户角色，登录时间等）将保存在当前会话中。<br>    3.服务器向用户返回session_id，session信息都会写入到用户的Cookie。<br>    4.用户的每个后续请求都将通过在Cookie中取出session_id传给服务器。<br>    5.服务器收到session_id并对比之前保存的数据，确认用户的身份。</p><p>这种模式最大的问题是，没有分布式架构，无法支持横向扩展。</p><p>解决方案<br>    1.session广播<br>    2.将透明令牌存入cookie，将用户身份信息存入redis</p><hr><h3 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h3><h4 id="访问令牌类型"><a href="#访问令牌类型" class="headerlink" title="访问令牌类型"></a>访问令牌类型</h4><p><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/JWT%E4%BB%A4%E7%89%8C?Expires=1660742155&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=LAODQYKNCEE3TpjZGFohYXvp7cU="></p><hr><h4 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h4><p><img src="https://yemu-biji.oss-cn-hangzhou.aliyuncs.com/JWT%E7%BB%84%E6%88%90?Expires=1660739900&OSSAccessKeyId=TMP.3KiR6dZWxUHvZuWAkHhwXZ5Kvw7k9aXR6UVNgG1itPaByFFwJHPvP2qd8fvnLviRVPJKZvZk9KV9yA6UD8uQK97gHvxfRB&Signature=Z4KwtleThZvhsM9qp3XxxzwFPPg="><br>    该对象为一个很长的字符串，通过’.’进行分隔为三个字符串。<br>    每一个字符串表示一个功能块</p><p><strong>JWT头</strong><br>    描述JWT元数据的JSON对象，通常如下显示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><pre><code>在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base46 URL算法将上述JSON对象转换为字符串。</code></pre><p><strong>有效载荷</strong><br>    有效载荷部分，是JWT的主体部分，也是一个JSON对象，包含要传递的数据。JWT指定七个默认字段选择。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss：发行人</span><br><span class="line">exp：到期时间</span><br><span class="line">sub：主题</span><br><span class="line">aud：用户</span><br><span class="line">nbf：在此之前不可用</span><br><span class="line">iat：发布时间</span><br><span class="line">jti：JWTID用于表示该JWT</span><br></pre></td></tr></table></figure><p>除此以上默认的字段外，我们可以自定义私有字段，如下列：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Helen&quot;</span></span><br><span class="line"><span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><p><em>注：默认情况JWT是未加密的，任何人都可以读取内容，因此不要构建隐私信息，存放保密信息，以防止信息泄露。JSON对象也使用Base64 URL算法转换为字符串保存。</em></p><p><strong>签名哈希</strong><br>    签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。<br>    首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。</p><p><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret)</code></p><pre><code>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用&quot;.&quot;分隔，就构成整个JWT对象。</code></pre><p><strong>Base64URL</strong><br>    如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。<br>    作为令牌的JWT可以放在URL中（例如api.example&#x2F;?token&#x3D;xxx）。 Base64中用的三个字符是”+”，”&#x2F;“和”&#x3D;”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”&#x3D;”去掉，”+”用”-“替换，”&#x2F;“用”_”替换，这就是Base64URL算法。</p><hr><h4 id="JWT的原则"><a href="#JWT的原则" class="headerlink" title="JWT的原则"></a>JWT的原则</h4><pre><code>JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。</code></pre><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Helen&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​    之后，当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。<br>​    服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。</p><hr><h4 id="JWT的用法"><a href="#JWT的用法" class="headerlink" title="JWT的用法"></a>JWT的用法</h4><p>​客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p><hr><h4 id="JWT的问题和趋势"><a href="#JWT的问题和趋势" class="headerlink" title="JWT的问题和趋势"></a>JWT的问题和趋势</h4><ul><li>JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</li><li>生产的token可以包含基本信息，比如id、用户昵称、头像等信息，避免再次查库</li><li>存储在客户端，不占用服务端的内存资源</li><li>JWT默认不加密，但可以加密。生成原始令牌后，可以再次对其进行加密。</li><li>当JWT未加密时，一些私密数据无法通过JWT传输。</li><li>JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</li><li>JWT本身包含认证信息，token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</li><li>为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录知识点&quot;&gt;&lt;a href=&quot;#单点登录知识点&quot; class=&quot;headerlink&quot; title=&quot;单点登录知识点&quot;&gt;&lt;/a&gt;单点登录知识点&lt;/h1&gt;&lt;h2 id=&quot;登录业务介绍&quot;&gt;&lt;a href=&quot;#登录业务介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术点总结" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    <category term="单点登录" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
    
    <category term="技术点总结" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Java</title>
    <link href="http://example.com/2022/08/17/Java/"/>
    <id>http://example.com/2022/08/17/Java/</id>
    <published>2022-08-16T16:43:15.521Z</published>
    <updated>2022-08-20T15:47:48.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK、JRE、JVM之间的联系"><a href="#JDK、JRE、JVM之间的联系" class="headerlink" title="JDK、JRE、JVM之间的联系"></a>JDK、JRE、JVM之间的联系</h4><ul><li>JDK：java的标准开发包，提供了 <strong>编译、运行</strong>java程序所需要的各种工具和资源，包括<strong>java编译器、java运行环境</strong>，以及常用的java类库等。</li><li>JRE：java的运行环境，用于运行java的字节码文件，JRE包括了JVM以及JVM工作所需的类库，普通用户只需安装JRE来运行java程序，而程序开发者必须安装JDK来编辑和调试程序。</li><li>JVM：java虚拟机，是JRE的一部分，是整个java实现跨平台最核心的一部分，负责运行字节码文件</li></ul><hr><h4 id="x3D-x3D-与equals方法的区别"><a href="#x3D-x3D-与equals方法的区别" class="headerlink" title="&#x3D;&#x3D;与equals方法的区别"></a>&#x3D;&#x3D;与equals方法的区别</h4><ul><li>&#x3D;&#x3D;：如果是基本数据类型，比较的是值。如果是引用类型，比较的是引用地址</li><li>equals：具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类型重写了equals方法，内部是比较字符串的各个字符是否全部相等</li></ul><hr><h4 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h4><ul><li><code>&lt;? extends T&gt;表示包括T在内的任何子类</code></li><li><code>&lt;? super T&gt;表示所有T在内的任何父类</code></li></ul><hr><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul><li><strong>重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</li><li><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类的访问修饰符是private则子类不能重写该方法。</li></ul><hr><h4 id="Sring、StringBuffer、StringBuilder的区别"><a href="#Sring、StringBuffer、StringBuilder的区别" class="headerlink" title="Sring、StringBuffer、StringBuilder的区别"></a>Sring、StringBuffer、StringBuilder的区别</h4><ul><li>Spring不可改变，如果尝试修，会生成一个新的字符串对象。StringBuffer、StringBuilder可以改变</li><li>StringBuffer是线程安全、StringBuilder是线程不安全的，所以单线程的环境下StringBuilder效率更高</li></ul><hr><h4 id="List与Set的区别"><a href="#List与Set的区别" class="headerlink" title="List与Set的区别"></a>List与Set的区别</h4><ul><li>List：有序，按对象插入顺序保存对象，可重复，允许多个Null元素，可以使用lterator去除所有元素，再逐一遍历，还可以使用get（int index）获取下标元素</li><li>Set：无序，不可以重复，最多允许一个Null元素对象，取元素的时候只能用lterator取得所有元素，再逐一遍历</li></ul><hr><h4 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h4><ul><li>ArrayList是基于数组实现的，LinkedList是基于链表实现的</li><li>由于底层不同，适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不一样。</li><li>两者都实现了List接口，但是LinkedList额外实现了Deque接口，所以LinkedList可以当作队列来使用。</li></ul><hr><h4 id="JDK1-7到JDK1-8-HashMap发生了什么变化（底层）"><a href="#JDK1-7到JDK1-8-HashMap发生了什么变化（底层）" class="headerlink" title="JDK1.7到JDK1.8 HashMap发生了什么变化（底层）"></a>JDK1.7到JDK1.8 HashMap发生了什么变化（底层）</h4><ul><li>1.7中底层是数组+链表，1.8中是数组+链表+红黑树，加红黑树是为了提高HashMap插入和查询的整体效率。</li><li>1.7链表插入使用的是头插入法，1.8中使用的是尾插入法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好直接使用尾插入法。</li><li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法目的是提高散列性，来提供HashMpa的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。</li></ul><hr><h4 id="说一下HashMap的Put方法"><a href="#说一下HashMap的Put方法" class="headerlink" title="说一下HashMap的Put方法"></a>说一下HashMap的Put方法</h4><ul><li><p>根据key通过哈希算法与运算得出数组下标</p></li><li><p>如果数组下标元素为空，则将key和value封装问Entry对象（JDK1.7中为Entry对象，1.8中为Node对象）并放入该位置。</p></li><li><p>如果数组下标不为空，则分情况讨论：</p></li><li><p>如果是JDK1.7，则先判断是否扩容，如果要扩容就扩容，如果不需要扩容就生成Entry对象，并使用头插法添加到当前位置的链表中。</p></li><li><p>如果是JDK1.8，则会先判断当前位置的Node类型，看红黑树Node，还是链表Node</p></li><li><p>如果是红黑树Node，则先将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树是否存在当前的key，如果存在则更新value。</p><ul><li>如果此位置上的Node对象为链表节点，则将key和value封装为一个链表Node并通过尾插法插入链表最后的位置，因为是尾插法，所以需要遍历链表，在遍历链表的过程中判断是否存在当前的key，如果存在则更新当前的value，当遍历完链表后，将新链表Ndoe插入链表中，插入到链表后，会看当前链表节点个数，如果大于等于8，那么会将链表转换为红黑树。</li><li>将key和value封装为Node插入到链表或红黑树中，再判断是否要进行扩容，如果需要就扩容，如果不需要就结束Put方法。</li></ul></li></ul><hr><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ul><li>深拷贝和浅拷贝就是值拷贝对象，一个对象存在两种类型的属性，一种是基本数据类型，一种是实例对象的应用。<ul><li>深拷贝：即会拷贝数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部属性指向的不是同一个对象。</li><li>浅拷贝：只会拷贝数据类型的值，以及实例的引用地址，并不会复制一份引用地址所指向的对象，也就是说浅拷贝出来的对象，内部类的属性指向的是同一个对象。</li></ul></li></ul><hr><h4 id="HashMap的扩容机制原理"><a href="#HashMap的扩容机制原理" class="headerlink" title="HashMap的扩容机制原理"></a>HashMap的扩容机制原理</h4><ul><li><p>1.7版本</p><ul><li>先组成新的数组。</li><li>遍历老数组中的每个位置上的链表上的每个元素。</li><li>取每个元素的key，并基于新数组的长度，计算每个元素在新数组的下标。</li><li>将元素添加到新数组中。</li><li>所有元素转移后，将新数组赋值给HashMap对象的table属性。</li></ul></li><li><p>1.8版本</p><ul><li><p>先组成新的数组</p></li><li><p>遍历老数组每个位置上的链表或者红黑树。</p></li><li><p>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中。</p></li><li><p>如果是红黑树，则先遍历红黑树，先计算红黑树中每个元素对应在新数组的下标位置。</p><ul><li>统计每个下标位置的元素个数。</li></ul></li><li><p>如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点添加到新数组对应的位置。</p></li><li><p>如果该位置下的元素个数没超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置。</p></li><li><p>所有元素转移完后，将新数组复制给HashMap对象的table属性。</p></li></ul></li></ul><hr><h4 id="CopyOnWriteArrayList的底层原理是怎样的"><a href="#CopyOnWriteArrayList的底层原理是怎样的" class="headerlink" title="CopyOnWriteArrayList的底层原理是怎样的"></a>CopyOnWriteArrayList的底层原理是怎样的</h4><ul><li>⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素 时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏</li><li>并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题 </li><li>写操作结束之后会把原数组指向新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应 ⽤场景，但是CopyOnWriteArrayList会⽐较占内存，同时可能读到的数据不是实时最新的数据，所 以不适合实时性要求很⾼的场景</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;JDK、JRE、JVM之间的联系&quot;&gt;&lt;a href=&quot;#JDK、JRE、JVM之间的联系&quot; class=&quot;headerlink&quot; title=&quot;JDK、JRE、JVM之间的联系&quot;&gt;&lt;/a&gt;JDK、JRE、JVM之间的联系&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JDK：java</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://example.com/2022/08/16/Spring/"/>
    <id>http://example.com/2022/08/16/Spring/</id>
    <published>2022-08-16T15:23:46.734Z</published>
    <updated>2022-08-18T09:00:26.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>框架源自于建筑学，隶属土木工程，后发展到软件工程领域</p><p>软件工程框架：经过验证的，具有一定功能的，半成品软件</p><ul><li><p>经过验证</p></li><li><p>具有一定功能</p></li><li><p>半成品</p></li></ul><p>框架作用：</p><ul><li><p>提高开发效率</p></li><li><p>增强可重用性</p></li><li><p>提供编写规范</p></li><li><p>节约维护成本</p></li><li><p>解耦底层实现原理</p></li></ul><p>参考视频：<a href="https://space.bilibili.com/37974444">https://space.bilibili.com/37974444</a></p><hr><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是分层的 JavaSE&#x2F;EE 应用 full-stack 轻量级开源框架</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.png"></p><p>Spring 优点：</p><ul><li>方便解耦，简化开发</li><li>方便集成各种框架</li><li>方便程序测试</li><li>AOP 编程难过的支持</li><li>声明式事务的支持</li><li>降低 JavaEE API 的使用难度</li></ul><p>体系结构：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><hr><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><ul><li>IoC（Inversion Of Control）控制反转，Spring 反向控制应用程序所需要使用的外部资源</li><li><strong>Spring 控制的资源全部放置在 Spring 容器中，该容器称为 IoC 容器</strong>（存放实例对象）</li><li>官方网站：<a href="https://spring.io/">https://spring.io/</a> → Projects → spring-framework → LEARN → Reference Doc</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E4%BB%8B%E7%BB%8D.png"></p><ul><li>耦合（Coupling）：代码编写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度</li><li>内聚（Cohesion）：代码编写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系</li><li>代码编写的目标：高内聚，低耦合。同一个模块内的各个元素之间要高度紧密，各个模块之间的相互依存度不紧密</li></ul><hr><h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>模拟三层架构中表现层调用业务层功能</p><ul><li><p>表现层：UserApp 模拟 UserServlet（使用 main 方法模拟）</p></li><li><p>业务层：UserService</p></li></ul><p>步骤：</p><ol><li><p>导入 spring 坐标（5.1.9.release）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写业务层与表现层（模拟）接口与实现类 service.UserService，service.impl.UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//业务方法  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建立 Spring 配置文件：resources.<strong>applicationContext</strong>.xml (名字一般使用该格式)</p></li><li><p>配置所需资源（Service）为 Spring 控制的资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.创建spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表现层（App）通过 Spring 获取资源（Service 实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2.加载配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取资源</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E5%AE%9E%E7%8E%B0.png"></p></li></ol><hr><h3 id="XML开发"><a href="#XML开发" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>标签：<bean> 标签，<beans> 的子标签</p><p>作用：定义 Spring 中的资源，受此标签定义的资源将受到 Spring 控制</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性</p><ul><li>id：bean 的名称，通过 id 值获取 bean (首字母小写)</li><li>class：bean 的类型，使用完全限定类名</li><li>name：bean 的名称，可以通过 name 值获取 bean，用于多人配合时给 bean 起别名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanId&quot;</span> <span class="attr">name</span>=<span class="string">&quot;beanName1,beanName2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ClassName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getBean(<span class="string">&quot;beanId&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName1&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName2&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>作用：定义 bean 的作用范围</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取值：</p><ul><li>singleton：设定创建出的对象保存在 Spring 容器中，是一个单例的对象</li><li>prototype：设定创建出的对象保存在 Spring 容器中，是一个非单例（原型）的对象</li><li>request、session、application、 websocket ：设定创建出的对象放置在 web 容器对应的位置</li></ul><p>Spring 容器中 Bean 的<strong>线程安全</strong>问题：</p><ul><li><p>原型 Bean，每次创建一个新对象，线程之间并不存在 Bean 共享，所以不会有线程安全的问题</p></li><li><p>单例 Bean，所有线程共享一个单例实例 Bean，因此是存在资源的竞争，如果单例 Bean是一个<strong>无状态 Bean</strong>，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的</p><p>解决方法：开发人员来进行线程安全的保证，最简单的办法就是把 Bean 的作用域 singleton 改为 protopyte</p></li></ul><hr><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>作用：定义 bean 对象在初始化或销毁时完成的工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&gt;&lt;/bean&gt;</span></span></span><br></pre></td></tr></table></figure><p>取值：bean 对应的类中对应的具体方法名</p><p>实现接口的方式实现初始化，无需配置文件配置 init-method：</p><ul><li>实现 InitializingBean，定义初始化逻辑</li><li>实现 DisposableBean，定义销毁逻辑</li></ul><p>注意事项：</p><ul><li>当 scope&#x3D;“singleton” 时，Spring 容器中有且仅有一个对象，init 方法在创建容器时仅执行一次</li><li>当 scope&#x3D;“prototype” 时，Spring 容器要创建同一类型的多个对象，init 方法在每个对象创建时均执行一次</li><li>当 scope&#x3D;“singleton” 时，关闭容器（<code>.close()</code>）会导致 bean 实例的销毁，调用 destroy 方法一次</li><li>当 scope&#x3D;“prototype” 时，对象的销毁由垃圾回收机制 GC 控制，destroy 方法将不会被执行</li></ul><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--init-method和destroy-method用于控制bean的生命周期--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>业务层实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; constructor is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService3&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul><li><p>静态工厂</p><p>作用：定义 bean 对象创建方式，使用静态工厂的形式创建 bean，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;FactoryClassName&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取值：工厂 bean 中用于获取对象的静态方法名</p><p>注意事项：class 属性必须配置成静态工厂的类名</p><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂创建 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService4&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例工厂</p><p>作用：定义 bean 对象创建方式，使用实例工厂的形式创建 bean，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBeanId&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>使用实例工厂创建 bean 首先需要将实例工厂配置 bean，交由 Spring 进行管理</p></li><li><p>factory-bean 是实例工厂的 Id</p></li></ul><p>bean 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实例工厂创建 bean，依赖工厂对象对应的 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService5&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; instance factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h5><p>ApplicationContext 子类相关API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String[] getBeanDefinitionNames()</td><td>获取 Spring 容器中定义的所有 JavaBean 的名称</td></tr><tr><td>BeanDefinition getBeanDefinition(String beanName)</td><td>返回给定 bean 名称的 BeanDefinition</td></tr><tr><td>String[] getBeanNamesForType(Class&lt;?&gt; type)</td><td>获取 Spring 容器中指定类型的所有 JavaBean 的名称</td></tr><tr><td>Environment getEnvironment()</td><td>获取与此组件关联的环境</td></tr></tbody></table><hr><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><ul><li><p>IoC（Inversion Of Control）控制翻转，Spring 反向控制应用程序所需要使用的外部资源</p></li><li><p>DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由 Spring 为其提供，资源进入应用程序的方式称为注入，简单说就是利用反射机制为类的属性赋值的操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-DI%E4%BB%8B%E7%BB%8D.png"></p></li></ul><p>IoC 和 DI 的关系：IoC 与 DI 是同一件事站在不同角度看待问题</p><hr><h5 id="set-注入"><a href="#set-注入" class="headerlink" title="set 注入"></a>set 注入</h5><p>标签：<property> 标签，<bean> 的子标签</p><p>作用：使用 set 方法的形式为 bean 提供资源</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>name：对应 bean 中的属性名，要注入的变量名，要求该属性必须提供可访问的 set 方法（严格规范此名称是 set 方法对应名称，首字母必须小写）</li><li>value：设定非引用类型属性对应的值，<strong>不能与 ref 同时使用</strong></li><li>ref：设定引用类型属性对应 bean 的 id ，不能与 value 同时使用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.对需要进行注入的变量添加set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        userDao.save();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.将要注入的资源声明为bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.将要注入的引用类型的变量通过property属性进行注入，--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>标签：<constructor-arg> 标签，<bean> 的子标签</p><p>作用：使用构造方法的形式为 bean 提供资源，兼容早期遗留系统的升级工作</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> /&gt;</span></span><br><span class="line">    .....<span class="comment">&lt;!--一个bean可以有多个constructor-arg标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>name：对应bean中的构造方法所携带的参数名</li><li>value：设定非引用类型构造方法参数对应的值，不能与 ref 同时使用</li><li>ref：设定引用类型构造方法参数对应 bean 的 id ，不能与 value 同时使用</li><li>type：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验</li><li>index：设定构造方法参数的位置，用于按位置匹配参数，参数 index 值从 0 开始计数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;argsName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;argsValue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;arg-index&quot;</span> <span class="attr">type</span>=<span class="string">&quot;arg-type&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(String driver,String username, String pwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+username+<span class="string">&quot; &quot;</span>+pwd+<span class="string">&quot; &quot;</span>+driver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层：参考 set 注入</p></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用构造方法进行注入，需要保障注入的属性与bean中定义的属性一致--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一致指顺序一致或类型一致或使用index解决该问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用 UserServiceImpl 的构造方法注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：参考 set 注入</p></li></ul><hr><h5 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h5><p>标签：<array> <list> <set> <map> <props>，<property> 或 <constructor-arg> 标签的子标签</p><p>作用：注入集合数据类型属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li><p>DAO 层：要注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList al;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> HashSet hs;</span><br><span class="line">    <span class="keyword">private</span> HashMap hm ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAl</span><span class="params">(ArrayList al)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.al = al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArr</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHs</span><span class="params">(HashSet hs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hs = hs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHm</span><span class="params">(HashMap hm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hm = hm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao running...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList:&quot;</span> + al);</span><br><span class="line">        System.out.println(<span class="string">&quot;Properties:&quot;</span> + properties);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet:&quot;</span> + hs);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap:&quot;</span> + hm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;al&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>seazean666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span>&gt;</span>666666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;seazean66666&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6666666666&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>标签：&lt;p:propertyName&gt;，&lt;p:propertyName-ref&gt;</p><p>作用：为 bean 注入属性值</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">p:propertyName</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">p:propertyName-ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>开启 p 命令空间：开启 Spring 对 p 命令空间的的支持，在 beans 标签中添加对应空间支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="string"><span class="tag">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:bookDao-ref</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:num</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><p>Spring 提供了对 EL 表达式的支持，统一属性注入格式</p><p>作用：为 bean 注入属性值</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;EL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：所有属性值不区分是否引用类型，统一使用value赋值</p><p>所有格式统一使用  value&#x3D;“#{}”</p><ul><li><p>常量  #{10}  #{3.14}  #{2e5}  #{‘it’}</p></li><li><p>引用 bean  #{beanId}    </p></li><li><p>引用 bean 属性  #{beanId.propertyName}</p></li><li><p>引用 bean 方法  beanId.methodName().method2()</p></li><li><p>引用静态方法  T(java.lang.Math).PI</p></li><li><p>运算符支持  #{3 lt 4 &#x3D;&#x3D; 4 ge 3}</p></li><li><p>正则表达式支持  #{user.name matches‘[a-z]{6,}’}</p></li><li><p>集合支持  #{likes[3]}</p></li></ul><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;userDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;bookDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;666666666&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>Spring 提供了读取外部 properties 文件的机制，使用读取到的数据为 bean 的属性赋值</p><p>操作步骤：</p><ol><li><p>准备外部 properties 文件</p></li><li><p>开启 context 命名空间支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载指定的 properties 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:data.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用加载的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;propertiesName&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：如果需要加载所有的 properties 文件，可以使用 <code>*.properties</code> 表示加载所有的 properties 文件</p></li><li><p>注意：读取数据使用 <strong>${propertiesName}</strong> 格式进行，其中 propertiesName 指 properties 文件中的属性名</p></li></ul><p>代码实现：</p><ul><li><p>data.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>DAO 层：注入的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+userName+<span class="string">&quot; &quot;</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>标签：<import>，<beans>标签的子标签</p><p>作用：在当前配置文件中导入其他配置文件中的项</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>resource：加载的配置文件名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">“config2.xml</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 容器加载多个配置文件：</p><ul><li><p>applicationContext-book.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext-user.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-user.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-book.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.seazean.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext-user.xml&quot;</span>,<span class="string">&quot;applicationContext-book.xml&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>Spring 容器中的 bean 定义冲突问题</p><ul><li><p>同 id 的 bean，后定义的覆盖先定义的</p></li><li><p>导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置，程序执行选择最下面的配置使用</p></li><li><p>导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同</p></li></ul><hr><h4 id="三方资源"><a href="#三方资源" class="headerlink" title="三方资源"></a>三方资源</h4><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>第三方资源配置</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载druid资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">datasource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;datasource&quot;</span>);</span><br><span class="line">System.out.println(datasource);</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h5><p>Mybatis 核心配置文件消失</p><ul><li><p>环境 environment 转换成数据源对象</p></li><li><p>映射 Mapper 扫描工作交由 Spring 处理</p></li><li><p>类型别名交由 Spring 处理</p></li></ul><p>DAO 接口不需要创建实现类，MyBatis-Spring 提供了一个动态代理的实现 <strong>MapperFactoryBean</strong>，这个类可以让直接注入数据映射器接口到 service 层 bean 中，底层将会动态代理创建类</p><p>整合原理：利用 Spring 框架的 SPI 机制，在 META-INF 目录的 spring.handlers 中给 Spring 容器中导入 NamespaceHandler 类</p><ul><li><p>NamespaceHandler 的 init 方法注册 bean 信息的解析器 MapperScannerBeanDefinitionParser</p></li><li><p>解析器在 Spring 容器创建过程中去<strong>解析 mapperScanner 标签</strong>，解析出的属性填充到 MapperScannerConfigurer 中</p></li><li><p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口，重写 postProcessBeanDefinitionRegistry() 方法，可以扫描到 MyBatis 的 Mapper</p></li></ul><hr><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h4><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>启动注解扫描，加载类中配置的注解项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName1,packageName2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在进行包扫描时，会对配置的包及其子包中所有文件进行扫描，多个包采用<code>,</code>隔开</li><li>扫描过程是以文件夹递归迭代的形式进行的</li><li>扫描过程仅读取合法的 Java 文件</li><li>扫描时仅读取 Spring 可识别的注解</li><li>扫描结束后会将可识别的有效注解转化为 Spring 对应的资源加入 IoC 容器</li><li>从加载效率上来说注解优于 XML 配置文件</li></ul><p>注解：启动时使用注解的形式替代 xml 配置，将 Spring 配置文件从工程中消除，简化书写</p><p>缺点：为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂。XML 中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%A4%BA%E4%BE%8B.png"></p><hr><h5 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解配置类</p><p>名称：@Configuration、@ComponentScan</p><p>类型：类注解</p><p>作用：<strong>设置当前类为 Spring 核心配置加载类</strong></p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;scanPackageName1&quot;,&quot;scanPackageName2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>核心配合类用于替换 Spring 核心配置文件，此类可以设置空的，不设置变量与属性</li><li>bean 扫描工作使用注解 @ComponentScan 替代，多个包用 <code>&#123;&#125; 和 ,</code> 隔开</li></ul><p>加载纯注解格式上下文对象，需要使用 <strong>AnnotationConfigApplicationContext</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">//方式一：名称对应类名</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：名称对应方法名 </span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean1</span> <span class="operator">=</span> (Person) applicationContext.getBean(<span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法三：指定名称@Bean(&quot;person2&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h5><p>组件扫描过滤器</p><p>开发过程中，需要根据需求加载必要的 bean，排除指定 bean</p><p>名称：@ComponentScan</p><p>类型：<strong>类注解</strong></p><p>作用：设置 Spring 配置加载类扫描规则</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,//设置基础扫描路径</span></span><br><span class="line"><span class="meta">    excludeFilters =//设置过滤规则，当前为排除过滤</span></span><br><span class="line"><span class="meta">@ComponentScan.Filter(//设置过滤器</span></span><br><span class="line"><span class="meta">    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤</span></span><br><span class="line"><span class="meta">    classes = Service.class)     //设置具体的过滤项，过滤所有@Service修饰的bean</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>includeFilters：设置包含性过滤器 </li><li>excludeFilters：设置排除性过滤器</li><li>type：设置过滤器类型</li></ul><hr><h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="设置-bean"><a href="#设置-bean" class="headerlink" title="设置 bean"></a>设置 bean</h5><p>名称：@Component、@Controller、@Service、@Repository</p><p>类型：类注解，写在类定义上方</p><p>作用：设置该类为 Spring 管理的 bean</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：@Controller、@Service 、@Repository 是 @Component 的衍生注解，功能同 @Component</p><p>属性：</p><ul><li>value（默认）：定义 bean 的访问 id</li></ul><hr><h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>名称：@Scope</p><p>类型：类注解，写在类定义上方</p><p>作用：设置该类作为 bean 对应的 scope 属性</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>相关属性</p><ul><li>value（默认）：定义 bean 的作用域，默认为 singleton，非单例取值 prototype</li></ul><hr><h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>名称：@PostConstruct、@PreDestroy</p><p>类型：方法注解，写在方法定义上方</p><p>作用：设置该类作为 bean 对应的生命周期方法</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义bean，后面添加bean的id</span></span><br><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//定义bean的作用域</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个对象的执行顺序：Constructor &gt;&gt; @Autowired（注入属性） &gt;&gt; @PostConstruct（初始化逻辑）</p><hr><h5 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h5><p>名称：@Bean</p><p>类型：方法注解</p><p>作用：设置该方法的返回值作为 Spring 管理的 bean</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;    <span class="keyword">return</span> ……;    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>因为第三方 bean 无法在其源码上进行修改，使用 @Bean 解决第三方 bean 的引入问题</p></li><li><p>该注解用于替代 XML 配置中的静态工厂与实例工厂创建 bean，不区分方法是否为静态或非静态</p></li><li><p>@Bean 所在的类必须被 Spring 扫描加载，否则该注解无法生效</p></li></ul><p>相关属性</p><ul><li>value（默认）：定义 bean 的访问 id</li><li>initMethod：声明初始化方法</li><li>destroyMethod：声明销毁方法</li></ul><hr><h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>名称：@Value</p><p>类型：属性注解、方法注解</p><p>作用：设置对应属性的值或对方法进行传参</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>value 值<strong>仅支持非引用类型数据</strong>，赋值时对方法的所有参数全部赋值</p></li><li><p>value 值支持读取 properties 文件中的属性值，通过类属性将 properties 中数据传入类中</p></li><li><p>value 值支持 SpEL</p></li><li><p>@value 注解如果添加在属性上方，可以省略 set 方法（set 方法的目的是为属性赋值）</p></li></ul><p>相关属性：</p><ul><li>value（默认）：定义对应的属性值或参数值</li></ul><hr><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><h6 id="属性注入-1"><a href="#属性注入-1" class="headerlink" title="属性注入"></a>属性注入</h6><p>名称：@Autowired、@Qualifier</p><p>类型：属性注解、方法注解</p><p>作用：设置对应属性的对象、对方法进行引用类型传参</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Autowired 默认按类型装配，指定 @Qualifier 后可以指定自动装配的 bean 的 id</li></ul><p>相关属性：</p><ul><li>required：<strong>为 true （默认）表示注入 bean 时该 bean 必须存在</strong>，不然就会注入失败抛出异常；为 false  表示注入时该 bean 存在就注入，不存在就忽略跳过</li></ul><p>注意：在使用 @Autowired 时，首先在容器中查询对应类型的 bean，如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据，如果查询的结果不止一个，那么 @Autowired 会根据名称来查找，如果查询的结果为空，那么会抛出异常</p><p>解决方法：使用 required &#x3D; false</p><hr><h6 id="优先注入"><a href="#优先注入" class="headerlink" title="优先注入"></a>优先注入</h6><p>名称：@Primary</p><p>类型：类注解</p><p>作用：设置类对应的 bean 按类型装配时优先装配</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Autowired 默认按类型装配，当出现相同类型的 bean，使用 @Primary 提高按类型自动装配的优先级，多个 @Primary 会导致优先级设置无效</li></ul><hr><h6 id="注解对比"><a href="#注解对比" class="headerlink" title="注解对比"></a>注解对比</h6><p>名称：@Inject、@Named、@Resource</p><ul><li>@Inject 与 @Named 是 JSR330 规范中的注解，功能与 @Autowired 和 @Qualifier 完全相同，适用于不同架构场景</li><li>@Resource 是 JSR250 规范中的注解，可以简化书写格式</li></ul><p>@Resource 相关属性</p><ul><li><p>name：设置注入的 bean 的 id</p></li><li><p>type：设置注入的 bean 的类型，接收的参数为 Class 类型</p></li></ul><p>@Autowired 和 @Resource之间的区别：</p><ul><li><p>@Autowired 默认是<strong>按照类型装配</strong>注入，默认情况下它要求依赖对象必须存在（可以设置 required 属性为 false）</p></li><li><p>@Resource 默认<strong>按照名称装配</strong>注入，只有当找不到与名称匹配的 bean 才会按照类型来装配注入</p></li></ul><hr><h5 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h5><p>Spring 容器管理的都是实例对象，**@Autowired 依赖注入的都是容器内的对象实例**，在 Java 中 static 修饰的静态属性（变量和方法）是属于类的，而非属于实例对象</p><p>当类加载器加载静态变量时，Spring 上下文尚未加载，所以类加载器不会在 Bean 中正确注入静态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译正常，但运行时报java.lang.NullPointerException，所以在调用testMethod()方法时，component变量还没被初始化</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li><p>@Autowired 注解到<strong>类的构造函数</strong>上，Spring 扫描到 Component 的 Bean，然后赋给静态变量 component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClass</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        TestClass.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Autowired 注解到<strong>静态属性的 setter 方法</strong>上</p></li><li><p>使用 @PostConstruct 注解一个方法，在方法内为 static 静态成员赋值</p></li><li><p>使用 Spring 框架工具类获取 bean，定义成局部变量使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> SpringApplicationContextUtil.getBean(<span class="string">&quot;component&quot;</span>);</span><br><span class="line">      component.callTestMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="http://jessehzx.top/2018/03/18/spring-autowired-static-field/">http://jessehzx.top/2018/03/18/spring-autowired-static-field/</a></p><hr><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>名称：@PropertySource</p><p>类型：类注解</p><p>作用：加载 properties 文件中的属性值</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:filename.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;propertiesAttributeName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String attributeName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>不支持 * 通配符，加载后，所有 Spring 控制的 bean 中均可使用对应属性值，加载多个需要用 <code>&#123;&#125; 和 ,</code> 隔开</li></ul><p>相关属性</p><ul><li><p>value（默认）：设置加载的 properties 文件名</p></li><li><p>ignoreResourceNotFound：如果资源未找到，是否忽略，默认为 false</p></li></ul><hr><h4 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h4><h5 id="依赖加载"><a href="#依赖加载" class="headerlink" title="依赖加载"></a>依赖加载</h5><p>@DependsOn</p><ul><li><p>名称：@DependsOn</p></li><li><p>类型：类注解、方法注解</p></li><li><p>作用：控制 bean 的加载顺序，使其在指定 bean 加载完毕后再加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;beanId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>配置在方法上，使 @DependsOn 指定的 bean 优先于 @Bean 配置的 bean 进行加载</p></li><li><p>配置在类上，使 @DependsOn 指定的 bean 优先于当前类中所有 @Bean 配置的 bean 进行加载</p></li><li><p>配置在类上，使 @DependsOn 指定的 bean 优先于 @Component 等配置的 bean 进行加载</p></li></ul></li><li><p>相关属性</p><ul><li>value（默认）：设置当前 bean 所依赖的 bean 的 id</li></ul></li></ul><p>@Order</p><ul><li><p>名称：@Order</p></li><li><p>类型：<strong>配置类注解</strong></p></li><li><p>作用：控制配置类的加载顺序，值越小越先加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>@Lazy</p><ul><li><p>名称：@Lazy</p></li><li><p>类型：类注解、方法注解</p></li><li><p>作用：控制 bean 的加载时机，使其延迟加载，获取的时候加载</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>@DependsOn</p><ul><li><p>微信订阅号，发布消息和订阅消息的 bean 的加载顺序控制（先开订阅，再发布）</p></li><li><p>双 11 活动，零点前是结算策略 A，零点后是结算策略 B，策略 B 操作的数据为促销数据，策略 B 加载顺序与促销数据的加载顺序</p></li></ul><p>@Lazy</p><ul><li>程序灾难出现后对应的应急预案处理是启动容器时加载时机</li></ul><p>@Order</p><ul><li>多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制</li></ul><hr><h4 id="整合资源"><a href="#整合资源" class="headerlink" title="整合资源"></a>整合资源</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>名称：@Import</p><p>类型：类注解</p><p>作用：导入第三方 bean 作为 Spring 控制的资源，这些类都会被 Spring 创建并放入 ioc 容器</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherClassName.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>@Import 注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定</li><li>在被导入的类中可以继续使用 @Import 导入其他资源</li><li>@Bean 所在的类可以使用导入的形式进入 Spring 容器，无需声明为 bean</li></ul><hr><h5 id="Druid-1"><a href="#Druid-1" class="headerlink" title="Druid"></a>Druid</h5><ul><li><p>加载资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;service&quot;,&quot;dao&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(JDBCConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">System.out.println(dataSource);</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h5><p>Spring 接管 Junit 的运行权，使用 Spring 专用的 Junit 类加载器，为 Junit 测试用例设定对应的 Spring 容器</p><p>注意：</p><ul><li><p>从 Spring5.0 以后，要求 Junit 的版本必须是4.12及以上</p></li><li><p>Junit 仅用于单元测试，不能将 Junit 的测试类配置成 Spring 的 bean，否则该配置将会被打包进入工程中</p></li></ul><p>test &#x2F; java &#x2F; service &#x2F; UserServiceTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定spring专用的类加载器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//设定加载的spring上下文对应的配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Mike&quot;</span>, account.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>ApplicationContext：</p><ol><li><p>ApplicationContext 是一个接口，提供了访问 Spring 容器的 API</p></li><li><p>ClassPathXmlApplicationContext 是一个类，实现了上述功能</p></li><li><p>ApplicationContext 的顶层接口是 BeanFactory</p></li><li><p>BeanFactory 定义了 bean 相关的最基本操作</p></li><li><p>ApplicationContext 在 BeanFactory 基础上追加了若干新功能</p></li></ol><p><strong>ApplicationContext 和 BeanFactory对比：</strong></p><ul><li><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器</p></li><li><p>BeanFactory 是 Spring 里面最底层的接口，是 IoC 的核心，定义了 IoC 的基本功能，包含了各种 Bean 的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext 接口作为 BeanFactory 的子类，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承 MessageSource，因此支持国际化</li><li>资源文件访问，如 URL 和文件（ResourceLoader）。</li><li>载入多个（有继承关系）上下文（即加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li><li>提供在监听器中注册 bean 的事件</li></ul></li><li><p>BeanFactory 创建的 bean 采用延迟加载形式，只有在使用到某个 Bean 时（调用 getBean），才对该 Bean 进行加载实例化（Spring 早期使用该方法获取 bean），这样就不能提前发现一些存在的 Spring 的配置问题；ApplicationContext 是在容器启动时，一次性创建了所有的 Bean，容器启动时，就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入</p></li><li><p>ApplicationContext 启动后预载入所有的单实例 Bean，所以程序启动慢，运行时速度快</p></li><li><p>两者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</p></li></ul><p>FileSystemXmlApplicationContext：加载文件系统中任意位置的配置文件，而 ClassPathXmlAC 只能加载类路径下的配置文件</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>BeanFactory 的成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>区分是 FactoryBean 还是创建的 Bean，加上 &amp; 代表是工厂，getBean 将会返回工厂</li><li>FactoryBean：如果某个 bean 的配置非常复杂，或者想要使用编码的形式去构建它，可以提供一个构建该 bean 实例的工厂，这个工厂就是 FactoryBean 接口实现类，FactoryBean 接口实现类也是需要 Spring 管理<ul><li>这里产生两种对象，一种是 FactoryBean 接口实现类（IOC 管理），另一种是 FactoryBean 接口内部管理的对象</li><li>获取 FactoryBean 接口实现类，使用 getBean 时传的 beanName 需要带 &amp; 开头</li><li>获取 FactoryBean 内部管理的对象，不需要带 &amp; 开头</li></ul></li></ul><p>BeanFactory 的基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(res);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>FactoryBean：对单一的 bean 的初始化过程进行封装，达到简化配置的目的</p><p>FactoryBean与 BeanFactory 区别：</p><ul><li><p>FactoryBean：封装单个 bean 的创建过程，就是工厂的 Bean</p></li><li><p>BeanFactory：Spring 容器顶层接口，定义了 bean 相关的获取操作</p></li></ul><p>代码实现：</p><ul><li><p>FactoryBean，实现类一般是 MapperFactoryBean，创建 DAO 层接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EquipmentDaoImplFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//获取Bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EquipmentDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//获取bean的类型</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//是否单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MapperFactoryBean 继承 SqlSessionDaoSupport，可以获取 SqlSessionTemplate，完成 MyBatis 的整合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"><span class="comment">// 获取 SqlSessionTemplate 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate == <span class="literal">null</span> || </span><br><span class="line">        sqlSessionFactory != <span class="built_in">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><ul><li><p>DAO 层 UserDao、AccountDao、BookDao、EquipmentDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;<span class="comment">//...........BookDao等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h5><p>名称：TypeFilter</p><p>类型：<strong>接口</strong></p><p>作用：自定义类型过滤器</p><p>示例：</p><ul><li><p>config &#x2F; filter &#x2F; MyTypeFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">    * metadataReaderFactory:可以获取到任何其他类的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//加载的类满足要求，匹配成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取当前类注解的信息</span></span><br><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">am</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line"><span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line"><span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过类的元数据获取类的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classMetadata.getClassName();</span><br><span class="line">        <span class="comment">//如果加载的类名满足过滤器要求，返回匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(className.equals(<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>))&#123;</span><br><span class="line">       <span class="comment">//返回true表示匹配成功，返回false表示匹配失败。此处仅确认匹配结果，不会确认是排除还是加入，排除/加入由配置项决定，与此处无关</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//设置排除bean，排除的规则是自定义规则（FilterType.CUSTOM），具体的规则定义为MyTypeFilter</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type= FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">                classes = MyTypeFilter.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="导入器"><a href="#导入器" class="headerlink" title="导入器"></a>导入器</h4><p>bean 只有通过配置才可以进入 Spring 容器，被 Spring 加载并控制</p><ul><li><p>配置 bean 的方式如下：</p><ul><li>XML 文件中使用 <bean/> 标签配置</li><li>使用 @Component 及衍生注解配置</li></ul></li></ul><p>导入器可以快速高效导入大量 bean，替代 @Import({a.class,b.class})，无需在每个类上添加 @Bean</p><p>名称： ImportSelector</p><p>类型：<strong>接口</strong></p><p>作用：自定义bean导入器</p><ul><li><p>selector &#x2F; MyImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">//      1.编程形式加载一个类</span></span><br><span class="line"><span class="comment">//      return new String[]&#123;&quot;dao.impl.BookDaoImpl&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">//      ResourceBundle bundle = ResourceBundle.getBundle(&quot;import&quot;);</span></span><br><span class="line"><span class="comment">//      String className = bundle.getString(&quot;className&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      3.加载import.properties文件中的多个类名</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;import&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> className.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>import.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#3.加载import.properties文件中的多个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl,dao.impl.AccountDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#4.导入包中的所有类</span></span><br><span class="line"><span class="attr">path</span>=<span class="string">dao.impl.*</span></span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;dao&quot;,&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="注册器"><a href="#注册器" class="headerlink" title="注册器"></a>注册器</h4><p>可以取代 ComponentScan 扫描器</p><p>名称：ImportBeanDefinitionRegistrar</p><p>类型：<strong>接口</strong></p><p>作用：自定义 bean 定义注册器</p><ul><li><p>registrar &#x2F; MyImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata:当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类，把所有需要添加到容器中的bean调用registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//自定义注册器</span></span><br><span class="line">        <span class="comment">//1.开启类路径bean定义扫描器，需要参数bean定义注册器BeanDefinitionRegistry，需要制定是否使用默认类型过滤器</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//2.添加包含性加载类型过滤器（可选，也可以设置为排除性加载类型过滤器）</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">TypeFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//所有匹配全部成功，此处应该添加实际的业务判定条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置扫描路径</span></span><br><span class="line">        scanner.addExcludeFilter(tf);<span class="comment">//排除</span></span><br><span class="line">        scanner.scan(<span class="string">&quot;dao&quot;</span>,<span class="string">&quot;service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>通过创建类<strong>继承相应的处理器的接口</strong>，重写后置处理的方法，来实现<strong>拦截 Bean 的生命周期</strong>来实现自己自定义的逻辑</p><p>BeanPostProcessor：bean 后置处理器，bean 创建对象初始化前后进行拦截工作的</p><p>BeanFactoryPostProcessor：beanFactory 的后置处理器</p><ul><li><pre><code>    加载时机：在 BeanFactory 初始化之后调用，来定制和修改 BeanFactory 的内容；所有的 bean 定义已经保存加载到 beanFactory，但是 bean 的实例还未创建</code></pre></li><li><pre><code>    执行流程：</code></pre><ul><li>ioc 容器创建对象</li><li>invokeBeanFactoryPostProcessors(beanFactory)：执行 BeanFactoryPostProcessor<ul><li>在 BeanFactory 中找到所有类型是 BeanFactoryPostProcessor 的组件，并执行它们的方法</li><li>在初始化创建其他组件前面执行</li></ul></li></ul></li></ul><p>BeanDefinitionRegistryPostProcessor：</p><ul><li><p>加载时机：在所有 bean 定义信息将要被加载，但是 bean 实例还未创建，优先于 BeanFactoryPostProcessor 执行；利用 BeanDefinitionRegistryPostProcessor 给容器中再额外添加一些组件</p></li><li><p>执行流程：</p><ul><li>ioc 容器创建对象</li><li>refresh() → invokeBeanFactoryPostProcessors(beanFactory)</li><li>从容器中获取到所有的 BeanDefinitionRegistryPostProcessor 组件<ul><li>依次触发所有的 postProcessBeanDefinitionRegistry() 方法</li><li>再来触发 postProcessBeanFactory() 方法</li></ul></li></ul></li></ul><hr><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><h5 id="基本概述-1"><a href="#基本概述-1" class="headerlink" title="基本概述"></a>基本概述</h5><p>ApplicationListener：监听容器中发布的事件，完成事件驱动模型开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt;</span><br></pre></td></tr></table></figure><p>所以监听 ApplicationEvent 及其下面的子事件</p><p>应用监听器步骤：</p><ul><li><pre><code>  写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）</code></pre></li><li><pre><code>  把监听器加入到容器 @Component</code></pre></li><li><pre><code>  只要容器中有相关事件的发布，就能监听到这个事件；*   ContextRefreshedEvent：容器刷新完成（所有 bean 都完全创建）会发布这个事件*   ContextClosedEvent：关闭容器会发布这个事件</code></pre></li><li><pre><code>  发布一个事件：`applicationContext.publishEvent()`</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt; &#123;</span><br><span class="line"><span class="comment">//当容器中发布此事件以后，方法触发</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;收到事件：&quot;</span> + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>ContextRefreshedEvent 事件：</p><ul><li><p>容器初始化过程中执行 <code>initApplicationEventMulticaster()</code>：初始化事件多播器</p><ul><li>先去容器中查询 <code>id = applicationEventMulticaster</code> 的组件，有直接返回</li><li>没有就执行 <code>this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)</code> 并且加入到容器中</li><li>以后在其他组件要派发事件，自动注入这个 applicationEventMulticaster</li></ul></li><li><p>容器初始化过程执行 <strong>registerListeners()</strong> 注册监听器</p><ul><li>从容器中获取所有监听器：<code>getBeanNamesForType(ApplicationListener.class, true, false)</code></li><li>将 listener 注册到 ApplicationEventMulticaster</li></ul></li><li><p>容器刷新完成：finishRefresh() → publishEvent(new ContextRefreshedEvent(this))</p><p>发布 ContextRefreshedEvent 事件：</p><ul><li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li><li>multicastEvent 派发事件<ul><li>获取到所有的 ApplicationListener</li><li>遍历 ApplicationListener<ul><li>如果有 Executor，可以使用 Executor 异步派发 <code>Executor executor = getTaskExecutor()</code></li><li>没有就同步执行 listener 方法 <code>invokeListener(listener, event)</code>，拿到 listener 回调 onApplicationEvent</li></ul></li></ul></li></ul></li></ul><p>容器关闭会发布 ContextClosedEvent</p><hr><h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><p>注解：@EventListener</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(classes=&#123;ApplicationEvent.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(ApplicationEvent event)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;UserService。。监听到的事件：&quot;</span> + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：使用 EventListenerMethodProcessor 处理器来解析方法上的 @EventListener，Spring 扫描使用注解的方法，并为之创建一个监听对象</p><p>SmartInitializingSingleton 原理：afterSingletonsInstantiated()</p><ul><li><pre><code>    IOC 容器创建对象并 refresh()</code></pre></li><li><pre><code>    finishBeanFactoryInitialization(beanFactory)：初始化剩下的单实例 bean</code></pre><ul><li>先创建所有的单实例 bean：getBean()</li><li>获取所有创建好的单实例 bean，判断是否是 SmartInitializingSingleton 类型的，如果是就调用 afterSingletonsInstantiated()</li></ul></li></ul><hr><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="基本概述-2"><a href="#基本概述-2" class="headerlink" title="基本概述"></a>基本概述</h3><p>AOP（Aspect Oriented Programing）：面向切面编程，一种编程<strong>范式</strong>，指导开发者如何组织程序结构</p><p>AOP 弥补了 OOP 的不足，基于 OOP 基础之上进行横向开发：</p><ul><li><p>uOOP 规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型</p></li><li><p>uAOP 程序开发主要关注基于 OOP 开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分），将软件开发由手工制作走向半自动化&#x2F;全自动化阶段，实现“插拔式组件体系结构”搭建</p></li></ul><p>AOP 作用：</p><ul><li><p>提高代码的可重用性</p></li><li><p>业务代码编码更简洁</p></li><li><p>业务代码维护更高效</p></li><li><p>业务功能扩展更便捷</p></li></ul><hr><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h4><ul><li><p>Joinpoint（连接点）：就是方法</p></li><li><p>Pointcut（切入点）：就是挖掉共性功能的方法</p></li><li><p>Advice（通知）：就是共性功能，最终以一个方法的形式呈现</p></li><li><p>Aspect（切面）：就是共性功能与挖的位置的对应关系</p></li><li><p>Target（目标对象）：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的</p></li><li><p>Weaving（织入）：就是将挖掉的功能回填的动态过程</p></li><li><p>Proxy（代理）：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现</p></li><li><p>Introduction（引入&#x2F;引介）：就是对原始对象无中生有的添加成员变量或成员方法</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png"></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5.png"></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5.png"></p><hr><h4 id="入门项目-1"><a href="#入门项目-1" class="headerlink" title="入门项目"></a>入门项目</h4><p>开发步骤：</p><ul><li><p>开发阶段</p><ul><li><p>制作程序</p></li><li><p>将非共性功能开发到对应的目标对象类中，并制作成切入点方法</p></li><li><p>将共性功能独立开发出来，制作成通知</p></li><li><p>在配置文件中，声明切入点</p></li><li><p>在配置文件中，声明切入点与通知间的关系（含通知类型），即切面</p></li></ul></li><li><p>运行阶段（AOP 完成）</p><ul><li><p>Spring 容器加载配置文件，监控所有配置的<strong>切入点</strong>方法的执行</p></li><li><p>当监控到切入点方法被运行，<strong>使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入</strong>，完成完整的代码逻辑并运行</p></li></ul></li></ul><ol><li><p>导入坐标 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>业务层抽取通用代码  service &#x2F; UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;共性功能&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aop.AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.制作通知类，在类中定义一个方法用于完成共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//共性功能抽取后职称独立的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;共性功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把通知加入spring容器管理，配置aop  applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--原始Spring控制资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>= <span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.配置共性功能成功spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.开启AOP命名空间: beans标签内--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4.配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--5.配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--6.配置切面（切入点与通知的关系）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--7.配置具体的切入点对应通知中那个操作方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;function&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//先输出共性功能，然后 user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="XML开发-1"><a href="#XML开发-1" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>Aspect（切面）用于描述切入点与通知间的关系，是 AOP 编程中的一个概念</p><p>AspectJ 是基于 java 语言对 Aspect 的实现</p><hr><h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>标签：<a href="aop:config">aop:config</a>，<beans> 的子标签</p><p>作用：设置 AOP</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个beans标签中可以配置多个aop:config标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="pointcut"><a href="#pointcut" class="headerlink" title="pointcut"></a>pointcut</h5><p>标签：<a href="aop:pointcut">aop:pointcut</a>，归属于 aop:config 标签和 aop:aspect 标签</p><p>作用：设置切入点</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>一个 aop:config 标签中可以配置多个 aop:pointcut 标签，且该标签可以配置在 aop:aspect 标签内</li></ul><p>属性：</p><ul><li><p>id ：识别切入点的名称</p></li><li><p>expression ：切入点表达式</p></li></ul><hr><h5 id="aspect"><a href="#aspect" class="headerlink" title="aspect"></a>aspect</h5><p>标签：<a href="aop:aspect">aop:aspect</a>，aop:config 的子标签</p><p>作用：设置具体的 AOP 通知对应的切入点（切面）</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:config标签中可以配置多个aop:aspect标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>ref ：通知所在的 bean 的 id</li></ul><hr><h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点描述的是某个方法</p><p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p><hr><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字(访问修饰符  返回值  包名.类名.方法名(参数)异常名)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配UserService中只含有一个参数的findById方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure><p>格式解析：</p><ul><li>关键字：描述表达式的匹配模式（参看关键字列表）</li><li>访问修饰符：方法的访问控制权限修饰符</li><li>类名：方法所在的类（此处可以配置接口名称）</li><li>异常：方法定义中指定抛出的异常</li></ul><p>关键字：</p><ul><li><p>execution ：匹配执行指定方法</p></li><li><p>args ：匹配带有指定参数类型的方法</p></li><li><p>within、this、target、@within、@target、@args、@annotation、bean、reference pointcut等</p></li></ul><p>通配符：</p><ul><li><p>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.seazean包下的任意包中的UserService类或接口中所有find开头的带有一个任意参数的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.seazean.*.UserService.find*(*)</span><br></pre></td></tr></table></figure></li><li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com包下的任意包中的UserService类或接口中所有名称为findById参数任意数量和类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure></li><li><p>+：专用于匹配子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配任意包下的Service结尾的类或者接口的子类或者实现类</span></span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ul><p>逻辑运算符：</p><ul><li>&amp;&amp;：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配</li><li>||：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配</li><li>! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(..))<span class="comment">//前三个都是匹配全部</span></span><br><span class="line">execution(* *..*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..)) </span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.User*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*Service.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.UserService.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.find*(..))<span class="comment">//find开头</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.*Id(..))<span class="comment">//I</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,*))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById())</span><br><span class="line">execution(List com.seazean.service.*Service+.findAll(..))</span><br></pre></td></tr></table></figure><hr><h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>XML 配置规则：</p><ul><li><p>企业开发命名规范严格遵循规范文档进行</p></li><li><p>先为方法配置局部切入点，再抽取类中公共切入点，最后抽取全局切入点</p></li><li><p>代码走查过程中检测切入点是否存在越界性包含</p></li><li><p>代码走查过程中检测切入点是否存在非包含性进驻</p></li><li><p>设定 AOP 执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配（不绝对正确：加进一个不该加的，删去一个不该删的相当于结果不变）</p></li><li><p>设定完毕的切入点如果发生调整务必进行回归测试</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.配置公共切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2.配置局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用公共切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3.直接配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p>AOP 的通知类型共5种：前置通知，后置通知、返回后通知、抛出异常后通知、环绕通知</p><h6 id="before"><a href="#before" class="headerlink" title="before"></a>before</h6><p>标签：<a href="aop:before">aop:before</a>，aop:aspect的子标签</p><p>作用：设置前置通知</p><ul><li><strong>前置通知</strong>：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行</li><li>应用：数据校验</li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:before标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><h6 id="after"><a href="#after" class="headerlink" title="after"></a>after</h6><p>标签：<a href="aop:after">aop:after</a>，aop:aspect的子标签</p><p>作用：设置后置通知</p><ul><li><p><strong>后置通知</strong>：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知</p></li><li><p>应用：现场清理</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><h6 id="after-r"><a href="#after-r" class="headerlink" title="after-r"></a>after-r</h6><p>标签：<a href="aop:after-returning">aop:after-returning</a>，aop:aspect的子标签</p><p>作用：设置返回后通知</p><ul><li><p><strong>返回后通知</strong>：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行</p></li><li><p>应用：返回值相关数据处理</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-returning标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>method：在通知类中设置当前通知类别对应的方法</li><li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li><li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li><li>returning：设置接受返回值的参数，与通知类中对应方法的参数一致</li></ul><h6 id="after-t"><a href="#after-t" class="headerlink" title="after-t"></a>after-t</h6><p>标签：<a href="aop:after-throwing">aop:after-throwing</a>，aop:aspect的子标签</p><p>作用：设置抛出异常后通知</p><ul><li><strong>抛出异常后通知</strong>：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行</li><li>应用：对原始方法中出现的异常信息进行处理</li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-throwing标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>method：在通知类中设置当前通知类别对应的方法</li><li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li><li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li><li>throwing：设置接受异常对象的参数，与通知类中对应方法的参数一致</li></ul><h6 id="around"><a href="#around" class="headerlink" title="around"></a>around</h6><p>标签：<a href="aop:around">aop:around</a>，aop:aspect的子标签</p><p>作用：设置环绕通知</p><ul><li><p><strong>环绕通知</strong>：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行</p></li><li><p>应用：功能强大，可以做任何事情</p></li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:around标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul><p>环绕通知的开发方式（参考通知顺序章节）：</p><ul><li><p>环绕通知是<strong>在原始方法的前后添加功能</strong>，在环绕通知中，存在对原始方法的显式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知方法相关说明：</p><ul><li><p>方法须设定 Object 类型的返回值，否则会<strong>拦截</strong>原始方法的返回。如果原始方法返回值类型为 void，通知方法也可以设定返回值类型为 void，最终返回 null</p></li><li><p>方法需在第一个参数位置设定 ProceedingJoinPoint 对象，通过该对象调用 proceed() 方法，实现<strong>对原始方法的调用</strong>。如省略该参数，原始方法将无法执行</p></li><li><p>使用 proceed() 方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出 Throwable 对象，封装原始方法中可能出现的异常信息</p></li></ul></li></ul><hr><h5 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h5><p>当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准。</p><ul><li><p>AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void after()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>after...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterReturing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterReturing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterThrowing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterThrowing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public Object around(ProceedingJoinPoint pjp) &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around before...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">       //对原始方法的调用</span></span><br><span class="line"><span class="string">        Object ret = pjp.proceed();</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around after...<span class="string">&quot;+ret);</span></span><br><span class="line"><span class="string">       return ret;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml  <strong>顺序执行</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>第一种方式：</p><ul><li><p>设定通知方法第一个参数为 JoinPoint，通过该对象调用 getArgs() 方法，获取原始方法运行的参数数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的通知均可以获取参数，环绕通知使用ProceedingJoinPoint.getArgs()方法</p></li></ul><p>第二种方式：</p><ul><li><p>设定切入点表达式为通知方法传递参数（锁定通知变量名）</p></li><li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p></li><li><p>解释：</p><ul><li><code>&amp;amp</code> 代表并且 &amp;</li><li>输出结果：a &#x3D; param1   b &#x3D; param2</li></ul></li></ul><p>第三种方式：</p><ul><li><p>设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）</p></li><li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%B8%89.png"></p></li><li><p>解释：输出结果 a &#x3D; param2   b &#x3D; param1</p></li></ul><hr><h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>环绕通知和返回后通知可以获取返回值，后置通知不一定，其他类型获取不到</p><p>第一种方式：适用于返回后通知（after-returning）</p><ul><li><p>设定返回值变量名</p></li><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return:&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第二种：适用于环绕通知（around）</p><ul><li><p>在通知类的方法中调用原始方法获取返回值</p></li><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> userService.save();</span><br><span class="line">       System.out.println(<span class="string">&quot;app.....&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h6><p>环绕通知和抛出异常后通知可以获取异常，后置通知不一定，其他类型获取不到</p><p>第一种：适用于返回后通知（after-throwing）</p><ul><li><p>设定异常对象变量名</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(t.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第二种：适用于环绕通知（around）</p><ul><li>在通知类的方法中调用原始方法捕获异常</li></ul><ul><li><p>原始方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类：try……catch……捕获异常后，ret为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//对此处调用进行try……catch……捕获异常，或抛出异常</span></span><br><span class="line">    <span class="comment">/* try &#123;</span></span><br><span class="line"><span class="comment">            ret = pjp.proceed();</span></span><br><span class="line"><span class="comment">        &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;around exception...&quot; + throwable.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userService.delete();</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="获取全部"><a href="#获取全部" class="headerlink" title="获取全部"></a>获取全部</h6><ul><li><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + i + <span class="string">&quot;,&quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service update running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service delete running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOPAdvice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        <span class="comment">//通过JoinPoint参数获取调用原始方法所携带的参数</span></span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturing</span><span class="params">(Object ret)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturing...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>+t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对原始方法的调用</span></span><br><span class="line">            ret = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...exception....&quot;</span>+throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;around after...&quot;</span>+ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="comment">//        userService.save(666, 888);</span></span><br><span class="line"><span class="comment">//        int ret = userService.update();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;app.....&quot; + ret);</span></span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h4><p>AOP 注解简化 XML：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.png"></p><p>注意事项：</p><ol><li><p>切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法</p></li><li><p>引用切入点时必须使用方法调用名称，方法后面的 () 不能省略</p></li><li><p>切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用</p></li><li><p>可以在通知类型注解后添加参数，实现 XML 配置中的属性，例如 after-returning 后的 returning 性</p></li></ol><hr><h4 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h4><h5 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h5><p>开启 AOP 注解支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;aop,config,service&quot;</span>/&gt;</span><span class="comment">&lt;!--启动Spring扫描--&gt;</span></span><br></pre></td></tr></table></figure><p>开发步骤：</p><ol><li>导入坐标（伴随 spring-context 坐标导入已经依赖导入完成）</li><li>开启 AOP 注解支持</li><li>配置切面 @Aspect</li><li>定义专用的切入点方法，并配置切入点 @Pointcut</li><li>为通知方法配置通知类型及对应切入点 @Before</li></ol><h5 id="纯注解-1"><a href="#纯注解-1" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解：@EnableAspectJAutoProxy</p><p>位置：Spring 注解配置类定义上方</p><p>作用：设置当前类开启 AOP 注解驱动的支持，加载 AOP 注解</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="基本注解-1"><a href="#基本注解-1" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h5><p>注解：@Aspect</p><p>位置：类定义上方</p><p>作用：设置当前类为切面类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Pointcut-1"><a href="#Pointcut-1" class="headerlink" title="Pointcut"></a>Pointcut</h5><p>注解：@Pointcut</p><p>位置：方法定义上方</p><p>作用：使用当前方法名作为切入点引用名称</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* *(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）</p><h5 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h5><p>注解：@Before</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为前置通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">//joinPoint.getArgs();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>多个参数时，JoinPoint参数一定要在第一位</strong></p><h5 id="After"><a href="#After" class="headerlink" title="After"></a>After</h5><p>注解：@After</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为后置通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AfterR"><a href="#AfterR" class="headerlink" title="AfterR"></a>AfterR</h5><p>注解：@AfterReturning</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为返回后通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;pt()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊参数：</p><ul><li>returning ：设定使用通知方法参数<strong>接收</strong>返回值的变量名</li></ul><h5 id="AfterT"><a href="#AfterT" class="headerlink" title="AfterT"></a>AfterT</h5><p>注解：@AfterThrowing</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为异常后通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;pt()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊参数：</p><ul><li>throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名</li></ul><h5 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h5><p>注解：@Around</p><p>位置：方法定义上方</p><p>作用：标注当前方法作为环绕通知</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>AOP 使用 XML 配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念，参照通知所配置的<strong>方法名字符串对应的编码值顺序</strong>，可以简单理解为字母排序</p><ul><li><p>同一个通知类中，相同通知类型以方法名排序为准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop001Log</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop002Exception</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同通知类中，以类名排序为准</p></li><li><p>使用 @Order 注解通过变更 bean 的加载顺序改变通知的加载顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">//先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(2)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice1</span> &#123;<span class="comment">//默认执行此通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDecorator</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//原始调用</span></span><br><span class="line">        userService.save();</span><br><span class="line">        <span class="comment">//增强功能（后置）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>JDKProxy 动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强，因为<strong>代理类继承Proxy</strong></p><p>静态代理和动态代理的区别：</p><ul><li>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</li><li>动态代理是程序在运行后通过反射创建字节码文件交由 JVM 加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceJDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceJDKProxy</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            userService.getClass().getClassLoader(),<span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">            userService.getClass().getInterfaces(),<span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;<span class="comment">//对原始方法执行进行拦截并增强</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB（Code Generation Library）：Code 生成类库 </p><p>CGLIB 特点：</p><ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li>CGLIB <strong>继承被代理类</strong>，如果代理类是 final 则不能实现</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-cglib.png"></p><ul><li><p>CGLIB 类</p><ul><li>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强，包括 Object 类中的方法（toString、hashCode）</li><li>返回值类型采用多态向下转型，所以需要设置父类类型</li></ul><p>需要对方法进行判断是否是 save，来选择性增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplCglibProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceCglibProxy</span><span class="params">(Class cls)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.设置Enhancer对象的父类是指定类型UserServerImpl</span></span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.设置回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method m, Object[] args, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//o是被代理出的类创建的对象，所以使用MethodProxy调用，并且是调用父类</span></span><br><span class="line">                <span class="comment">//通过调用父类的方法实现对原始方法的调用</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                <span class="comment">//后置增强内容,需要判断是都是save方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;I love Java&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//使用Enhancer对象创建对应的对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserService)enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> UserServiceCglibProxy.createUserServiceCglibProxy(UserServiceImpl.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="代理选择"><a href="#代理选择" class="headerlink" title="代理选择"></a>代理选择</h4><p>Spirng 可以通过配置的形式控制使用的代理形式，Spring 会先判断是否实现了接口，如果实现了接口就使用 JDK 动态代理，如果没有实现接口则使用 CGLIB 动态代理，通过配置可以修改为使用 CGLIB </p><ul><li><p>XML 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>XML 注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注解驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改为使用 cglib 创建代理对象</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>JDK 动态代理和 CGLIB 动态代理的区别：</p><ul><li>JDK 动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。</li><li>CGLIB 动态代理即使被代理的类没有实现接口也可以使用，因为 CGLIB 动态代理是使用继承被代理类的方式进行扩展</li><li>CGLIB 动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被 final 修饰的话，就不能进行代理</li></ul></li></ul><hr><h4 id="织入时机"><a href="#织入时机" class="headerlink" title="织入时机"></a>织入时机</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA.png" alt="AOP织入时机"></p><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>事务：数据库中多个操作合并在一起形成的操作序列，事务特征（ACID）</p><p>作用：</p><ul><li>当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）</li><li>当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）</li></ul><p>Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口</p><p>Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 <strong>Innodb 引擎</strong>，是支持事务的；如果 MySQL 使用 MyISAM 引擎，那从根上就是不支持事务的</p><p><strong>保证原子性</strong>：</p><ul><li>要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></li><li>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong> 实现，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</li><li>回滚日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</li></ul><hr><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p><strong>分布式事务</strong>：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高</p><p>在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</p><hr><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，也就是方法嵌套：</p><ul><li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p></li><li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外层事务 Service A 的 aMethod 调用内层 Service B 的 bMethod</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务则<strong>加入该事务</strong>；如果当前没有事务则创建一个新的事务<ul><li>内外层是相同的事务，在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚</li><li>工作流程：<ul><li>线程执行到 serviceA.aMethod() 时，其实是执行的代理 serviceA 对象的 aMethod</li><li>首先执行事务增强器逻辑（环绕增强），提取事务标签属性，检查当前线程是否绑定 connection 数据库连接资源，没有就调用 datasource.getConnection()，设置事务提交为手动提交 autocommit(false)</li><li>执行其他增强器的逻辑，然后调用 target 的目标方法 aMethod() 方法，进入 serviceB 的逻辑</li><li>serviceB 也是先执行事务增强器的逻辑，提取事务标签属性，但此时会检查到线程绑定了 connection，检查注解的传播属性，所以调用 DataSourceUtils.getConnection(datasource) 共享该连接资源，执行完相关的增强和 SQL 后，发现事务并不是当前方法开启的，可以直接返回上层</li><li>serviceA.aMethod() 继续执行，执行完增强后进行提交事务或回滚事务</li></ul></li></ul></li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则以非事务的方式继续运行</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则抛出异常</li></ul><p><strong>不支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起<ul><li>内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚</li><li>如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交</li></ul></li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： <strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起</li><li>TransactionDefinition.PROPAGATION_NEVER： <strong>以非事务方式运行</strong>，如果当前存在事务，则抛出异常</li></ul><p>其他情况：</p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务（两个事务没有关系）来运行<ul><li>如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC</li><li>如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback</li><li><strong>应用场景</strong>：在查询数据的时候要向数据库中存储一些日志，系统不希望存日志的行为影响到主逻辑，可以使用该传播</li></ul></li></ul><p>requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的</p><hr><h4 id="超时属性"><a href="#超时属性" class="headerlink" title="超时属性"></a>超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过该时间限制事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1</p><hr><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中</p><p>读操作为什么需要启用事务支持：</p><ul><li>MySQL  默认对每一个新建立的连接都启用了 <code>autocommit</code> 模式，在该模式下，每一个发送到 MySQL 服务器的 SQL 语句都会在一个<strong>单独</strong>的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务</li><li>执行多条查询语句，如果方法加上了 <code>@Transactional</code> 注解，这个方法执行的所有 SQL 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 <code>@Transactional</code>，每条 SQL 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出<strong>现读数据不一致的状态</strong></li></ul><hr><h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><h4 id="事务对象"><a href="#事务对象" class="headerlink" title="事务对象"></a>事务对象</h4><p>J2EE 开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p><p>Spring 为业务层提供了整套的事务解决方案：</p><ul><li><p>PlatformTransactionManager</p></li><li><p>TransactionDefinition</p></li><li><p>TransactionStatus</p></li></ul><hr><h4 id="PTM"><a href="#PTM" class="headerlink" title="PTM"></a>PTM</h4><p>PlatformTransactionManager，平台事务管理器实现类：</p><ul><li><p>DataSourceTransactionManager  适用于 Spring JDBC 或 MyBatis</p></li><li><p>HibernateTransactionManager  适用于 Hibernate3.0 及以上版本</p></li><li><p>JpaTransactionManager  适用于 JPA</p></li><li><p>JdoTransactionManager  适用于 JDO</p></li><li><p>JtaTransactionManager  适用于 JTA</p></li></ul><p>管理器：</p><ul><li><p>JPA（Java Persistence API）Java EE 标准之一，为 POJO 提供持久化标准规范，并规范了持久化开发的统一 API，符合 JPA 规范的开发可以在不同的 JPA 框架下运行</p><p><strong>非持久化一个字段</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure></li><li><p>JDO（Java Data Object）是 Java 对象持久化规范，用于存取某种数据库中的对象，并提供标准化 API。JDBC 仅针对关系数据库进行操作，JDO 可以扩展到关系数据库、XML、对象数据库等，可移植性更强</p></li><li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与 JDBC 相比，JDBC 事务则被限定在一个单一的数据库连接，而一个 JTA 事务可以有多个参与者，比如 JDBC 连接、JDO 都可以参与到一个 JTA 事务中</p></li></ul><p>此接口定义了事务的基本操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus getTransaction(TransactionDefinition definition)</td><td>获取事务</td></tr><tr><td>void commit(TransactionStatus status)</td><td>提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>回滚事务</td></tr></tbody></table><hr><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>TransactionDefinition 此接口定义了事务的基本信息：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>获取事务定义名称</td></tr><tr><td>boolean isReadOnly()</td><td>获取事务的读写属性</td></tr><tr><td>int getIsolationLevel()</td><td>获取事务隔离级别</td></tr><tr><td>int getTimeout()</td><td>获取事务超时时间</td></tr><tr><td>int getPropagationBehavior()</td><td>获取事务传播行为特征</td></tr></tbody></table><hr><h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean isNewTransaction()</td><td>获取事务是否处于新开始事务状态</td></tr><tr><td>voin flush()</td><td>刷新事务状态</td></tr><tr><td>boolean isCompleted()</td><td>获取事务是否处于已完成状态</td></tr><tr><td>boolean hasSavepoint()</td><td>获取事务是否具有回滚储存点</td></tr><tr><td>boolean isRollbackOnly()</td><td>获取事务是否处于回滚状态</td></tr><tr><td>void setRollbackOnly()</td><td>设置事务处于回滚状态</td></tr></tbody></table><hr><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>编程式、声明式（XML）、声明式（注解）</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>银行转账业务</p><ul><li><p>包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DAO层接口：AccountDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">//入账操作name:入账用户名money:入账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出账操作name:出账用户名money:出账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层接口提供转账操作：AccountService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"><span class="comment">//转账操作outName:出账用户名inName:入账用户名money:转账金额</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">accountDao.inMoney(outName,money);</span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射配置文件：dao &#x2F; AccountDao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;inMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money + #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;outMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money - #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.2.185:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li><li><p>核心配置文件：applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描映射配置和Dao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ap...xml&quot;</span>);</span><br><span class="line"><span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> (AccountService) ctx.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">accountService.transfer(<span class="string">&quot;Jock1&quot;</span>, <span class="string">&quot;Jock2&quot;</span>, <span class="number">100d</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="编程式-1"><a href="#编程式-1" class="headerlink" title="编程式"></a>编程式</h4><p>编程式事务就是代码显式的给出事务的开启和提交</p><ul><li><p>修改业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建事务管理器，</span></span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//2.为事务管理器设置与数据层相同的数据源</span></span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//3.创建事务定义对象</span></span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="comment">//4.创建事务状态对象，用于控制事务执行，【开启事务】</span></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    accountDao.inMoney(inName,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;    <span class="comment">//模拟业务层事务过程中出现错误</span></span><br><span class="line">    accountDao.outMoney(outName,money);</span><br><span class="line">    <span class="comment">//5.提交事务</span></span><br><span class="line">    dstm.commit(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="AOP改造"><a href="#AOP改造" class="headerlink" title="AOP改造"></a>AOP改造</h4><ul><li><p>将业务层的事务处理功能抽取出来制作成 AOP 通知，利用环绕通知运行期动态织入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">tx</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">        <span class="comment">//事务定义</span></span><br><span class="line">        <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="comment">//事务状态</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span>  ptm.getTransaction(td);</span><br><span class="line">        <span class="comment">//pjp.getArgs()标准写法，也可以不加，同样可以传递参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        ptm.commit(ts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 applicationContext.xml，要开启 AOP 空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改bean的属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置AOP通知类，并注入dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.TxAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用环绕通知将通知类织入到原始业务对象执行过程中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..transfer(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;tx&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改业务层实现提供转账操作：AccountServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><h4 id="XML-2"><a href="#XML-2" class="headerlink" title="XML"></a>XML</h4><h5 id="tx使用"><a href="#tx使用" class="headerlink" title="tx使用"></a>tx使用</h5><p>删除 TxAdvice 通知类，开启 tx 命名空间，配置 applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义事务管理的通知类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义控制的事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用aop:advisor在AOP配置中引用事务专属通知类，底层invoke调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>aop:advice 与 aop:advisor 区别<ul><li><p>aop:advice 配置的通知类可以是普通 Java 对象，不实现接口，也不使用继承关系</p></li><li><p>aop:advisor 配置的通知类必须实现通知接口，底层 invoke 调用</p><ul><li><p>MethodBeforeAdvice</p></li><li><p>AfterReturningAdvice</p></li><li><p>ThrowsAdvice</p></li></ul></li></ul></li></ul><p>pom.xml 文件引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="tx配置"><a href="#tx配置" class="headerlink" title="tx配置"></a>tx配置</h5><h6 id="advice"><a href="#advice" class="headerlink" title="advice"></a>advice</h6><p>标签：tx:advice，beans 的子标签</p><p>作用：专用于声明事务通知</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本属性：</p><ul><li>id：用于配置 aop 时指定通知器的 id</li><li>transaction-manager：指定事务管理器 bean</li></ul><h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><p>类型：tx:attributes，tx:advice 的子标签</p><p>作用：定义通知属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="method"><a href="#method" class="headerlink" title="method"></a>method</h6><p>标签：tx:method，tx:attribute 的子标签</p><p>作用：设置具体的事务属性</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标准格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span><span class="comment">&lt;!--标准--&gt;</span></span><br></pre></td></tr></table></figure><p>说明：通常事务属性会配置多个，包含 1 个读写的全事务属性，1 个只读的查询类事务属性</p><p>属性：</p><ul><li>name：待添加事务的方法名表达式（支持 * 通配符）</li><li>read-only：设置事务的读写属性，true 为只读，false 为读写</li><li>timeout：设置事务的超时时长，单位秒，-1 为无限长</li><li>isolation：设置事务的隔离界别，该隔离级设定是基于 Spring 的设定，非数据库端</li><li>no-rollback-for：设置事务中不回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>rollback-for：设置事务中必回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>propagation：设置事务的传播行为</li></ul><hr><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><h6 id="XML-3"><a href="#XML-3" class="headerlink" title="XML"></a>XML</h6><p>标签：tx:annotation-driven</p><p>归属：beans 标签</p><p>作用：开启事务注解驱动，并指定对应的事务管理器</p><p>范例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h6 id="纯注解-2"><a href="#纯注解-2" class="headerlink" title="纯注解"></a>纯注解</h6><p>名称：@EnableTransactionManagement</p><p>类型：类注解，Spring 注解配置类上方</p><p>作用：开启注解驱动，等同 XML 格式中的注解驱动</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//自动装配</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h5><p>名称：@Transactional</p><p>类型：方法注解，类注解，接口注解</p><p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    readOnly = false,</span></span><br><span class="line"><span class="meta">    timeout = -1,</span></span><br><span class="line"><span class="meta">    isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">    rollbackFor = &#123;ArithmeticException.class, IOException.class&#125;,</span></span><br><span class="line"><span class="meta">    noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRES_NEW</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> addAccount&#123;&#125; </span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效</p></li><li><p>不推荐在接口上使用 <code>@Transactional</code> 注解</p><p>原因：在接口上使用注解，<strong>只有在使用基于接口的代理（JDK）时才会生效，因为注解是不能继承的</strong>，这就意味着如果正在使用基于类的代理（CGLIB）时，那么事务的设置将不能被基于类的代理所识别</p></li><li><p>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</p></li><li><p>默认情况下，事务只有遇到运行期异常 和 Error 会导致事务回滚，但是在遇到检查型（Checked）异常时不会回滚</p><ul><li>继承自 RuntimeException 或 error 的是非检查型异常，比如空指针和索引越界，而继承自 Exception 的则是检查型异常，比如 IOException、ClassNotFoundException，RuntimeException 本身继承 Exception</li><li>非检查型类异常可以不用捕获，而检查型异常则必须用 try 语句块把异常交给上级方法，这样事务才能有效</li></ul></li></ul><p><strong>事务不生效的问题</strong></p><ul><li><p>情况 1：确认创建的 MySQL 数据库表引擎是 InnoDB，MyISAM 不支持事务</p></li><li><p>情况 2：注解到 protected，private 方法上事务不生效，但不会报错</p><p>原因：理论上而言，不用 public 修饰，也可以用 aop 实现事务的功能，但是方法私有化让其他业务无法调用</p><p>AopUtils.canApply：<code>methodMatcher.matches(method, targetClass) --true--&gt; return true</code><br><code>TransactionAttributeSourcePointcut.matches()</code> ，AbstractFallbackTransactionAttributeSource 中 getTransactionAttribute 方法调用了其本身的 computeTransactionAttribute 方法，当加了事务注解的方法不是 public 时，该方法直接返回 null，所以造成增强不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况 3：注解所在的类没有被加载成 Bean</p></li><li><p>情况 4：在业务层捕捉异常后未向上抛出，事务不生效</p><p>原因：在业务层捕捉并处理了异常（try..catch）等于把异常处理掉了，Spring 就不知道这里有错，也不会主动去回滚数据，推荐做法是在业务层统一抛出异常，然后在控制层统一处理</p></li><li><p>情况 5：遇到检测异常时，也无法回滚</p><p>原因：Spring 的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。想针对检测异常进行事务回滚，可以在 @Transactional 注解里使用 rollbackFor 属性明确指定异常</p></li><li><p>情况 6：Spring 的事务传播策略在<strong>内部方法</strong>调用时将不起作用，在一个 Service 内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务，事务注解要加到调用方法上才生效</p><p>原因：Spring 的事务都是使用 AOP 代理的模式，动态代理 invoke 后会调用原始对象，而原始对象在去调用方法时是不会触发拦截器，就是<strong>一个方法调用本对象的另一个方法</strong>，所以事务也就无法生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注解添加在update方法上无效，需要添加到add()方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况 7：注解在接口上，代理对象是 CGLIB</p></li></ul><hr><h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><ul><li><p>Dao 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">//对当前方法添加事务，该配置将替换接口的配置</span></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = false,</span></span><br><span class="line"><span class="meta">        timeout = -1,</span></span><br><span class="line"><span class="meta">        isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;&#125;,//java.lang.ArithmeticException.class, IOException.class</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span> &#123;</span><br><span class="line">        accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加文件 Spring.config、Mybatis.config、JDBCConfig (参考ioc_Mybatis)、TransactionManagerConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><p>Spring 模板对象：TransactionTemplate、JdbcTemplate、RedisTemplate、RabbitTemplate、JmsTemplate、HibernateTemplate、RestTemplate</p><ul><li><p>JdbcTemplate：提供标准的 sql 语句操作API</p></li><li><p>NamedParameterJdbcTemplate：提供标准的具名 sql 语句操作API</p></li><li><p>RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMoney</span><span class="params">(Integer id, Double money)</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;account:id:&quot;</span>+id,money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Double <span class="title function_">findMondyById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">money</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;account:id:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Double</span>(money.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-RedisTemplate.png"></p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="XML-4"><a href="#XML-4" class="headerlink" title="XML"></a>XML</h3><p>三大对象：</p><ul><li><p><strong>BeanDefinition</strong>：是 Spring 中极其重要的一个概念，存储了 bean 对象的所有特征信息，如是否单例、是否懒加载、factoryBeanName 等，和 bean 的关系就是类与对象的关系，一个不同的 bean 对应一个 BeanDefinition</p></li><li><p><strong>BeanDefinationRegistry</strong>：存放 BeanDefination 的容器，是一种键值对的形式，通过特定的 Bean 定义的 id，映射到相应的 BeanDefination，<strong>BeanFactory 的实现类同样继承 BeanDefinationRegistry 接口</strong>，拥有保存 BD 的能力</p></li><li><p><strong>BeanDefinitionReader</strong>：读取配置文件，<strong>XML 用 Dom4j 解析</strong>，<strong>注解用 IO 流加载解析</strong></p></li></ul><p>程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><p>源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">    <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="comment">//将 resource 包装成带编码格式的 EncodedResource</span></span><br><span class="line">    <span class="comment">//EncodedResource 中 getReader()方法，调用java.io包下的 转换流 创建指定编码的输入流对象</span></span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>XmlBeanDefinitionReader.loadBeanDefinitions()</code>：<strong>把 Resource 解析成 BeanDefinition 对象</strong></p><ul><li><code>currentResources = this.resourcesCurrentlyBeingLoaded.get()</code>：拿到当前线程已经加载过的所有 EncodedResoure 资源，用 ThreadLocal 保证线程安全</li><li><code>if (currentResources == null)</code>：判断 currentResources 是否为空，为空则进行初始化</li><li><code>if (!currentResources.add(encodedResource))</code>：如果已经加载过该资源会报错，防止重复加载</li><li><code>inputSource = new InputSource(inputStream)</code>：资源对象包装成 InputSource，InputSource 是 <strong>SAX</strong> 中的资源对象，用来进行 XML 文件的解析</li><li><code>return doLoadBeanDefinitions()</code>：<strong>加载返回</strong></li><li><code>currentResources.remove(encodedResource)</code>：加载完成移除当前 encodedResource</li><li><code>resourcesCurrentlyBeingLoaded.remove()</code>：ThreadLocal 为空时移除元素，防止内存泄露</li></ul></li><li><p><code>XmlBeanDefinitionReader.doLoadBeanDefinitions(inputSource, resource)</code>：真正的加载函数</p><p><code>Document doc = doLoadDocument(inputSource, resource)</code>：转换成有<strong>层次结构</strong>的 Document 对象</p><ul><li><p><code>getEntityResolver()</code><strong>：获取用来解析 DTD、XSD 约束的解析器</strong></p></li><li><p><code>getValidationModeForResource(resource)</code>：获取验证模式</p></li></ul><p><code>int count = registerBeanDefinitions(doc, resource)</code>：<strong>将 Document 解析成 BD 对象，注册（添加）到  BeanDefinationRegistry 中</strong>，返回新注册的数量</p><ul><li><code>createBeanDefinitionDocumentReader()</code>：创建 DefaultBeanDefinitionDocumentReader 对象</li><li><code>getRegistry().getBeanDefinitionCount()</code>：获取解析前 BeanDefinationRegistry 中的 bd 数量</li><li><code>registerBeanDefinitions(doc, readerContext)</code>：注册 BD<ul><li><code>this.readerContext = readerContext</code>：保存上下文对象</li><li><code>doRegisterBeanDefinitions(doc.getDocumentElement())</code>：真正的注册 BD 函数<ul><li><code>doc.getDocumentElement()</code>：拿出顶层标签 <beans></beans></li></ul></li></ul></li><li><code>return getRegistry().getBeanDefinitionCount() - countBefore</code>：返回新加入的数量</li></ul></li><li><p><code>DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions()</code>：注册 BD 到 BR</p><ul><li><code>createDelegate(getReaderContext(), root, parent)</code>：beans 是标签的解析器对象</li><li><code>delegate.isDefaultNamespace(root)</code>：判断 beans 标签是否是默认的属性</li><li><code>root.getAttribute(PROFILE_ATTRIBUTE)</code>：解析 profile 属性</li><li><code>preProcessXml(root)</code>：解析前置处理，自定义实现</li><li><code>parseBeanDefinitions(root, this.delegate)</code>：<strong>解析 beans 标签中的子标签</strong><ul><li><code>parseDefaultElement(ele, delegate)</code>：如果是默认的标签，用该方法解析子标签<ul><li>判断标签名称，进行相应的解析</li><li><code>processBeanDefinition(ele, delegate)</code>：</li></ul></li><li><code>delegate.parseCustomElement(ele)</code>：解析自定义的标签</li></ul></li><li><code>postProcessXml(root)</code>：解析后置处理</li></ul></li><li><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code>：<strong>解析 bean 标签并注册到注册中心</strong></p><ul><li><p><code>delegate.parseBeanDefinitionElement(ele)</code>：解析 bean 标签封装为 BeanDefinitionHolder</p><ul><li><p><code>if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty())</code>：条件一成立说明 name 没有值，条件二成立说明别名有值</p><p><code>beanName = aliases.remove(0)</code>：拿别名列表的第一个元素当作 beanName</p></li><li><p><code>parseBeanDefinitionElement(ele, beanName, containingBean)</code>：<strong>解析 bean 标签</strong></p><ul><li><code>parseState.push(new BeanEntry(beanName))</code>：当前解析器的状态设置为 BeanEntry</li><li>class 和 parent 属性存在一个，parent 是作为父标签为了被继承</li><li><code>createBeanDefinition(className, parent)</code>：设置了class 的 GenericBeanDefinition对象</li><li><code>parseBeanDefinitionAttributes()</code>：解析 bean 标签的属性</li><li>接下来解析子标签</li></ul></li><li><p><code>beanName = this.readerContext.generateBeanName(beanDefinition)</code>：生成 className + # + 序号的名称赋值给 beanName </p></li><li><p><code>return new BeanDefinitionHolder(beanDefinition, beanName, aliases)</code>：<strong>包装成 BeanDefinitionHolder</strong></p></li></ul></li><li><p><code>registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</code>：<strong>注册到容器</strong></p><ul><li><code>beanName = definitionHolder.getBeanName()</code>：获取beanName</li><li><code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>：添加到注册中心</li></ul></li><li><p><code>getReaderContext().fireComponentRegistered()</code>：发送注册完成事件</p></li></ul></li></ul><p><strong>说明：源码部分的笔记不一定适合所有人阅读，作者采用流水线式去解析重要的代码，解析的结构类似于树状，如果视觉疲劳可以去网上参考一些博客和流程图学习源码。</strong></p><hr><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h4><p>Spring IOC 容器是 ApplicationContext 或者 BeanFactory，使用多个 Map 集合保存单实例 Bean，环境信息等资源，不同层级有不同的容器，比如整合 SpringMVC 的父子容器（先看 Bean 部分的源码解析再回看容器）</p><p>ClassPathXmlApplicationContext 与 AnnotationConfigApplicationContext 差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(annotatedClasses);<span class="comment">// 解析配置类，封装成一个 BeanDefinitionHolder，并注册到容器</span></span><br><span class="line">    refresh();<span class="comment">// 加载刷新容器中的 Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 Spring 的注解解析器到容器</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 实例化路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext.refresh()：</p><ul><li><p>prepareRefresh()：刷新前的<strong>预处理</strong></p><ul><li><code>this.startupDate = System.currentTimeMillis()</code>：设置容器的启动时间</li><li><code>initPropertySources()</code>：初始化一些属性设置，可以自定义个性化的属性设置方法</li><li><code>getEnvironment().validateRequiredProperties()</code>：检查环境变量</li><li><code>earlyApplicationEvents= new LinkedHashSet&lt;ApplicationEvent&gt;()</code>：保存容器中早期的事件</li></ul></li><li><p>obtainFreshBeanFactory()：获取一个<strong>全新的 BeanFactory 接口实例</strong>，如果容器中存在工厂实例直接销毁</p><p><code>refreshBeanFactory()</code>：创建 BeanFactory，设置序列化 ID、读取 BeanDefinition 并加载到工厂</p><ul><li><code>if (hasBeanFactory())</code>：applicationContext 内部拥有一个 beanFactory 实例，需要将该实例完全释放销毁</li><li><code>destroyBeans()</code>：销毁原 beanFactory 实例，将 beanFactory 内部维护的单实例 bean 全部清掉，如果哪个 bean 实现了 Disposablejie接口，还会进行 bean distroy 方法的调用处理<ul><li><code>this.singletonsCurrentlyInDestruction = true</code>：设置当前 beanFactory 状态为销毁状态</li><li><code>String[] disposableBeanNames</code>：获取销毁集合中的 bean，如果当前 bean 有<strong>析构函数</strong>就会在销毁集合</li><li><code>destroySingleton(disposableBeanNames[i])</code>：遍历所有的 disposableBeans，执行销毁方法<ul><li><code>removeSingleton(beanName)</code>：清除三级缓存和 registeredSingletons 中的当前 beanName 的数据</li><li><code>this.disposableBeans.remove(beanName)</code>：从销毁集合中清除，每个 bean 只能 destroy 一次</li><li><code>destroyBean(beanName, disposableBean)</code>：销毁 bean<ul><li>dependentBeanMap 记录了依赖当前 bean 的其他 bean 信息，因为依赖的对象要被回收了，所以依赖当前 bean 的其他对象都要执行 destroySingleton，遍历 dependentBeanMap 执行销毁</li><li><code>bean.destroy()</code>：解决完成依赖后，执行 DisposableBean 的 destroy 方法</li><li><code> this.dependenciesForBeanMap.remove(beanName)</code>：保存当前 bean 依赖了谁，直接清除</li></ul></li></ul></li><li>进行一些集合和缓存的清理工作</li></ul></li><li><code>closeBeanFactory()</code>：将容器内部的 beanFactory 设置为空，重新创建</li><li><code>beanFactory = createBeanFactory()</code>：创建新的 DefaultListableBeanFactory 对象</li><li><code>beanFactory.setSerializationId(getId())</code>：进行 ID 的设置，可以根据 ID 获取 BeanFactory 对象</li><li><code>customizeBeanFactory(beanFactory)</code>：设置是否允许覆盖和循环引用</li><li><code>loadBeanDefinitions(beanFactory)</code>：<strong>加载 BeanDefinition 信息，注册 BD注册到 BeanFactory 中</strong></li><li><code>this.beanFactory = beanFactory</code>：把 beanFactory 填充至容器中</li></ul><p><code>getBeanFactory()</code>：返回创建的 DefaultListableBeanFactory 对象，该对象继承 BeanDefinitionRegistry</p></li><li><p>prepareBeanFactory(beanFactory)：<strong>BeanFactory 的预准备</strong>工作，向容器中添加一些组件</p><ul><li><code>setBeanClassLoader(getClassLoader())</code>：给当前 bf 设置一个<strong>类加载器</strong>，加载 bd 的 class 信息</li><li><code>setBeanExpressionResolver()</code>：设置 EL 表达式解析器</li><li><code>addPropertyEditorRegistrar</code>：添加一个属性编辑器，解决属性注入时的格式转换</li><li><code>addBeanPostProcessor()</code>：添加后处理器，主要用于向 bean 内部注入一些框架级别的实例</li><li><code>ignoreDependencyInterface()</code>：设置忽略自动装配的接口，bean 内部的这些类型的字段   不参与依赖注入</li><li><code>registerResolvableDependency()</code>：注册一些类型依赖关系</li><li><code>addBeanPostProcessor()</code>：将配置的监听者注册到容器中，当前 bean 实现 ApplicationListener 接口就是监听器事件</li><li><code>beanFactory.registerSingleton()</code>：添加一些系统信息</li></ul></li><li><p>postProcessBeanFactory(beanFactory)：BeanFactory 准备工作完成后进行的后置处理工作，扩展方法</p></li><li><p>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行 BeanFactoryPostProcessor 的方法</strong></p><ul><li><p><code>processedBeans = new HashSet&lt;&gt;()</code>：存储已经执行过的 BeanFactoryPostProcessor 的 beanName</p></li><li><p><code>if (beanFactory instanceof BeanDefinitionRegistry)</code>：<strong>当前 BeanFactory 是 bd 的注册中心，bd 全部注册到 bf</strong></p></li><li><p><code>for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors)</code>：遍历所有的 bf 后置处理器</p></li><li><p><code>if (postProcessor instanceof BeanDefinitionRegistryPostProcessor)</code>：是 Registry 类的后置处理器</p><p><code>registryProcessor.postProcessBeanDefinitionRegistry(registry)</code>：向 bf 中注册一些 bd</p><p><code>registryProcessors.add(registryProcessor)</code>：添加到 BeanDefinitionRegistryPostProcessor 集合</p></li><li><p><code>regularPostProcessors.add(postProcessor)</code>：添加到 BeanFactoryPostProcessor 集合</p></li><li><p>逻辑到这里已经获取到所有 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor  接口类型的后置处理器</p></li><li><p><strong>首先回调 BeanDefinitionRegistryPostProcessor 类的后置处理方法 postProcessBeanDefinitionRegistry()</strong></p><ul><li><p>获取实现了 PriorityOrdered（主排序接口）接口的 bdrpp，进行 sort 排序，然后全部执行并放入已经处理过的集合</p></li><li><p>再执行实现了 Ordered（次排序接口）接口的 bdrpp</p></li><li><p>最后执行没有实现任何优先级或者是顺序接口 bdrpp，<code>boolean reiterate = true</code> 控制 while 是否需要再次循环，循环内是查找并执行 bdrpp 后处理器的 registry 相关的接口方法，接口方法执行以后会向 bf 内注册 bd，注册的 bd 也有可能是 bdrpp 类型，所以需要该变量控制循环</p></li><li><p><code>processedBeans.add(ppName)</code>：已经执行过的后置处理器存储到该集合中，防止重复执行</p></li><li><p><code> invokeBeanFactoryPostProcessors()</code>：bdrpp 继承了 BeanFactoryPostProcessor，有 postProcessBeanFactory 方法</p></li></ul></li><li><p><strong>执行普通 BeanFactoryPostProcessor 的相关 postProcessBeanFactory 方法，按照主次无次序执行</strong></p><ul><li><code>if (processedBeans.contains(ppName))</code>：会过滤掉已经执行过的后置处理器</li></ul></li><li><p><code>beanFactory.clearMetadataCache()</code>：清除缓存中合并的 Bean 定义，因为后置处理器可能更改了元数据</p></li></ul></li></ul><p><strong>以上是 BeanFactory 的创建及预准备工作，接下来进入 Bean 的流程</strong></p><ul><li><p>registerBeanPostProcessors(beanFactory)：<strong>注册 Bean 的后置处理器</strong>，为了干预 Spring 初始化 bean 的流程，这里仅仅是向容器中<strong>注入而非使用</strong></p><ul><li><p><code>beanFactory.getBeanNamesForType(BeanPostProcessor.class)</code>：<strong>获取配置中实现了 BeanPostProcessor 接口类型</strong></p></li><li><p><code>int beanProcessorTargetCount</code>：后置处理器的数量，已经注册的 + 未注册的 + 即将要添加的一个</p></li><li><p><code>beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker())</code>：添加一个检查器</p><p><code>BeanPostProcessorChecker.postProcessAfterInitialization()</code>：初始化后的后处理器方法</p><ul><li><code>!(bean instanceof BeanPostProcessor) </code>：当前 bean 类型是普通 bean，不是后置处理器</li><li><code>!isInfrastructureBean(beanName)</code>：成立说明当前 beanName 是用户级别的 bean  不是 Spring 框架的</li><li><code>this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount</code>：BeanFactory 上面注册后处理器数量 &lt; 后处理器数量，说明后处理框架尚未初始化完成</li></ul></li><li><p><code>for (String ppName : postProcessorNames)</code>：遍历 PostProcessor 集合，<strong>根据实现不同的顺序接口添加到不同集合</strong></p></li><li><p><code>sortPostProcessors(priorityOrderedPostProcessors, beanFactory)</code>：实现 PriorityOrdered 接口的后处理器排序</p><p><code>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)</code>：<strong>注册到 beanFactory 中</strong></p></li><li><p>接着排序注册实现 Ordered 接口的后置处理器，然后注册普通的（ 没有实现任何优先级接口）后置处理器</p></li><li><p>最后排序 MergedBeanDefinitionPostProcessor 类型的处理器，根据实现的排序接口，排序完注册到 beanFactory 中</p></li><li><p><code>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext))</code>：重新注册 ApplicationListenerDetector 后处理器，用于在 Bean 创建完成后检查是否属于 ApplicationListener 类型，如果是就把 Bean 放到<strong>监听器容器</strong>中保存起来</p></li></ul></li><li><p>initMessageSource()：初始化 MessageSource 组件，主要用于做国际化功能，消息绑定与消息解析</p><ul><li><code>if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME))</code>：容器是否含有名称为 messageSource 的 bean</li><li><code>beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class)</code>：如果有证明用户自定义了该类型的 bean，获取后直接赋值给 this.messageSource</li><li><code>dms = new DelegatingMessageSource()</code>：容器中没有就新建一个赋值</li></ul></li><li><p>initApplicationEventMulticaster()：<strong>初始化事件传播器</strong>，在注册监听器时会用到</p><ul><li><code>if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME))</code>：<strong>条件成立说明用户自定义了事件传播器</strong>，可以实现 ApplicationEventMulticaster 接口编写自己的事件传播器，通过 bean 的方式提供给 Spring</li><li>如果有就直接从容器中获取；如果没有则创建一个 SimpleApplicationEventMulticaster 注册</li></ul></li><li><p>onRefresh()：留给用户去实现，可以硬编码提供一些组件，比如提供一些监听器</p></li><li><p>registerListeners()：注册通过配置提供的 Listener，这些<strong>监听器</strong>最终注册到 ApplicationEventMulticaster 内</p><ul><li><p><code>for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) </code>：注册编码实现的监听器</p></li><li><p><code>getBeanNamesForType(ApplicationListener.class, true, false)</code>：注册通过配置提供的 Listener</p></li><li><p><code>multicastEvent(earlyEvent)</code>：<strong>发布前面步骤产生的事件 applicationEvents</strong></p><p><code>Executor executor = getTaskExecutor()</code>：获取线程池，有线程池就异步执行，没有就同步执行</p></li></ul></li><li><p>finishBeanFactoryInitialization()：<strong>实例化非懒加载状态的单实例</strong></p><ul><li><p><code>beanFactory.freezeConfiguration()</code>：<strong>冻结配置信息</strong>，就是冻结 BD 信息，冻结后无法再向 bf 内注册 bd</p></li><li><p><code>beanFactory.preInstantiateSingletons()</code>：实例化 non-lazy-init singletons</p><ul><li><p><code>for (String beanName : beanNames)</code>：遍历容器内所有的 beanDefinitionNames</p></li><li><p><code>getMergedLocalBeanDefinition(beanName)</code>：获取与父类合并后的对象（Bean → 获取流程部分详解此函数）</p></li><li><p><code>if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</code>：BD 对应的 Class 满足非抽象、单实例，非懒加载，需要预先实例化</p><p><code>if (isFactoryBean(beanName))</code>：BD 对应的 Class 是 factoryBean 对象</p><ul><li><code>getBean(FACTORY_BEAN_PREFIX + beanName)</code>：获取工厂 FactoryBean 实例本身</li><li><code>isEagerInit</code>：控制 FactoryBean 内部管理的 Bean 是否也初始化</li><li><code>getBean(beanName)</code>：<strong>初始化 Bean，获取 Bean 详解此函数</strong></li></ul><p><code>getBean(beanName)</code>：不是工厂 bean 直接获取</p></li><li><p><code>for (String beanName : beanNames)</code>：检查所有的 Bean 是否实现 SmartInitializingSingleton 接口，实现了就执行 afterSingletonsInstantiated()，进行一些创建后的操作</p></li></ul></li></ul></li><li><p><code>finishRefresh()</code>：完成刷新后做的一些事情，主要是启动生命周期</p><ul><li><code>clearResourceCaches()</code>：清空上下文缓存</li><li><code>initLifecycleProcessor()</code>：<strong>初始化和生命周期有关的后置处理器</strong>，容器的生命周期<ul><li><code>if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME))</code>：成立说明自定义了生命周期处理器</li><li><code>defaultProcessor = new DefaultLifecycleProcessor()</code>：Spring 默认提供的生命周期处理器</li><li><code> beanFactory.registerSingleton()</code>：将生命周期处理器注册到 bf 的一级缓存和注册单例集合中</li></ul></li><li><code>getLifecycleProcessor().onRefresh()</code>：获取该**生命周期后置处理器回调 onRefresh()**，调用 <code>startBeans(true)</code><ul><li><code>lifecycleBeans = getLifecycleBeans()</code>：获取到所有实现了 Lifecycle 接口的对象包装到 Map 内，key 是beanName， value 是 Lifecycle 对象</li><li><code>int phase = getPhase(bean)</code>：获取当前 Lifecycle 的 phase 值，当前生命周期对象可能依赖其他生命周期对象的执行结果，所以需要 phase 决定执行顺序，数值越低的优先执行</li><li><code>LifecycleGroup group = phases.get(phase)</code>：把 phsae 相同的 Lifecycle 存入 LifecycleGroup</li><li><code>if (group == null)</code>：group 为空则创建，初始情况下是空的</li><li><code>group.add(beanName, bean)</code>：将当前 Lifecycle 添加到当前 phase 值一样的 group 内</li><li><code>Collections.sort(keys)</code>：<strong>从小到大排序，按优先级启动</strong></li><li><code>phases.get(key).start()</code>：遍历所有的 Lifecycle 对象开始启动</li><li><code>doStart(this.lifecycleBeans, member.name, this.autoStartupOnly)</code>：底层调用该方法启动<ul><li><code>bean = lifecycleBeans.remove(beanName)</code>： 确保 Lifecycle 只被启动一次，在一个分组内被启动了在其他分组内就看不到 Lifecycle 了</li><li><code>dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName)</code>：获取当前即将被启动的 Lifecycle 所依赖的其他 beanName，需要<strong>先启动所依赖的 bean</strong>，才能启动自身</li><li><code>if ()</code>：传入的参数 autoStartupOnly 为 true 表示启动 isAutoStartUp 为 true 的 SmartLifecycle 对象，不会启动普通的生命周期的对象；false 代表全部启动</li><li>bean.start()：<strong>调用启动方法</strong></li></ul></li></ul></li><li><code>publishEvent(new ContextRefreshedEvent(this))</code>：<strong>发布容器刷新完成事件</strong></li><li><code>liveBeansView.registerApplicationContext(this)</code>：暴露 Mbean</li></ul></li></ul><p>补充生命周期 stop() 方法的调用</p><ul><li><p>DefaultLifecycleProcessor.stop()：调用 DefaultLifecycleProcessor.stopBeans()</p><ul><li><p>获取到所有实现了 Lifecycle 接口的对象并按 phase 数值分组的</p></li><li><p><code>keys.sort(Collections.reverseOrder())</code>：按 phase 降序排序 Lifecycle 接口，最先启动的最晚关闭（责任链？）</p></li><li><p><code>phases.get(key).stop()</code>：遍历所有的 Lifecycle 对象开始停止</p><ul><li><p><code>latch = new CountDownLatch(this.smartMemberCount)</code>：创建 CountDownLatch，设置 latch 内部的值为当前分组内的  smartMemberCount 的数量</p></li><li><p><code>countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;())</code>：保存当前正在处理关闭的smartLifecycle 的 BeanName</p></li><li><p><code>for (LifecycleGroupMember member : this.members)</code>：处理本分组内需要关闭的 Lifecycle</p><p><code>doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames)</code>：真正的停止方法</p><ul><li><p><code>getBeanFactory().getDependentBeans(beanName)</code>：<strong>获取依赖当前 Lifecycle 的其他对象的 beanName</strong>，因为当前的 Lifecycle 即将要关闭了，所有的依赖了当前 Lifecycle 的 bean 也要关闭</p></li><li><p><code>countDownBeanNames.add(beanName)</code>：将当前 SmartLifecycle beanName 添加到 countDownBeanNames 集合内，该集合表示正在关闭的 SmartLifecycle</p></li><li><p><code>bean.stop()</code>：调用停止的方法</p></li></ul></li></ul></li></ul></li></ul><hr><h4 id="获取Bean-1"><a href="#获取Bean-1" class="headerlink" title="获取Bean"></a>获取Bean</h4><p>单实例：在容器启动时创建对象</p><p>多实例：在每次获取的时候创建对象</p><p>获取流程：<strong>获取 Bean 时先从单例池获取，如果没有则进行第二次获取，并带上工厂类去创建并添加至单例池</strong></p><p>Java 启动 Spring 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure><p>AbstractBeanFactory.doGetBean()：获取 Bean，context.getBean() 追踪到此</p><ul><li><p><code>beanName = transformedBeanName(name)</code>：name 可能是一个别名，重定向出来真实 beanName；也可能是一个 &amp; 开头的 name，说明要获取的 bean 实例对象，是一个 FactoryBean 对象（IOC 原理 → 核心类）</p><ul><li><code>BeanFactoryUtils.transformedBeanName(name)</code>：判断是哪种 name，返回截取 &amp; 以后的 name 并放入缓存<ul><li><code>transformedBeanNameCache.computeIfAbsent</code>：缓存是并发安全集合，key &#x3D;&#x3D; null || value &#x3D;&#x3D; null 时 put 成功 </li><li>do while 循环一直去除 &amp; 直到不再含有 &amp;</li></ul></li><li><code>canonicalName(name)</code>：aliasMap 保存别名信息，其中的 do while 逻辑是迭代查找，比如 A 别名叫做 B，但是 B 又有别名叫 C， aliasMap 为 {“C”:”B”, “B”:”A”}，get(C) 最后返回的是  A</li></ul></li><li><p><code>DefaultSingletonBeanRegistry.getSingleton()</code>：<strong>第一次获取从缓存池获取</strong>（循环依赖详解此代码）</p><ul><li>缓存中有数据进行 getObjectForBeanInstance() 获取可使用的 Bean（本节结束部分详解此函数）</li><li>缓存中没有数据进行下面的逻辑进行创建</li></ul></li><li><p><code>if(isPrototypeCurrentlyInCreation(beanName))</code>：检查 bean 是否在原型（Prototype）正在被创建的集合中，如果是就报错，说明产生了循环依赖，<strong>原型模式解决不了循环依赖</strong></p><p>原因：先加载 A，把 A 加入集合，A 依赖 B 去加载 B，B 又依赖 A，去加载 A，发现 A 在正在创建集合中，产生循环依赖</p></li><li><p><code>markBeanAsCreated(beanName)</code>：把 bean 标记为已经创建，<strong>防止其他线程重新创建 Bean</strong></p></li><li><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：<strong>获取合并父 BD 后的 BD 对象</strong>，BD 是直接继承的，合并后的 BD 信息是包含父类的 BD 信息</p><ul><li><p><code>this.mergedBeanDefinitions.get(beanName)</code>：从缓存中获取</p></li><li><p><code>if(bd.getParentName()==null)</code>：beanName 对应 BD 没有父 BD 就不用处理继承，封装为 RootBeanDefinition 返回</p></li><li><p><code>parentBeanName = transformedBeanName(bd.getParentName())</code>：处理父 BD 的 name 信息</p></li><li><p><code>if(!beanName.equals(parentBeanName))</code>：一般情况父子 BD 的名称不同</p><p><code>pbd = getMergedBeanDefinition(parentBeanName)</code>：递归调用，最终返回父 BD 的父 BD 信息</p></li><li><p><code>mbd = new RootBeanDefinition(pbd)</code>：按照父 BD 信息创建 RootBeanDefinition 对象</p></li><li><p><code>mbd.overrideFrom(bd)</code>：<strong>子 BD 信息覆盖 mbd</strong>，因为是要以子 BD 为基准，不存在的才去父 BD 寻找（<strong>类似 Java 继承</strong>）</p></li><li><p><code>this.mergedBeanDefinitions.put(beanName, mbd)</code>：放入缓存</p></li></ul></li><li><p><code>checkMergedBeanDefinition()</code>：判断当前 BD 是否为<strong>抽象 BD</strong>，抽象 BD 不能创建实例，只能作为父 BD 被继承</p></li><li><p><code>mbd.getDependsOn()</code>：获取 bean 标签 depends-on</p></li><li><p><code>if(dependsOn != null)</code>：<strong>遍历所有的依赖加载，解决不了循环依赖</strong></p><p><code>isDependent(beanName, dep)</code>：判断循环依赖，出现循环依赖问题报错</p><ul><li><p>两个 Map：<code>&lt;bean name=&quot;A&quot; depends-on=&quot;B&quot; ...&gt;</code></p><ul><li>dependentBeanMap：记录依赖了当前 beanName 的其他 beanName（谁依赖我，我记录谁）</li><li>dependenciesForBeanMap：记录当前 beanName 依赖的其它 beanName </li><li>以 B 为视角 dependentBeanMap {“B”：{“A”}}，以 A 为视角 dependenciesForBeanMap {“A” :{“B”}}</li></ul></li><li><p><code>canonicalName(beanName)</code>：处理 bean 的 name</p></li><li><p><code>dependentBeans = this.dependentBeanMap.get(canonicalName)</code>：获取依赖了当前 bean 的 name</p></li><li><p><code>if (dependentBeans.contains(dependentBeanName))</code>：依赖了当前 bean 的集合中是否有该 name，有就产生循环依赖</p></li><li><p>进行递归处理所有的引用：假如 <code>&lt;bean name=&quot;A&quot; dp=&quot;B&quot;&gt; &lt;bean name=&quot;B&quot; dp=&quot;C&quot;&gt; &lt;bean name=&quot;C&quot; dp=&quot;A&quot;&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependentBeanMap=&#123;A:&#123;C&#125;, B:&#123;A&#125;, C:&#123;B&#125;&#125; </span><br><span class="line"><span class="comment">// C 依赖 A     判断谁依赖了C递归判断谁依赖了B</span></span><br><span class="line">isDependent(C, A)  → C#dependentBeans=&#123;B&#125; → isDependent(B, A); → B#dependentBeans=&#123;A&#125; <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li></ul><p><code>registerDependentBean(dep, beanName)</code>：把 bean 和依赖注册到两个 Map 中，注意参数的位置，被依赖的在前</p><p><code>getBean(dep)</code>：<strong>先加载依赖的 Bean</strong>，又进入 doGetBean() 的逻辑</p></li><li><p><code>if (mbd.isSingleton())</code>：<strong>判断 bean 是否是单例的 bean</strong></p><p><code>getSingleton(String, ObjectFactory&lt;?&gt;)</code>：<strong>第二次获取，传入一个工厂对象</strong>，这个方法更倾向于创建实例并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanName, mbd, args);<span class="comment">//创建，跳转生命周期</span></span><br><span class="line">    <span class="comment">//lambda表达式，调用了ObjectFactory的getObject()方法，实际回调接口实现的是 createBean()方法进行创建对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>singletonObjects.get(beanName)</code>：从一级缓存检查是否已经被加载，单例模式复用已经创建的 bean</p></li><li><p><code>this.singletonsCurrentlyInDestruction</code>：容器销毁时会设置这个属性为 true，这时就不能再创建 bean 实例了</p></li><li><p><code>beforeSingletonCreation(beanName)</code>：检查构造注入的依赖，<strong>构造参数注入产生的循环依赖无法解决</strong></p><p><code>!this.singletonsCurrentlyInCreation.add(beanName)</code>：将当前 beanName 放入到正在创建中单实例集合，放入成功说明没有产生循环依赖，失败则产生循环依赖，进入判断条件内的逻辑抛出异常</p><p>原因：加载 A，向正在创建集合中添加了 {A}，根据 A 的构造方法实例化 A 对象，发现 A 的构造方法依赖 B，然后加载 B，B 构造方法的参数依赖于 A，又去加载 A 时来到当前方法，因为创建中集合已经存在 A，所以添加失败</p></li><li><p><code>singletonObject = singletonFactory.getObject()</code>：<strong>创建 bean</strong>（生命周期部分详解）</p></li><li><p><strong>创建完成以后，Bean 已经初始化好，是一个完整的可使用的 Bean</strong></p></li><li><p><code>afterSingletonCreation(beanName)</code>：从正在创建中的集合中移出</p></li><li><p><code>addSingleton(beanName, singletonObject)</code>：<strong>添加一级缓存单例池中，从二级三级缓存移除</strong></p></li></ul><p><code>bean = getObjectForBeanInstance</code>：<strong>单实例可能是普通单实例或者 FactoryBean</strong>，如果是 FactoryBean 实例，需要判断 name 是带 &amp; 还是不带 &amp;，带 &amp; 说明 getBean 获取 FactoryBean 对象，否则是获取 FactoryBean 内部管理的实例</p><ul><li><p>参数 name 是未处理 &amp; 的 name，beanName 是处理过 &amp; 和别名后的 name</p></li><li><p><code>if(BeanFactoryUtils.isFactoryDereference(name))</code>：判断 doGetBean 中参数 name 前是否带 &amp;，不是处理后的</p></li><li><p><code>if(!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name))</code>：Bean 是普通单实例或者是 FactoryBean 就可以直接返回，否则进入下面的获取 <strong>FactoryBean 内部管理的实例</strong>的逻辑</p></li><li><p><code>getCachedObjectForFactoryBean(beanName)</code>：尝试到缓存获取，获取到直接返回，获取不到进行下面逻辑</p></li><li><p><code>if (mbd == null &amp;&amp; containsBeanDefinition(beanName))</code>：Spring 中有当前 beanName 的 BeanDefinition 信息</p><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：获取合并后的 BeanDefinition</p></li><li><p><code>mbd.isSynthetic()</code>：默认值是 false 表示这是一个用户对象，如果是 true 表示是系统对象</p></li><li><p><code>object = getObjectFromFactoryBean(factory, beanName, !synthetic)</code>：从工厂内获取实例</p><ul><li><code>factory.isSingleton() &amp;&amp; containsSingleton(beanName)</code>：工厂内部维护的对象是单实例并且一级缓存存在该 bean</li><li>首先去缓存中获取，获取不到就<strong>使用工厂获取</strong>然后放入缓存，进行循环依赖判断</li></ul></li></ul></li><li><p><code>else if (mbd.isPrototype())</code>：<strong>bean 是原型的 bean</strong></p><p><code>beforePrototypeCreation(beanName)</code>：当前线程正在创建的原型对象 beanName 存入 prototypesCurrentlyInCreation</p><ul><li><code>curVal = this.prototypesCurrentlyInCreation.get()</code>：获取当前线程的正在创建的原型类集合</li><li><code>this.prototypesCurrentlyInCreation.set(beanName)</code>：集合为空就把当前 beanName 加入</li><li><code>if (curVal instanceof String)</code>：已经有线程相关原型类创建了，把当前的创建的加进去</li></ul><p><code>createBean(beanName, mbd, args)</code>：创建原型类对象，不需要三级缓存</p><p><code>afterPrototypeCreation(beanName)</code>：从正在创建中的集合中移除该 beanName， <strong>与 beforePrototypeCreation逻辑相反</strong></p></li><li><p><code>convertIfNecessary()</code>：<strong>依赖检查</strong>，检查所需的类型是否与实际 bean 实例的类型匹配</p></li><li><p><code>return (T) bean</code>：返回创建完成的 bean</p></li></ul><hr><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h5><p>Bean 的生命周期：实例化 instantiation，填充属性 populate，初始化 initialization，销毁 destruction</p><p>AbstractAutowireCapableBeanFactory.createBean()：进入 Bean 生命周期的流程</p><ul><li><p><code>resolvedClass = resolveBeanClass(mbd, beanName)</code>：判断 mdb 中的 class 是否已经<strong>加载到 JVM</strong>，如果未加载则使用类加载器将 beanName 加载到 JVM中并返回 class 对象</p></li><li><p><code>if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null)</code>：条件成立封装 mbd 并把 resolveBeanClass 设置到 bd 中</p><ul><li>条件二：mbd 在 resolveBeanClass 之前是否有 class</li><li>条件三：mbd 有 className</li></ul></li><li><p><code>bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>：实例化前的后置处理器返回一个代理实例对象（不是 AOP）</p><ul><li>自定义类继承 InstantiationAwareBeanPostProcessor，重写 postProcessBeforeInstantiation 方法，<strong>方法逻辑为创建对象</strong> </li><li>并配置文件 <code>&lt;bean class=&quot;intefacePackage.MyInstantiationAwareBeanPostProcessor&quot;&gt;</code> 导入为 bean</li><li>条件成立，<strong>短路操作</strong>，直接 return bean</li></ul></li><li><p><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>：Do it</p></li></ul><p>AbstractAutowireCapableBeanFactory.<strong>doCreateBean</strong>(beanName, RootBeanDefinition, Object[] args)：创建 Bean</p><ul><li><p><code>BeanWrapper instanceWrapper = null</code>：<strong>Spring 给所有创建的 Bean 实例包装成 BeanWrapper</strong>，内部最核心的方法是获取实例，提供了一些额外的接口方法，比如属性访问器</p></li><li><p><code>instanceWrapper = this.factoryBeanInstanceCache.remove(beanName)</code>：单例对象尝试从缓存中获取，会移除缓存</p></li><li><p><code>createBeanInstance()</code>：<strong>缓存中没有实例就进行创建实例</strong>（逻辑复杂，下一小节详解）</p></li><li><p><code>if (!mbd.postProcessed)</code>：每个 bean 只进行一次该逻辑</p><p><code>applyMergedBeanDefinitionPostProcessors()</code>：<strong>后置处理器，合并 bd 信息</strong>，接下来要属性填充了</p><p><code>AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()</code>：<strong>后置处理逻辑（@Autowired）</strong></p><ul><li><p><code>metadata = findAutowiringMetadata(beanName, beanType, null)</code>：提取当前 bean 整个继承体系内的 <strong>@Autowired、@Value、@Inject</strong> 信息，存入一个 InjectionMetadata 对象，保存着当前 bean 信息和要自动注入的字段信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;<span class="comment">//当前 bean </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;InjectedElement&gt; injectedElements;<span class="comment">//要注入的信息集合</span></span><br></pre></td></tr></table></figure><ul><li><p><code>metadata = buildAutowiringMetadata(clazz)</code>：查询当前 clazz 感兴趣的注解信息</p><ul><li><p><code>ReflectionUtils.doWithLocalFields()</code>：提取<strong>字段</strong>的注解的信息</p><p><code>findAutowiredAnnotation(field)</code>：代表感兴趣的注解就是那三种注解，获取这三种注解的元数据</p></li><li><p><code>ReflectionUtils.doWithLocalMethods()</code>：提取<strong>方法</strong>的注解的信息</p></li><li><p><code>do&#123;&#125; while (targetClass != null &amp;&amp; targetClass != Object.class)</code>：循环从父类中解析，直到 Object 类</p></li></ul></li><li><p><code>this.injectionMetadataCache.put(cacheKey, metadata)</code>：存入缓存</p></li></ul></li></ul><p><code>mbd.postProcessed = true</code>：设置为 true，下次访问该逻辑不会再进入</p></li><li><p><code>earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)</code>：单例、解决循环引用、是否在单例正在创建集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 【放入三级缓存一个工厂对象，用来获取提前引用】</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    <span class="comment">// lamda 表达式，用来获取提前引用，循环依赖部分详解该逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code> populateBean(beanName, mbd, instanceWrapper)</code>：**属性填充，依赖注入，整体逻辑是先处理标签再处理注解，填充至 pvs 中，最后通过 apply 方法最后完成属性依赖注入到 BeanWrapper **</p><ul><li><p><code>if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName))</code>：实例化后的后置处理器，默认返回 true，可以自定义类继承 InstantiationAwareBeanPostProcessor 修改后置处理方法的返回值为 false，使 continueWithPropertyPopulation 为 false，<strong>会导致直接返回，不进行属性的注入</strong></p></li><li><p><code>if (!continueWithPropertyPopulation)</code>：自定义方法返回值会造成该条件成立，逻辑为直接返回，<strong>不进行依赖注入</strong></p></li><li><p><code>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)</code>：处理依赖注入逻辑开始</p></li><li><p><code>mbd.getResolvedAutowireMode() == ?</code>：<strong>根据 bean 标签配置的 autowire</strong> 判断是 BY_NAME 或者 BY_TYPE</p><p><code>autowireByName(beanName, mbd, bw, newPvs)</code>：根据字段名称去获取依赖的 bean，还没注入，只是添加到 pvs</p><ul><li><p><code>propertyNames = unsatisfiedNonSimpleProperties(mbd, bw)</code>：bean 实例中有该字段和该字段的 setter 方法，但是在 bd 中没有 property 属性</p><ul><li><p>拿到配置的 property 信息和 bean 的所有字段信息</p></li><li><p><code>pd.getWriteMethod() != null</code>：<strong>当前字段是否有 set 方法，配置类注入的方式需要 set 方法</strong></p><p><code>!isExcludedFromDependencyCheck(pd)</code>：当前字段类型是否在忽略自动注入的列表中</p><p><code>!pvs.contains(pd.getName()</code>：当前字段不在 xml 或者其他方式的配置中，也就是 bd 中不存在对应的 property</p><p><code>!BeanUtils.isSimpleProperty(pd.getPropertyType()</code>：是否是基本数据类型和内置的几种数据类型，基本数据类型不允许自动注入</p></li></ul></li><li><p><code>if (containsBean(propertyName))</code>：BeanFactory 中存在当前 property 的 bean 实例，说明找到对应的依赖数据</p></li><li><p><code>getBean(propertyName)</code>：<strong>拿到 propertyName 对应的 bean 实例</strong></p></li><li><p><code>pvs.add(propertyName, bean)</code>：填充到 pvs 中</p></li><li><p><code>registerDependentBean(propertyName, beanName))</code>：添加到两个依赖 Map（dependsOn）中</p></li></ul><p><code>autowireByType(beanName, mbd, bw, newPvs)</code>：根据字段类型去查找依赖的 bean</p><ul><li><code>desc = new AutowireByTypeDependencyDescriptor(methodParam, eager)</code>：依赖描述信息</li><li><code>resolveDependency(desc, beanName, autowiredBeanNames, converter)</code>：根据描述信息，查找依赖对象，容器中没有对应的实例但是有对应的 BD，会调用 getBean(Type) 获取对象</li></ul><p><code>pvs = newPvs</code>：newPvs 是处理了依赖数据后的 pvs，所以赋值给 pvs</p></li><li><p><code>hasInstAwareBpps</code>：表示当前是否有 InstantiationAwareBeanPostProcessors 的后置处理器（Autowired）</p></li><li><p><code>pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code>：**@Autowired 注解的注入**，这个传入的 pvs 对象，最后原封不动的返回，不会添加东西</p><ul><li><p><code>findAutowiringMetadata()</code>：包装着当前 bd 需要注入的注解信息集合，<strong>三种注解的元数据</strong>，直接缓存获取</p></li><li><p><code>InjectionMetadata.InjectedElement.inject()</code>：遍历注解信息解析后注入到 Bean，方法和字段的注入实现不同</p><p>以字段注入为例：</p><ul><li><p><code>value = resolveFieldValue(field, bean, beanName)</code>：处理字段属性值</p><p><code>value = beanFactory.resolveDependency()</code>：解决依赖</p><p><code>result = doResolveDependency()</code>：<strong>真正处理自动注入依赖的逻辑</strong></p><ul><li><p><code>Object shortcut = descriptor.resolveShortcut(this)</code>：默认返回 null</p></li><li><p><code>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor)</code>：<strong>获取 @Value 的值</strong></p></li><li><p><code>converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor())</code>：如果 value 不是 null，就直接进行类型转换返回数据</p></li><li><p><code>matchingBeans = findAutowireCandidates(beanName, type, descriptor)</code>：如果 value 是空说明字段是引用类型，<strong>获取 @Autowired 的 Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addCandidateEntry() → Object beanInstance = descriptor.resolveCandidate()</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 获取 bean</span></span><br><span class="line">    <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>ReflectionUtils.makeAccessible(field)</code>：修改访问权限</p></li><li><p><code>field.set(bean, value)</code>：获取属性访问器为此 field 对象赋值</p></li></ul></li></ul></li><li><p><code>applyPropertyValues()</code>：<strong>将所有解析的 PropertyValues 的注入至 BeanWrapper 实例中</strong>（深拷贝）</p><ul><li><code>if (pvs.isEmpty())</code>：注解 @Autowired 和 @Value 标注的信息在后置处理的逻辑注入完成，此处为空直接返回</li><li>下面的逻辑进行 XML 配置的属性的注入，首先获取转换器进行数据转换，然后<strong>获取 WriteMethod (set) 方法进行反射调用</strong>，完成属性的注入</li></ul></li></ul></li><li><p><code>initializeBean(String,Object,RootBeanDefinition)</code>：<strong>初始化，分为配置文件和实现接口两种方式</strong></p><ul><li><p><code>invokeAwareMethods(beanName, bean)</code>：根据 bean 是否实现 Aware 接口执行初始化的方法</p></li><li><p><code>wrappedBean = applyBeanPostProcessorsBeforeInitialization</code>：初始化前的后置处理器，可以继承接口重写方法</p><ul><li><code>processor.postProcessBeforeInitialization()</code>：执行后置处理的方法，默认返回 bean 本身</li><li><code>if (current == null) return result</code>：重写方法返回 null，会造成后置处理的短路，直接返回</li></ul></li><li><p><code>invokeInitMethods(beanName, wrappedBean, mbd)</code>：<strong>反射执行初始化方法</strong></p><ul><li><p><code>isInitializingBean = (bean instanceof InitializingBean)</code>：初始化方法的定义有两种方式，一种是自定义类实现 InitializingBean 接口，另一种是配置文件配置 &lt;bean id&#x3D;”…” class&#x3D;”…” init-method&#x3D;”init”&#x2F; &gt;</p></li><li><p><code>isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))</code>：</p><ul><li><p>条件一：当前 bean 是不是实现了 InitializingBean </p></li><li><p>条件二：InitializingBean 接口中的方法 afterPropertiesSet，判断该方法是否是容器外管理的方法</p></li></ul></li><li><p><code>if (mbd != null &amp;&amp; bean.getClass() != NullBean.class)</code>：成立说明是配置文件的方式</p><p><code>if(!(接口条件))</code>表示<strong>如果通过接口实现了初始化方法的话，就不会在调用配置类中 init-method 定义的方法</strong></p><p><code>((InitializingBean) bean).afterPropertiesSet()</code>：调用方法</p><p><code>invokeCustomInitMethod</code>：执行自定义的方法</p><ul><li><code>initMethodName = mbd.getInitMethodName()</code>：获取方法名</li><li><code>Method initMethod = ()</code>：根据方法名获取到 init-method 方法</li><li><code> methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod)</code>：将方法转成从接口层面获取</li><li><code>ReflectionUtils.makeAccessible(methodToInvoke)</code>：访问权限设置成可访问</li><li><code> methodToInvoke.invoke(bean)</code>：<strong>反射调用初始化方法</strong>，以当前 bean 为角度去调用</li></ul></li></ul></li><li><p><code>wrappedBean = applyBeanPostProcessorsAfterInitialization</code>：初始化后的后置处理器</p><ul><li><p><code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code>：如果 Bean 被子类标识为要代理的 bean，则使用配置的拦截器<strong>创建代理对象</strong>，AOP 部分详解</p></li><li><p>如果不存在循环依赖，创建动态代理 bean 在此处完成；否则真正的创建阶段是在属性填充时获取提前引用的阶段，<strong>循环依赖</strong>详解，源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该集合用来避免重复将某个 bean 生成代理对象，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 beanName 或者加上 &amp;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);y</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey)</span> != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>if (earlySingletonExposure)</code>：是否允许提前引用</p><p><code>earlySingletonReference = getSingleton(beanName, false)</code>：<strong>从二级缓存获取实例</strong>，放入一级缓存是在 doGetBean 中的sharedInstance &#x3D; getSingleton() 逻辑中，此时在 createBean 的逻辑还没有返回，所以一级缓存没有</p><p><code>if (earlySingletonReference != null)</code>：当前 bean 实例从二级缓存中获取到了，说明<strong>产生了循环依赖</strong>，在属性填充阶段会提前调用三级缓存中的工厂生成 Bean 的代理对象（或原始实例），放入二级缓存中，然后使用原始 bean 继续执行初始化</p><ul><li><p><code> if (exposedObject == bean)</code>：<strong>初始化后的 bean &#x3D;&#x3D; 创建的原始实例</strong>，条件成立的两种情况：当前的真实实例不需要被代理；当前实例存在循环依赖已经被提前代理过了，初始化时的后置处理器直接返回 bean 原实例</p><p><code>exposedObject = earlySingletonReference</code>：<strong>把代理后的 Bean 传给 exposedObject 用来返回，因为只有代理对象才封装了拦截器链，main 方法中用代理对象调用方法时会进行增强，代理是对原始对象的包装，所以这里返回的代理对象中含有完整的原实例（属性填充和初始化后的），是一个完整的代理对象，返回后外层方法会将当前 Bean 放入一级缓存</strong></p></li><li><p><code>else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName))</code>：是否有其他 bean 依赖当前 bean，执行到这里说明是不存在循环依赖、存在增强代理的逻辑，也就是正常的逻辑</p><ul><li><p><code>dependentBeans = getDependentBeans(beanName)</code>：取到依赖当前 bean 的其他 beanName</p></li><li><p><code>if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))</code>：判断 dependentBean 是否创建完成</p><ul><li><code>if (!this.alreadyCreated.contains(beanName))</code>：成立当前 bean 尚未创建完成，当前 bean 是依赖exposedObject 的 bean，返回 true</li></ul></li><li><p><code>return false</code>：创建完成返回 false</p><p><code>actualDependentBeans.add(dependentBean)</code>：创建完成的 dependentBean 加入该集合</p></li><li><p><code>if (!actualDependentBeans.isEmpty())</code>：条件成立说明有依赖于当前 bean 的 bean 实例创建完成，但是当前的 bean 还没创建完成返回，依赖当前 bean 的外部 bean 持有的是不完整的 bean，所以需要报错</p></li></ul></li></ul></li><li><p><code>registerDisposableBeanIfNecessary</code>：判断当前 bean 是否需要<strong>注册析构函数回调</strong>，当容器销毁时进行回调</p><ul><li><p><code>if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))</code></p><ul><li><p>如果是原型 prototype 不会注册析构回调，不会回调该函数，对象的回收由 JVM 的 GC 机制完成</p></li><li><p>requiresDestruction()：</p><ul><li><p><code>DisposableBeanAdapter.hasDestroyMethod(bean, mbd)</code>：bd 中定义了 DestroyMethod 返回 true</p></li><li><p><code>hasDestructionAwareBeanPostProcessors()</code>：后处理器框架决定是否进行析构回调</p></li></ul></li></ul></li><li><p><code>registerDisposableBean()</code>：条件成立进入该方法，给当前单实例注册回调适配器，适配器内根据当前 bean 实例是继承接口（DisposableBean）还是自定义标签来判定具体调用哪个方法实现</p></li></ul></li><li><p><code>this.disposableBeans.put(beanName, bean)</code>：向销毁集合添加实例</p></li></ul><hr><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>AbstractAutowireCapableBeanFactory.createBeanInstance(beanName, RootBeanDefinition, Object[] args)</p><ul><li><p><code>resolveBeanClass(mbd, beanName)</code>：确保 Bean 的 Class 真正的被加载</p></li><li><p>判断类的访问权限是不是 public，不是进入下一个判断，是否允许访问类的 non-public 的构造方法，不允许则报错</p></li><li><p><code>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier()</code>：获取创建实例的函数，可以自定义，没有进入下面的逻辑</p></li><li><p><code>if (mbd.getFactoryMethodName() != null)</code>：<strong>判断 bean 是否设置了 factory-method 属性，优先使用</strong></p><p><bean class="" factory-method="">，设置了该属性进入 factory-method 方法创建实例</p></li><li><p><code>resolved = false</code>：代表 bd 对应的构造信息是否已经解析成可以反射调用的构造方法</p></li><li><p><code>autowireNecessary = false</code>：是否自动匹配构造方法</p></li><li><p><code>if(mbd.resolvedConstructorOrFactoryMethod != null)</code>：获取 bd 的构造信息转化成反射调用的 method 信息</p><ul><li>method 为 null 则 resolved 和 autowireNecessary 都为默认值 false</li><li><code>autowireNecessary = mbd.constructorArgumentsResolved</code>：构造方法有参数，设置为 true</li></ul></li><li><p><strong>bd 对应的构造信息解析完成，可以直接反射调用构造方法了</strong>：</p><ul><li><p><code>return autowireConstructor(beanName, mbd, null, null)</code>：<strong>有参构造</strong>，根据参数匹配最优的构造器创建实例</p></li><li><p><code>return instantiateBean(beanName, mbd)</code>：<strong>无参构造方法通过反射创建实例</strong></p><ul><li><p><code>SimpleInstantiationStrategy.instantiate()</code>：<strong>真正用来实例化的函数</strong>（无论如何都会走到这一步）</p><ul><li><p><code>if (!bd.hasMethodOverrides())</code>：没有方法重写覆盖</p><p><code>BeanUtils.instantiateClass(constructorToUse)</code>：调用 <code>Constructor.newInstance()</code> 实例化</p></li><li><p><code>instantiateWithMethodInjection(bd, beanName, owner)</code>：<strong>有方法重写采用 CGLIB  实例化</strong></p></li></ul></li><li><p><code>BeanWrapper bw = new BeanWrapperImpl(beanInstance)</code>：包装成 BeanWrapper 类型的对象</p></li><li><p><code>return bw</code>：返回实例</p></li></ul></li></ul></li><li><p><code>ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName)</code>：**@Autowired 注解**，对应的后置处理器 AutowiredAnnotationBeanPostProcessor 逻辑</p><ul><li><p>配置了 lookup 的相关逻辑</p></li><li><p><code>this.candidateConstructorsCache.get(beanClass)</code>：从缓存中获取构造方法，第一次获取为 null，进入下面逻辑</p></li><li><p><code>rawCandidates = beanClass.getDeclaredConstructors()</code>：获取所有的构造器</p></li><li><p><code>Constructor&lt;?&gt; requiredConstructor = null</code>：唯一的选项构造器，**@Autowired(required &#x3D; “true”)** 时有值</p></li><li><p><code>for (Constructor&lt;?&gt; candidate : rawCandidates)</code>：遍历所有的构造器：</p><p><code>ann = findAutowiredAnnotation(candidate)</code>：有三种注解中的一个会返回注解的属性</p><ul><li><p>遍历 this.autowiredAnnotationTypes 中的三种注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);<span class="comment">//！！！！！！！！！！！！！！</span></span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(...ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><code> AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type)</code>：获取注解的属性</p></li><li><p><code>if (attributes != null) return attributes</code>：任意一个注解属性不为空就注解返回</p></li></ul><p><code>if (ann == null)</code>：注解属性为空</p><ul><li><code>userClass = ClassUtils.getUserClass(beanClass)</code>：如果当前 beanClass 是代理对象，方法上就已经没有注解了，所以<strong>获取原始的用户类型重新获取该构造器上的注解属性</strong>（<strong>事务注解失效</strong>也是这个原理）</li></ul><p><code>if (ann != null)</code>：注解属性不为空了</p><ul><li><p><code>required = determineRequiredStatus(ann)</code>：获取 required 属性的值</p><ul><li><code>!ann.containsKey(this.requiredParameterName) || </code>：判断属性是否包含 required，不包含进入后面逻辑</li><li><code>this.requiredParameterValue == ann.getBoolean(this.requiredParameterName)</code>：获取属性值返回</li></ul></li><li><p><code>if (required)</code>：代表注解 @Autowired(required &#x3D; true)</p><p><code>if (!candidates.isEmpty())</code>：true 代表只能有一个构造方法，构造集合不是空代表可选的构造器不唯一，报错</p><p><code>requiredConstructor = candidate</code>：把构造器赋值给 requiredConstructor</p></li><li><p><code>candidates.add(candidate)</code>：把当前构造方法添加至 candidates 集合</p></li></ul><p><code> if(candidate.getParameterCount() == 0)</code>：当前遍历的构造器的参数为 0 代表没有参数，是<strong>默认构造器</strong>，赋值给 defaultConstructor </p></li><li><p><code>candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0])</code>：<strong>将构造器转成数组返回</strong></p></li></ul></li><li><p><code>if(ctors != null)</code>：条件成立代表指定了<strong>构造方法数组</strong></p><p><code>mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR</code>：<bean autowire=""> 标签内 autowiremode 的属性值，默认是 no，AUTOWIRE_CONSTRUCTOR 代表选择最优的构造方法</p><p><code>mbd.hasConstructorArgumentValues()</code>：bean 信息中是否配置了构造参数的值</p><p><code>!ObjectUtils.isEmpty(args)</code>：getBean 时，指定了参数 arg</p></li><li><p><code>return autowireConstructor(beanName, mbd, ctors, args)</code>：<strong>选择最优的构造器进行创建实例</strong>（复杂，不建议研究）</p><ul><li><p><code>beanFactory.initBeanWrapper(bw)</code>：向 BeanWrapper 中注册转换器，向工厂中注册属性编辑器</p></li><li><p><code>Constructor&lt;?&gt; constructorToUse = null</code>：实例化反射构造器</p><p><code>ArgumentsHolder argsHolderToUse</code>：实例化时真正去用的参数，并持有对象</p><ul><li>rawArguments 是转换前的参数，arguments 是类型转换完成的参数</li></ul><p><code>Object[] argsToUse</code>：参数实例化时使用的参数</p></li><li><p><code>Object[] argsToResolve</code>：表示构造器参数做转换后的参数引用</p></li><li><p><code>if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved)</code>：</p><ul><li>条件一成立说明当前 bd 生成的实例不是第一次，缓存中有解析好的构造器方法可以直接拿来反射调用</li><li>条件二成立说明构造器参数已经解析过了</li></ul></li><li><p><code>argsToUse = resolvePreparedArguments()</code>：argsToResolve 不是完全解析好的，还需要继续解析</p></li><li><p><code>if (constructorToUse == null || argsToUse == null)</code>：条件成立说明缓存机制失败，进入构造器匹配逻辑</p></li><li><p><code>Constructor&lt;?&gt;[] candidates = chosenCtors</code>：chosenCtors  只有在构造方法上有 autowaire 三种注解时才有数据</p></li><li><p><code>if (candidates == null)</code>：candidates 为空就根据 beanClass 是否允许访问非公开的方法来获取构造方法</p></li><li><p><code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code>：默认无参</p><p><code>bw.setBeanInstance(instantiate())</code>：<strong>使用无参构造器反射调用，创建出实例对象，设置到 BeanWrapper 中去</strong></p></li><li><p><code>boolean autowiring</code>：<strong>需要选择最优的构造器</strong></p></li><li><p><code>cargs = mbd.getConstructorArgumentValues()</code>：获取参数值</p><p><code>resolvedValues = new ConstructorArgumentValues()</code>：获取已经解析后的构造器参数值</p><ul><li><code>final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues</code>：key 是 index， value 是值</li><li><code>final List&lt;ValueHolder&gt; genericArgumentValues</code>：没有 index 的值</li></ul><p><code>minNrOfArgs = resolveConstructorArguments(..,resolvedValues)</code>：从 bd 中解析并获取构造器参数的个数</p><ul><li><code>valueResolver.resolveValueIfNecessary()</code>：将引用转换成真实的对象</li><li><code>resolvedValueHolder.setSource(valueHolder)</code>：将对象填充至 ValueHolder 中</li><li><code> resolvedValues.addIndexedArgumentValue()</code>：将参数值封装至 resolvedValues 中</li></ul></li><li><p><code>AutowireUtils.sortConstructors(candidates)</code>：排序规则 public &gt; 非公开的 &gt; 参数多的 &gt; 参数少的</p></li><li><p><code> int minTypeDiffWeight = Integer.MAX_VALUE</code>：值越低说明构造器<strong>参数列表类型</strong>和构造参数的匹配度越高</p></li><li><p><code>Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors</code>：模棱两可的构造器，两个构造器匹配度相等时放入</p></li><li><p><code>for (Constructor&lt;?&gt; candidate : candidates)</code>：遍历筛选出 minTypeDiffWeight 最低的构造器</p></li><li><p><code>Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes()</code>：获取当前处理的构造器的参数类型</p></li><li><p><code>if()</code>：candidates 是排过序的，当前筛选出来的构造器的优先级一定是优先于后面的 constructor</p></li><li><p><code>if (paramTypes.length &lt; minNrOfArgs)</code>：需求的小于给的，不匹配</p></li><li><p><code>int typeDiffWeight</code>：获取匹配度</p><ul><li><code>mbd.isLenientConstructorResolution()</code>：true 表示 ambiguousConstructors 允许有数据，false 代表不允许有数据，有数据就报错（LenientConstructorResolution：宽松的构造函数解析）</li><li><code>argsHolder.getTypeDifferenceWeight(paramTypes)</code>：选择参数转换前和转换后匹配度最低的，循环向父类中寻找该方法，直到寻找到 Obejct 类</li></ul></li><li><p><code> if (typeDiffWeight &lt; minTypeDiffWeight)</code>：条件成立说明当前循环处理的构造器更优</p></li><li><p><code>else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight)</code>：当前处理的构造器的计算出来的 DiffWeight 与上一次筛选出来的最优构造器的值一致，说明有模棱两可的情况</p></li><li><p><code>if (constructorToUse == null)</code>：未找到可以使用的构造器，报错</p></li><li><p><code> else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution())</code>：模棱两可有数据，LenientConstructorResolution &#x3D;&#x3D; false，所以报错</p></li><li><p><code>argsHolderToUse.storeCache(mbd, constructorToUse)</code>：匹配成功，进行缓存，方便后来者使用该 bd 实例化</p></li><li><p><code> bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse))</code>：匹配成功调用 instantiate 创建出实例对象，设置到 BeanWrapper 中去</p></li></ul></li><li><p><code>return instantiateBean(beanName, mbd)</code>：默认走到这里</p></li></ul><hr><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>循环依赖：是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成一个环形调用</p><p>Spring 循环依赖有四种：</p><ul><li>DependsOn 依赖加载【无法解决】（两种 Map）</li><li>原型模式 Prototype 循环依赖【无法解决】（正在创建集合）</li><li>单例 Bean 循环依赖：构造参数产生依赖【无法解决】（正在创建集合，getSingleton() 逻辑中）</li><li>单例 Bean 循环依赖：setter 产生依赖【可以解决】</li></ul><p>解决循环依赖：提前引用，提前暴露创建中的 Bean</p><ul><li>Spring 先实例化 A，拿到 A 的构造方法反射创建出来 A 的早期实例对象，这个对象被包装成 ObjectFactory 对象，放入三级缓存</li><li>处理 A 的依赖数据，检查发现 A 依赖 B 对象，所以 Spring 就会去根据 B 类型到容器中去 getBean(B)，这里产生递归</li><li>拿到 B 的构造方法，进行反射创建出来 B 的早期实例对象，也会把 B 包装成 ObjectFactory 对象，放到三级缓存，处理 B 的依赖数据，检查发现 B 依赖了 A 对象，然后 Spring 就会去根据 A 类型到容器中去 getBean(A.class)</li><li>这时从三级缓存中获取到 A 的早期对象进入属性填充</li></ul><p>循环依赖的三级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级缓存：存放所有初始化完成单实例 bean，单例池，key是beanName，value是对应的单实例对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级缓存：存放实例化未进行初始化的 Bean，提前引用池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. 3*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p>为什么需要三级缓存？</p><ul><li>循环依赖解决需要提前引用动态代理对象，AOP 动态代理是在 Bean 初始化后的后置处理中进行，这时的 bean 已经是成品对象。因为需要提前进行动态代理，三级缓存的 ObjectFactory 提前产生需要代理的对象，把提前引用放入二级缓存</li><li>如果只有二级缓存，提前引用就直接放入了一级缓存，然后 Bean 初始化完成后又会放入一级缓存，产生数据覆盖，<strong>导致提前引用的对象和一级缓存中的并不是同一个对象</strong></li><li>一级缓存只能存放完整的单实例，<strong>为了保证 Bean 的生命周期不被破坏</strong>，不能将未初始化的 Bean 暴露到一级缓存</li><li>若存在循环依赖，<strong>后置处理不创建代理对象，真正创建代理对象的过程是在 getBean(B) 的阶段中</strong></li></ul></li><li><p>三级缓存一定会创建提前引用吗？</p><ul><li>出现循环依赖就会去三级缓存获取提前引用，不出现就不会，走正常的逻辑，创建完成直接放入一级缓存</li><li>存在循环依赖，就创建代理对象放入二级缓存，如果没有增强方法就返回 createBeanInstance 创建的实例，因为 addSingletonFactory 参数中传入了实例化的 Bean，在 singletonFactory.getObject() 中返回给 singletonObject，所以<strong>存在循环依赖就一定会使用工厂</strong>，但是不一定创建的是代理对象，不需要增强就是原始对象</li></ul></li><li><p>wrapIfNecessary 一定创建代理对象吗？（AOP 动态代理部分有源码解析）</p><ul><li>存在增强器会创建动态代理，不需要增强就不需要创建动态代理对象</li><li>存在循环依赖会提前增强，初始化后不需要增强</li></ul></li><li><p>什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？</p><ul><li><p>实例化之后，依赖注入之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createBeanInstance -&gt; addSingletonFactory -&gt; populateBean</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>假如 A 依赖 B，B 依赖 A</p><ul><li><p>当 A 创建实例后填充属性前，执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加给定的单例工厂以构建指定的单例</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 单例池包含该Bean说明已经创建完成，不需要循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">//加入三级缓存</span></span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName,singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="comment">// 从二级缓存移除，因为三个Map中都是一个对象，不能同时存在！</span></span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>填充属性时 A 依赖 B，这时需要 getBean(B)，也会把 B 的工厂放入三级缓存，接着 B 填充属性时发现依赖 A，去进行**第一次 ** getSingleton(A)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);<span class="comment">//为true代表允许拿到早期引用。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 在一级缓存中获取 beanName 对应的单实例对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 单实例确实尚未创建；单实例正在创建，发生了循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存获取</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存不存在，并且允许获取早期实例对象，去三级缓存查看</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从三级缓存获取工厂对象，并得到 bean 的提前引用</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 【缓存升级】，放入二级缓存，提前引用池</span></span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 从三级缓存移除该对象</span></span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从三级缓存获取 A 的 Bean：<code>singletonFactory.getObject()</code>，调用了 lambda 表达式的 getEarlyBeanReference 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="comment">// 【向提前引用代理池 earlyProxyReferences 中添加该 Bean，防止对象被重新代理】</span></span><br><span class="line">    <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="comment">// 创建代理对象，createProxy</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B 填充了 A 的提前引用后会继续初始化直到完成，<strong>返回原始 A 的逻辑继续执行</strong></p></li></ul><hr><h3 id="AOP-2"><a href="#AOP-2" class="headerlink" title="AOP"></a>AOP</h3><h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p>@EnableAspectJAutoProxy：AOP 注解驱动，给容器中导入 AspectJAutoProxyRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">// 是否强制使用 CGLIB 创建代理对象 </span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前代理对象暴露到上下文内，方便代理对象内部的真实对象拿到代理对象</span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJAutoProxyRegistrar 在用来向容器中注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>，以 BeanDefiantion 形式存在，在容器初始化时加载。AnnotationAwareAspectJAutoProxyCreator 间接实现了 InstantiationAwareBeanPostProcessor，Order 接口，该类会在 Bean 的实例化和初始化的前后起作用</p><p>工作流程：创建 IOC 容器，调用 refresh() 刷新容器，<code>registerBeanPostProcessors(beanFactory)</code> 阶段，通过 getBean() 创建 AnnotationAwareAspectJAutoProxyCreator 对象，在生命周期的初始化方法中执行回调 initBeanFactory() 方法初始化注册三个工具类：BeanFactoryAdvisorRetrievalHelperAdapter、ReflectiveAspectJAdvisorFactory、BeanFactoryAspectJAdvisorsBuilderAdapter</p><hr><h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>Bean 初始化完成的执行后置处理器的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 【beanName 或者加上 &amp; 的 beanName】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该 key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAutoProxyCreator.wrapIfNecessary()：根据通知创建动态代理，没有通知直接返回原实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件一般不成立，很少使用 TargetSourceCreator 去创建对象 BeforeInstantiation 阶段，doCreateBean 之前的阶段</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// advisedBeans 集合保存的是 bean 是否被增强过了</span></span><br><span class="line">    <span class="comment">// 条件成立说明当前 beanName 对应的实例不需要被增强处理，判断是在 BeforeInstantiation 阶段做的</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件一：判断当前 bean 类型是否是基础框架类型，这个类的实例不能被增强</span></span><br><span class="line">    <span class="comment">// 条件二：shouldSkip 判断当前 beanName 是否是 .ORIGINAL 结尾，如果是就跳过增强逻辑，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【查找适合当前 bean 实例的增强方法】（下一节详解）</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 条件成立说明上面方法查询到适合当前class的通知</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 根据查询到的增强创建代理对象（下一节详解）</span></span><br><span class="line">        <span class="comment">// 参数一：目标对象</span></span><br><span class="line">        <span class="comment">// 参数二：beanName</span></span><br><span class="line">        <span class="comment">// 参数三：匹配当前目标对象 clazz 的 Advisor 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="comment">// 保存代理对象类型</span></span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行到这里说明没有查到通知，当前 bean 不需要增强</span></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="comment">// 【返回原始的 bean 实例】</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h4><p>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()：查找适合当前类实例的增强，并进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">// 查询适合当前类型的增强通知</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 增强为空直接返回 null，不需要创建代理</span></span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是空，转成数组返回</span></span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()：</p><ul><li><p><code>candidateAdvisors = findCandidateAdvisors()</code>：<strong>获取当前容器内可以使用（所有）的 advisor</strong>，调用的是 AnnotationAwareAspectJAutoProxyCreator 类的方法，每个方法对应一个 Advisor </p><ul><li><p><code>advisors = super.findCandidateAdvisors()</code>：<strong>查询出 XML 配置的所有 Advisor 类型</strong></p><ul><li><code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors()</code>：通过 BF 查询出来 BD 配置的 class 中 是 Advisor 子类的 BeanName</li><li><code>advisors.add()</code>：使用 Spring 容器获取当前这个 Advisor 类型的实例</li></ul></li><li><p><code>advisors.addAll(....buildAspectJAdvisors())</code>：<strong>获取所有添加 @Aspect 注解类中的 Advisor</strong></p><p><code>buildAspectJAdvisors()</code>：构建的方法，<strong>把 Advice 封装成 Advisor</strong></p><ul><li><p><code> beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)</code>：获取出容器内 Object 所有的 beanName，就是全部的</p></li><li><p><code> for (String beanName : beanNames)</code>：遍历所有的 beanName，判断每个 beanName 对应的 Class 是否是 Aspect 类型，就是加了 @Aspect 注解的类</p><ul><li><p><code>factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName)</code>：使用工厂模式管理 Aspect 的元数据，关联的真实 @Aspect 注解的实例对象</p></li><li><p><code>classAdvisors = this.advisorFactory.getAdvisors(factory)</code>：添加了 @Aspect 注解的类的通知信息</p><ul><li><p>aspectClass：@Aspect 标签的类的 class</p></li><li><p><code>for (Method method : getAdvisorMethods(aspectClass))</code>：遍历<strong>不包括 @Pointcut 注解的方法</strong></p><p><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName)</code>：<strong>将当前 method 包装成 Advisor 数据</strong></p><ul><li><p><code>AspectJExpressionPointcut expressionPointcut = getPointcut()</code>：获取切点表达式</p></li><li><p><code>return new InstantiationModelAwarePointcutAdvisorImpl()</code>：把 method 中 Advice 包装成 Advisor，Spring 中每个 Advisor 内部一定是持有一个 Advice 的，Advice 内部最重要的数据是当前 method 和aspectInstanceFactory，工厂用来获取实例</p><p><code>this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)</code>：实例化 Advice 对象，逻辑是获取注解信息，根据注解的不同生成对应的 Advice 对象</p></li></ul></li></ul></li><li><p><code>advisors.addAll(classAdvisors)</code>：保存通过 @Aspect 注解定义的 Advisor 数据</p></li></ul></li><li><p><code>this.aspectBeanNames = aspectNames</code>：将所有 @Aspect 注解 beanName 缓存起来，表示提取 Advisor 工作完成</p></li><li><p><code>return advisors</code>：返回 Advisor 列表</p></li></ul></li></ul></li><li><p><code>eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, ...)</code>：<strong>选出匹配当前类的增强</strong></p><ul><li><p><code>if (candidateAdvisors.isEmpty())</code>：条件成立说明当前 Spring 没有可以操作的 Advisor</p></li><li><p><code>List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;()</code>：存放匹配当前 beanClass 的 Advisors 信息</p></li><li><p><code>for (Advisor candidate : candidateAdvisors)</code>：<strong>遍历所有的 Advisor</strong></p><p><code> if (canApply(candidate, clazz, hasIntroductions))</code>：判断遍历的 advisor 是否匹配当前的 class，匹配就加入集合</p><ul><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：创建的 advisor 是 InstantiationModelAwarePointcutAdvisorImpl 类型</p><p><code>PointcutAdvisor pca = (PointcutAdvisor) advisor</code>：封装当前 Advisor</p><p><code>return canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>：重载该方法</p><ul><li><code>if (!pc.getClassFilter().matches(targetClass))</code>：<strong>类不匹配 Pointcut 表达式，直接返回 false</strong></li><li><code>methodMatcher = pc.getMethodMatcher()</code>：<strong>获取 Pointcut 方法匹配器</strong>，类匹配进行类中方法的匹配</li><li><code>Set&lt;Class&lt;?&gt;&gt; classes</code>：保存目标对象 class 和目标对象父类超类的接口和自身实现的接口</li><li><code>if (!Proxy.isProxyClass(targetClass))</code>：判断当前实例是不是代理类，确保 class 内存储的数据包括目标对象的class  而不是代理类的 class</li><li><code>for (Class&lt;?&gt; clazz : classes)</code>：<strong>检查目标 class 和上级接口的所有方法，查看是否会被方法匹配器匹配</strong>，如果有一个方法匹配成功，就说明目标对象 AOP 代理需要增强<ul><li><code>specificMethod = AopUtils.getMostSpecificMethod(method, targetClass)</code>：方法可能是接口的，判断当前类有没有该方法</li><li><code>return (specificMethod != method &amp;&amp; matchesMethod(specificMethod))</code>：<strong>类和方法的匹配</strong>，不包括参数</li></ul></li></ul></li></ul></li></ul></li><li><p><code>extendAdvisors(eligibleAdvisors)</code>：在 eligibleAdvisors 列表的索引 0 的位置添加 DefaultPointcutAdvisor，<strong>封装了 ExposeInvocationInterceptor 拦截器</strong></p></li><li><p><code> eligibleAdvisors = sortAdvisors(eligibleAdvisors)</code>：<strong>对拦截器进行排序</strong>，数值越小优先级越高，高的排在前面</p><ul><li>实现 Ordered 或 PriorityOrdered 接口，PriorityOrdered 的级别要优先于 Ordered，使用 OrderComparator 比较器</li><li>使用 @Order（Spring 规范）或 @Priority（JDK 规范）注解，使用 AnnotationAwareOrderComparator 比较器</li><li>ExposeInvocationInterceptor 实现了 PriorityOrdered ，所以总是排在第一位，MethodBeforeAdviceInterceptor 没实现任何接口，所以优先级最低，排在最后</li></ul></li><li><p><code>return eligibleAdvisors</code>：返回拦截器链</p></li></ul><hr><h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><p>AbstractAutoProxyCreator.createProxy()：根据增强方法创建代理对象</p><ul><li><p><code>ProxyFactory proxyFactory = new ProxyFactory()</code>：<strong>无参构造 ProxyFactory</strong>，此处讲解一下两种有参构造方法：</p><ul><li><p>public ProxyFactory(Object target)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"><span class="comment">// 将目标对象封装成 SingletonTargetSource 保存到父类的字段中</span></span><br><span class="line">   setTarget(target);</span><br><span class="line">    <span class="comment">// 获取目标对象 class 所有接口保存到 AdvisedSupport 中的 interfaces 集合中</span></span><br><span class="line">   setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassUtils.getAllInterfaces(target) 底层调用 getAllInterfacesForClassAsSet(java.lang.Class&lt;?&gt;, java.lang.ClassLoader)：</p><ul><li><code>if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader))</code>：<ul><li>条件一：判断当前目标对象是接口</li><li>条件二：检查给定的类在给定的 ClassLoader 中是否可见</li></ul></li><li><code>Class&lt;?&gt;[] ifcs = current.getInterfaces()</code>：拿到自己实现的接口，拿不到接口实现的接口</li><li><code>current = current.getSuperclass()</code>：递归寻找父类的接口，去获取父类实现的接口</li></ul></li><li><p>public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个代理的接口</span></span><br><span class="line">    addInterface(proxyInterface);</span><br><span class="line">    <span class="comment">// 添加通知，底层调用 addAdvisor</span></span><br><span class="line">    addAdvice(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>addAdvisor(pos, new DefaultPointcutAdvisor(advice))</code>：Spring 中 Advice 对应的接口就是 Advisor，Spring 使用 Advisor 包装 Advice 实例</li></ul></li></ul></li><li><p><code>proxyFactory.copyFrom(this)</code>：填充一些信息到 proxyFactory</p></li><li><p><code>if (!proxyFactory.isProxyTargetClass())</code>：条件成立说明 proxyTargetClass 为 false（默认），两种配置方法：</p><ul><li><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; </code>：强制使用 CGLIB</li><li><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></li></ul><p><code>if (shouldProxyTargetClass(beanClass, beanName))</code>：如果 bd 内有 preserveTargetClass &#x3D; true ，那么这个 bd 对应的 class <strong>创建代理时必须使用 CGLIB</strong>，条件成立设置 proxyTargetClass 为 true</p><p><code>evaluateProxyInterfaces(beanClass, proxyFactory)</code>：<strong>根据目标类判定是否可以使用 JDK 动态代理</strong></p><ul><li><code>targetInterfaces = ClassUtils.getAllInterfacesForClass()</code>：获取当前目标对象 class 和父类的全部实现接口</li><li><code>boolean hasReasonableProxyInterface = false</code>：实现的接口中是否有一个合理的接口</li><li><code>if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0)</code>：遍历所有的接口，如果有任意一个接口满足条件，设置 hRPI 变量为 true<ul><li>条件一：判断当前接口是否是 Spring 生命周期内会回调的接口</li><li>条件二：接口不能是 GroovyObject、Factory、MockAccess 类型的</li><li>条件三：找到一个可以使用的被代理的接口</li></ul></li><li><code>if (hasReasonableProxyInterface)</code>：<strong>有合理的接口，将这些接口设置到 proxyFactory 内</strong></li><li><code>proxyFactory.setProxyTargetClass(true)</code>：<strong>没有合理的代理接口，强制使用 CGLIB 创建对象</strong></li></ul></li><li><p><code>advisors = buildAdvisors(beanName, specificInterceptors)</code>：匹配目标对象 clazz 的 Advisors，填充至 ProxyFactory</p></li><li><p><code>proxyFactory.setPreFiltered(true)</code>：设置为 true 表示传递给 proxyFactory 的 Advisors 信息做过基础类和方法的匹配</p></li><li><p><code>return proxyFactory.getProxy(getProxyClassLoader())</code>：创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)：参数是一个配置对象，保存着创建代理需要的生产资料，会加锁创建，保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 条件二为 true 代表强制使用 CGLIB 动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || </span><br><span class="line">        <span class="comment">// 条件三：被代理对象没有实现任何接口或者只实现了 SpringProxy 接口，只能使用 CGLIB 动态代理</span></span><br><span class="line">        hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立说明 target 【是接口或者是已经被代理过的类型】，只能使用 JDK 动态代理</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);<span class="comment">// 使用 JDK 动态代理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);<span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);<span class="comment">// 【有接口的情况下只能使用 JDK 动态代理】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JdkDynamicAopProxy.getProxy(java.lang.ClassLoader)：获取 JDK 的代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 配置类封装到 JdkDynamicAopProxy.advised 属性中</span></span><br><span class="line">    <span class="built_in">this</span>.advised = config;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取需要代理的接口数组</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找当前所有的需要代理的接口，看是否有 equals 方法和 hashcode 方法，如果有就做一个标记</span></span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法最终返回一个代理类对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// classLoader：类加载器  proxiedInterfaces：生成的代理类，需要实现的接口集合</span></span><br><span class="line">    <span class="comment">// this JdkDynamicAopProxy 实现了 InvocationHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopProxyUtils.completeProxiedInterfaces(this.advised, true)：获取代理的接口数组，并添加 SpringProxy 接口</p><ul><li><p><code>specifiedInterfaces = advised.getProxiedInterfaces()</code>：从 ProxyFactory 中拿到所有的 target 提取出来的接口</p><ul><li><code>if (specifiedInterfaces.length == 0)</code>：如果没有实现接口，检查当前 target 是不是接口或者已经是代理类，封装到 ProxyFactory 的 interfaces 集合中</li></ul></li><li><p><code> addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)</code>：判断目标对象所有接口中是否有 SpringProxy 接口，没有的话需要添加，这个接口<strong>标识这个代理类型是 Spring 管理的</strong></p><ul><li><code>addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>：判断目标对象的所有接口，是否已经有 Advised 接口</li><li><code> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class))</code>：判断目标对象的所有接口，是否已经有 DecoratingProxy 接口</li><li><code>int nonUserIfcCount = 0</code>：非用户自定义的接口数量，接下来要添加上面的三个接口了</li><li><code>proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount]</code>：创建一个新的 class 数组，长度是原目标对象提取出来的接口数量和 Spring 追加的数量，然后进行 <strong>System.arraycopy 拷贝到新数组中</strong></li><li><code>int index = specifiedInterfaces.length</code>：获取原目标对象提取出来的接口数量，当作 index</li><li><code>if(addSpringProxy)</code>：根据上面三个布尔值把接口添加到新数组中</li><li><code>return proxiedInterfaces</code>：返回追加后的接口集合</li></ul></li></ul><p>JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods()：查找在任何定义在接口中的 equals 和 hashCode 方法</p><ul><li><code>for (Class&lt;?&gt; proxiedInterface : proxiedInterfaces)</code>：遍历所有的接口<ul><li><p><code> Method[] methods = proxiedInterface.getDeclaredMethods()</code>：获取接口中的所有方法</p></li><li><p><code>for (Method method : methods)</code>：遍历所有的方法</p><ul><li><code>if (AopUtils.isEqualsMethod(method))</code>：当前方法是 equals 方法，把 equalsDefined 置为 true</li><li><code>if (AopUtils.isHashCodeMethod(method))</code>：当前方法是 hashCode 方法，把 hashCodeDefined 置为 true</li></ul></li><li><p><code>if (this.equalsDefined &amp;&amp; this.hashCodeDefined)</code>：如果有一个接口中有这两种方法，直接返回</p></li></ul></li></ul></li></ul><hr><h4 id="方法增强"><a href="#方法增强" class="headerlink" title="方法增强"></a>方法增强</h4><p>main() 函数中调用用户方法，会进入代理对象的 invoke 方法</p><p>JdkDynamicAopProxy 类中的 invoke 方法是真正执行代理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy：代理对象，method：目标对象的方法，args：目标对象方法对应的参数</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advised 就是初始化 JdkDynamicAopProxy 对象时传入的变量</span></span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 条件成立说明代理类实现的接口没有定义 equals 方法，并且当前 method 调用 equals 方法，</span></span><br><span class="line">        <span class="comment">// 就调用 JdkDynamicAopProxy 提供的 equals 方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line"><span class="comment">// 需不需要暴露当前代理对象到 AOP 上下文内</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 【把代理对象设置到上下文环境】</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 targetSource 获取真正的代理对象</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找【适合该方法的增强】，首先从缓存中查找，查找不到进入主方法【下文详解】</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截器链是空，说明当前 method 不需要被增强</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有匹配当前 method 的方法拦截器，要做增强处理，把方法信息封装到方法调用器里</span></span><br><span class="line">            <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// 【拦截器链驱动方法，核心】</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">          <span class="comment">// 如果目标方法返回目标对象，这里做个普通替换返回代理对象</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果允许了提前暴露，这里需要设置为初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// 当前代理对象已经完成工作，【把原始对象设置回上下文】</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)：查找适合该方法的增强，首先从缓存中查找，获取通知时是从全部增强中获取适合当前类的，这里是<strong>从当前类的中获取适合当前方法的增强</strong></p><ul><li><p><code>AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance()</code>：向容器注册适配器，<strong>可以将非 Advisor 类型的增强，包装成为 Advisor，将 Advisor 类型的增强提取出来对应的 MethodInterceptor</strong></p><ul><li><p><code>instance = new DefaultAdvisorAdapterRegistry()</code>：该对象向容器中注册了 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter 三个适配器</p></li><li><p>Advisor 中持有 Advice 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advisor</span> &#123;</span><br><span class="line">Advice <span class="title function_">getAdvice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>advisors = config.getAdvisors()</code>：获取 ProxyFactory 内部持有的增强信息</p></li><li><p><code>interceptorList = new ArrayList&lt;&gt;(advisors.length)</code>：拦截器列表有 5 个，1 个 ExposeInvocation和 4 个增强器</p></li><li><p><code>actualClass = (targetClass != null ? targetClass : method.getDeclaringClass())</code>：真实的目标对象类型</p></li><li><p><code>Boolean hasIntroductions = null</code>：引介增强，不关心</p></li><li><p><code>for (Advisor advisor : advisors)</code>：<strong>遍历所有的 advisor 增强</strong></p></li><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：条件成立说明当前 Advisor 是包含切点信息的，进入匹配逻辑</p><p><code>pointcutAdvisor = (PointcutAdvisor) advisor</code>：转成可以获取到切点信息的接口</p><p><code>if(config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass))</code>：当前代理被预处理，或者当前被代理的 class 对象匹配当前 Advisor 成功，只是 class 匹配成功</p><ul><li><p><code>mm = pointcutAdvisor.getPointcut().getMethodMatcher()</code>：获取切点的方法匹配器，不考虑引介增强</p></li><li><p><code>match = mm.matches(method, actualClass)</code>：<strong>静态匹配成功返回 true，只关注于处理类及其方法，不考虑参数</strong></p></li><li><p><code>if (match)</code>：如果静态切点检查是匹配的，在运行的时候才进行<strong>动态切点检查，会考虑参数匹配</strong>（代表传入了参数）。如果静态匹配失败，直接不需要进行参数匹配，提高了工作效率</p><p><code>interceptors = registry.getInterceptors(advisor)</code>：提取出当前 advisor 内持有的 advice 信息 </p><ul><li><p><code>Advice advice = advisor.getAdvice()</code>：获取增强方法</p></li><li><p><code>if (advice instanceof MethodInterceptor)</code>：当前 advice 是 MethodInterceptor 直接加入集合</p></li><li><p><code>for (AdvisorAdapter adapter : this.adapters)</code>：<strong>遍历三个适配器进行匹配</strong>（初始化时创建的），匹配成功创建对应的拦截器返回，以 MethodBeforeAdviceAdapter 为例</p><p><code>if (adapter.supportsAdvice(advice))</code>：判断当前 advice 是否是对应的 MethodBeforeAdvice</p><p><code>interceptors.add(adapter.getInterceptor(advisor))</code>：条件成立就往拦截器链中添加 advisor</p><ul><li><code>advice = (MethodBeforeAdvice) advisor.getAdvice()</code>：<strong>获取增强方法</strong></li><li><code>return new MethodBeforeAdviceInterceptor(advice)</code>：<strong>封装成 MethodBeforeAdviceInterceptor 返回</strong></li></ul></li></ul><p><code>interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm))</code>：向拦截器链添加动态匹配器</p><p><code>interceptorList.addAll(Arrays.asList(interceptors))</code>：将当前 advisor 内部的方法拦截器追加到 interceptorList</p></li></ul></li><li><p><code>interceptors = registry.getInterceptors(advisor)</code>：进入 else 的逻辑，说明当前 Advisor 匹配全部 class 的全部 method，全部加入到 interceptorList</p></li><li><p><code>return interceptorList</code>：返回 method 方法的拦截器链</p></li></ul><p>retVal &#x3D; invocation.proceed()：<strong>拦截器链驱动方法</strong></p><ul><li><p><code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code>：条件成立说明方法拦截器全部都已经调用过了（index 从 - 1 开始累加），接下来需要执行目标对象的目标方法</p><p><code>return invokeJoinpoint()</code>：<strong>调用连接点（目标）方法</strong></p></li><li><p><code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>：<strong>获取下一个方法拦截器</strong></p></li><li><p><code>if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)</code>：需要运行时匹配</p><p><code>if (dm.methodMatcher.matches(this.method, targetClass, this.arguments))</code>：判断是否匹配成功</p><ul><li><code>return dm.interceptor.invoke(this)</code>：匹配成功，执行方法</li><li><code>return proceed()</code>：匹配失败跳过当前拦截器</li></ul></li><li><p><code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>：<strong>一般方法拦截器都会执行到该方法，此方法内继续执行 proceed() 完成责任链的驱动，直到最后一个  MethodBeforeAdviceInterceptor 调用前置通知，然后调用 mi.proceed()，发现是最后一个拦截器就直接执行连接点（目标方法），return 到上一个拦截器的 mi.proceed() 处，依次返回到责任链的上一个拦截器执行通知方法</strong></p></li></ul><p>图示先从上往下建立链，然后从下往上依次执行，责任链模式</p><ul><li><p>正常执行：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 返回通知</p></li><li><p>出现异常：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 异常通知</p></li><li><p>MethodBeforeAdviceInterceptor 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先执行通知方法，再驱动责任链</span></span><br><span class="line">    <span class="built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="comment">// 开始驱动目标方法执行，执行完后返回到这，然后继续向上层返回</span></span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AfterReturningAdviceInterceptor 源码：没有任何异常处理机制，直接抛给上层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先驱动责任链，再执行通知方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> mi.proceed();</span><br><span class="line">    <span class="built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJAfterThrowingAdvice 执行异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认直接驱动责任链</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 出现错误才执行该方法</span></span><br><span class="line">        <span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">            invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png"></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></p><hr><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><h4 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h4><h5 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>容器启动时会根据注解注册对应的解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// 注册解析器</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span>());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> <span class="title class_">JtaTransactionManagerBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取对应的解析器 NamespaceHandlerSupport#findParserForElement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanDefinitionParser <span class="title function_">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    <span class="comment">// 获取对应的解析器</span></span><br><span class="line">    <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.parsers.get(localName);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用解析器的方法对 XML 文件进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"><span class="comment">// 向Spring容器注册了一个 BD -&gt; TransactionalEventListenerFactory.class</span></span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">            registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;proxy&quot;，默认逻辑，不配置 mode 时</span></span><br><span class="line">        <span class="comment">// 用来向容器中注入一些 BeanDefinition，包括事务增强器、事务拦截器、注解解析器</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>@EnableTransactionManagement 导入 TransactionManagementConfigurationSelector，该类给 Spring 容器中两个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="comment">// 导入 AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration（默认）</span></span><br><span class="line">        <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">        <span class="comment">// 导入 AspectJTransactionManagementConfiguration（与声明式事务无关）</span></span><br><span class="line">        <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoProxyRegistrar：给容器中注册 InfrastructureAdvisorAutoProxyCreator，<strong>利用后置处理器机制拦截 bean 以后包装并返回一个代理对象</strong>，代理对象中保存所有的拦截器，利用拦截器的链式机制依次进入每一个拦截器中进行拦截执行（就是 AOP 原理）</p><p>ProxyTransactionManagementConfiguration：是一个 Spring 的事务配置类，注册了三个 Bean：</p><ul><li>BeanFactoryTransactionAttributeSourceAdvisor：事务驱动，利用注解 @Bean 把该类注入到容器中，该增强器有两个字段：</li><li>TransactionAttributeSource：解析事务注解的相关信息，真实类型是 AnnotationTransactionAttributeSource，构造方法中注册了三个<strong>注解解析器</strong>，解析 Spring、JTA、Ejb3 三种类型的事务注解</li><li>TransactionInterceptor：<strong>事务拦截器</strong>，代理对象执行拦截器方法时，调用 TransactionInterceptor 的 invoke 方法，底层调用TransactionAspectSupport.invokeWithinTransaction()，通过 PlatformTransactionManager 控制着事务的提交和回滚，所以事务的底层原理就是通过 AOP 动态织入，进行事务开启和提交</li></ul><p>注解解析器 SpringTransactionAnnotationParser <strong>解析 @Transactional 注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="type">RuleBasedTransactionAttribute</span> <span class="variable">rbta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleBasedTransactionAttribute</span>();</span><br><span class="line"><span class="comment">// 从注解信息中获取传播行为</span></span><br><span class="line">    <span class="type">Propagation</span> <span class="variable">propagation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">    rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">    <span class="comment">// 获取隔离界别</span></span><br><span class="line">    <span class="type">Isolation</span> <span class="variable">isolation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">    rbta.setIsolationLevel(isolation.value());</span><br><span class="line">    rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">    <span class="comment">// 从注解信息中获取 readOnly 参数</span></span><br><span class="line">    rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">    <span class="comment">// 从注解信息中获取 value 信息并且设置 qualifier，表示当前事务指定使用的【事务管理器】</span></span><br><span class="line">    rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">// 【存放的是 rollback 条件】，回滚规则放在这个集合</span></span><br><span class="line">    List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示事务碰到哪些指定的异常才进行回滚，不指定的话默认是 RuntimeException/Error 非检查型异常菜回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与 rollbackFor 功能相同</span></span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示事务碰到指定的 exception 实现对象不进行回滚，否则碰到其他的class就进行回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置回滚规则</span></span><br><span class="line">    rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="驱动方法"><a href="#驱动方法" class="headerlink" title="驱动方法"></a>驱动方法</h4><p>TransactionInterceptor 事务拦截器的核心驱动方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// targetClass 是需要被事务增强器增强的目标类，invocation.getThis() → 目标对象 → 目标类</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 参数一是目标方法，参数二是目标类，参数三是方法引用，用来触发驱动方法</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务属性源信息</span></span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">//  提取 @Transactional 注解信息，txAttr 是注解信息的承载对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 获取 Spring 配置的事务管理器</span></span><br><span class="line">    <span class="comment">// 首先会检查是否通过XML或注解配置 qualifier，没有就尝试去容器获取，一般情况下为 DatasourceTransactionManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="comment">// 权限定类名.方法名，该值用来当做事务名称使用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 条件成立说明是【声明式事务】</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">    <span class="comment">// 用来【开启事务】</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an 【around advice】: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// 环绕通知，执行目标方法（方法引用方式，invocation::proceed，还是调用 proceed）</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//  执行业务代码时抛出异常，执行回滚逻辑</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理事务的信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务的入口</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 编程式事务，省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><h5 id="事务绑定"><a href="#事务绑定" class="headerlink" title="事务绑定"></a>事务绑定</h5><p>创建事务的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">                                                       <span class="meta">@Nullable</span> TransactionAttribute txAttr, </span></span><br><span class="line"><span class="params">                                                       <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务的名称： 类的权限定名.方法名</span></span><br><span class="line">        txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过事务管理器根据事务属性创建事务状态对象，事务状态对象一般情况下包装着 事务对象，当然也有可能是null</span></span><br><span class="line">            <span class="comment">// 方法上的注解为 @Transactional(propagation = NOT_SUPPORTED || propagation = NEVER) 时</span></span><br><span class="line">            <span class="comment">// 【下一小节详解】</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">                             <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 包装成一个上层的事务上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionAspectSupport#prepareTransactionInfo：为事务的属性和状态准备一个事务信息对象</p><ul><li><code>TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification)</code>：创建事务信息对象</li><li><code>txInfo.newTransactionStatus(status)</code>：填充事务的状态信息</li><li><code>txInfo.bindToThread()</code>：利用 ThreadLocal <strong>把当前事务信息绑定到当前线程</strong>，不同的事务信息会形成一个栈的结构<ul><li><code>this.oldTransactionInfo = transactionInfoHolder.get()</code>：获取其他事务的信息存入 oldTransactionInfo </li><li><code>transactionInfoHolder.set(this)</code>：将当前的事务信息设置到 ThreadLocalMap 中</li></ul></li></ul><hr><h5 id="事务创建"><a href="#事务创建" class="headerlink" title="事务创建"></a>事务创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 获取事务的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">        definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 条件成立说明当前是事务重入的情况，事务中有 ConnectionHolder 对象</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// a方法开启事务，a方法内调用b方法，b方法仍然加了 @Transactional 注解，需要检查传播行为</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 逻辑到这说明当前线程没有连接资源，一个连接对应一个事务，没有连接就相当于没有开启事务</span></span><br><span class="line">    <span class="comment">// 检查事务的延迟属性</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传播行为是 MANDATORY，没有事务就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要开启事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 什么也没挂起，因为线程并没有绑定事务</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否支持同步线程事务，一般是 true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 新建一个事务状态信息</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 【启动事务】</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 设置线程上下文变量，方便程序运行期间获取当前事务的一些核心的属性，initSynchronization() 启动同步</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不支持事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建事务状态对象</span></span><br><span class="line">        <span class="comment">// 参数2 transaction 是 null 说明当前事务状态是未手动开启事，线程上未绑定任何的连接资源，业务程序执行时需要先去 datasource 获取的 conn，是自动提交事务的，不需要 Spring 再提交事务</span></span><br><span class="line">        <span class="comment">// 参数6 suspendedResources 是 null 说明当前事务状态未挂起任何事务，当前事务执行到后置处理时不需要恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceTransactionManager#doGetTransaction：真正获取事务的方法</p><ul><li><p><code>DataSourceTransactionObject txObject = new DataSourceTransactionObject()</code>：<strong>创建事务对象</strong></p></li><li><p><code>txObject.setSavepointAllowed(isNestedAllowed())</code>：设置事务对象是否支持保存点，由事务管理器控制（默认不支持）</p></li><li><p><code>ConnectionHolder conHolder = TransactionSynchronizationManager.getResource(obtainDataSource())</code>：</p><ul><li><p>从 ThreadLocal 中获取 conHolder 资源，可能拿到 null 或者不是 null</p></li><li><p>是 null：举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;...b.b()....&#125;</span><br></pre></td></tr></table></figure></li><li><p>不是 null：执行 b 方法事务增强的前置逻辑时，可以拿到 a 放进去的 conHolder 资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;....&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>txObject.setConnectionHolder(conHolder, false)</code>：将 ConnectionHolder 保存到事务对象内，参数二是 false 代表连接资源是上层事务共享的，不是新建的连接资源</p></li><li><p><code>return txObject</code>：返回事务的对象</p></li></ul><p>DataSourceTransactionManager#doBegin：事务开启的逻辑</p><ul><li><p><code>txObject = (DataSourceTransactionObject) transaction</code>：强转为事务对象</p></li><li><p>事务中没有数据库连接资源就要分配：</p><p><code>Connection newCon = obtainDataSource().getConnection()</code>：<strong>获取 JDBC 原生的数据库连接对象</strong></p><p><code>txObject.setConnectionHolder(new ConnectionHolder(newCon), true)</code>：代表是新开启的事务，新建的连接对象</p></li><li><p><code>previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)</code>：修改连接属性</p><ul><li><p><code>if (definition != null &amp;&amp; definition.isReadOnly())</code>：注解（或 XML）配置了只读属性，需要设置</p></li><li><p><code>if (..definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT)</code>：注解配置了隔离级别</p><p><code>int currentIsolation = con.getTransactionIsolation()</code>：获取连接的隔离界别</p><p><code>previousIsolationLevel = currentIsolation</code>：保存之前的隔离界别，返回该值</p><p><code> con.setTransactionIsolation(definition.getIsolationLevel())</code>：<strong>将当前连接设置为配置的隔离界别</strong></p></li></ul></li><li><p><code>txObject.setPreviousIsolationLevel(previousIsolationLevel)</code>：将 Conn 原来的隔离级别保存到事务对象，为了释放 Conn 时重置回原状态</p></li><li><p><code>if (con.getAutoCommit())</code>：默认会成立，说明还没开启事务</p><p><code>txObject.setMustRestoreAutoCommit(true)</code>：保存 Conn 原来的事务状态</p><p><code>con.setAutoCommit(false)</code>：<strong>开启事务，JDBC 原生的方式</strong></p></li><li><p><code>txObject.getConnectionHolder().setTransactionActive(true)</code>：表示 Holder 持有的 Conn 已经手动开启事务了</p></li><li><p><code>TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())</code>：将 ConnectionHolder 对象绑定到 ThreadLocal 内，数据源为 key，为了方便获取手动开启事务的连接对象去执行 SQL</p></li></ul><hr><h5 id="事务重入"><a href="#事务重入" class="headerlink" title="事务重入"></a>事务重入</h5><p>事务重入的核心处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">handleExistingTransaction</span><span class="params">( TransactionDefinition definition, </span></span><br><span class="line"><span class="params">                                                    Object transaction, <span class="type">boolean</span> debugEnabled)</span>&#123;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NEVER，需要以非事务方式执行操作，如果当前事务存在则【抛出异常】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NOT_SUPPORTED，以非事务方式运行，如果当前存在事务，则【把当前事务挂起】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="comment">// 挂起事务</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建一个非事务的事务状态对象返回</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 开启新事物的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="comment">// 【挂起当前事务】</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">       <span class="comment">// 【开启新事物】</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传播行为是 PROPAGATION_NESTED，嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// Spring 默认不支持内嵌事务</span></span><br><span class="line">        <span class="comment">// 【开启方式】：&lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot;&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedTransactionNotSupportedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">            <span class="comment">//  为当前方法创建一个 TransactionStatus 对象，</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span></span><br><span class="line">                prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, <span class="literal">false</span>, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 创建一个 JDBC 的保存点</span></span><br><span class="line">            status.createAndHoldSavepoint();</span><br><span class="line">            <span class="comment">// 不需要使用同步，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Usually only for JTA transaction，开启一个新事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED，【使用当前的事务】</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="挂起恢复"><a href="#挂起恢复" class="headerlink" title="挂起恢复"></a>挂起恢复</h5><p>AbstractPlatformTransactionManager#suspend：<strong>挂起事务</strong>，并获得一个上下文信息对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title function_">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务是同步状态的</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (transaction != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// do it</span></span><br><span class="line">                suspendedResources = doSuspend(transaction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将上层事务绑定在线程上下文的变量全部取出来</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 通过被挂起的资源和上层事务的上下文变量，创建一个【SuspendedResourcesHolder】返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuspendedResourcesHolder</span>(suspendedResources, suspendedSynchronizations, </span><br><span class="line">                                                name, readOnly, isolationLevel, wasActive);</span><br><span class="line">        &#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doSuspend</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="comment">// 将当前方法的事务对象 connectionHolder 属性置为 null，不和上层共享资源</span></span><br><span class="line">    <span class="comment">// 当前方法有可能是不开启事务或者要开启一个独立的事务</span></span><br><span class="line">    txObject.setConnectionHolder(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 【解绑在线程上的事务】</span></span><br><span class="line">    <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#resume：<strong>恢复现场</strong>，根据挂起资源去恢复线程上下文信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">(Object transaction, SuspendedResourcesHolder resourcesHolder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resourcesHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取被挂起的事务资源</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> resourcesHolder.suspendedResources;</span><br><span class="line">        <span class="keyword">if</span> (suspendedResources != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//绑定上一个事务的 ConnectionHolder 到线程上下文</span></span><br><span class="line">            doResume(transaction, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">        <span class="keyword">if</span> (suspendedSynchronizations != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            <span class="comment">// 将线程上下文变量恢复为上一个事务的挂起现场</span></span><br><span class="line">            doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doResume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, Object suspendedResources)</span> &#123;</span><br><span class="line">    <span class="comment">// doSuspend 的逆动作，【绑定资源】</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="提交回滚"><a href="#提交回滚" class="headerlink" title="提交回滚"></a>提交回滚</h4><h5 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务状态信息不为空进入逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 条件二成立 说明目标方法抛出的异常需要回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 事务管理器的回滚方法</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到这里，说明当前事务虽然抛出了异常，但是该异常并不会导致整个事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 继承自 RuntimeException 或 error 的是【非检查型异常】，才会归滚事务</span></span><br><span class="line">    <span class="comment">// 如果配置了其他回滚错误，会获取到回滚规则 rollbackRules 进行判断</span></span><br><span class="line">    <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 事务已经完成不需要回滚</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 开始回滚事务</span></span><br><span class="line">    processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#processRollback：事务回滚</p><ul><li><p><code>triggerBeforeCompletion(status)</code>：用来做扩展逻辑，回滚前的前置处理</p></li><li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，当前方法只是复用了上层事务的一个内嵌事务</p><p><code>status.rollbackToHeldSavepoint()</code>：内嵌事务加入事务时会创建一个保存点，此时恢复至保存点</p></li><li><p><code>if (status.isNewTransaction())</code>：说明事务是当前连接开启的，需要去回滚事务</p><p><code>doRollback(status)</code>：真正的的回滚函数</p><ul><li><code>DataSourceTransactionObject txObject = status.getTransaction()</code>：获取事务对象</li><li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li><li><code>con.rollback()</code>：<strong>JDBC 的方式回滚事务</strong></li></ul></li><li><p><code>else</code>：当前方法是共享的上层的事务，和上层使用同一个 Conn 资源，<strong>共享的事务不能直接回滚，应该交给上层处理</strong></p><p><code>doSetRollbackOnly(status)</code>：设置 con.rollbackOnly &#x3D; true，线程回到上层事务 commit 时会检查该字段，然后执行回滚操作</p></li><li><p><code>triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)</code>：回滚的后置处理</p></li><li><p><code>cleanupAfterCompletion(status)</code>：清理和恢复现场</p></li></ul><hr><h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务管理器的提交方法</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 已经完成的事务不需要提交了</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 条件成立说明是当前的业务强制回滚</span></span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 回滚逻辑，</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 成立说明共享当前事务的【下层事务逻辑出错，需要回滚】</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前事务还是事务重入，会继续抛给上层，最上层事务会进行真实的事务回滚操作</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行提交</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#processCommit：事务提交</p><ul><li><p><code>prepareForCommit(status)</code>：前置处理</p></li><li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，只是复用了上层事务</p><p><code>status.releaseHeldSavepoint()</code>：清理保存点，因为没有发生任何异常，所以保存点没有存在的意义了</p></li><li><p><code>if (status.isNewTransaction())</code>：说明事务是归属于当前连接的，需要去提交事务</p><p><code>doCommit(status)</code>：真正的提交函数</p><ul><li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li><li><code>con.commit()</code>：<strong>JDBC 的方式提交事务</strong></li></ul></li><li><p><code>doRollbackOnCommitException(status, ex)</code>：<strong>提交事务出错后进行回滚</strong></p></li><li><p><code> cleanupAfterCompletion(status)</code>：清理和恢复现场</p></li></ul><hr><h5 id="清理现场"><a href="#清理现场" class="headerlink" title="清理现场"></a>清理现场</h5><p>恢复上层事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cleanupTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的 ThreadLocal 获取上层的事务信息，将当前事务出栈，继续执行上层事务</span></span><br><span class="line">        txInfo.restoreThreadLocalStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restoreThreadLocalStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">    transactionInfoHolder.set(<span class="built_in">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前层级事务结束时的清理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前方法的事务状态为完成状态</span></span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        <span class="comment">// 清理线程上下文变量以及扩展点注册的 sync</span></span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事务是当前线程开启的</span></span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="comment">// 解绑资源</span></span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件成立说明当前事务执行的时候，【挂起了一个上层的事务】</span></span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> (status.hasTransaction() ? status.getTransaction() : <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 恢复上层事务现场</span></span><br><span class="line">        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceTransactionManager#doCleanupAfterCompletion：清理工作</p><ul><li><p><code>TransactionSynchronizationManager.unbindResource(obtainDataSource())</code>：解绑数据库资源</p></li><li><p><code>if (txObject.isMustRestoreAutoCommit())</code>：是否恢复连接，Conn 归还到 DataSource<strong>，归还前需要恢复到申请时的状态</strong></p><p><code>con.setAutoCommit(true)</code>：恢复连接为自动提交</p></li><li><p><code>DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel())</code>：恢复隔离级别</p></li><li><p><code>DataSourceUtils.releaseConnection(con, this.dataSource)</code>：<strong>将连接归还给数据库连接池</strong></p></li><li><p><code>txObject.getConnectionHolder().clear()</code>：清理 ConnectionHolder 资源</p></li></ul><hr><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>@Component 解析流程：</p><ul><li><p>注解类启动容器的时，注册 ClassPathBeanDefinitionScanner 到容器，用来扫描 Bean 的相关信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历指定的所有的包，【这就相当于扫描了】</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 读取当前包下的资源装换为 BeanDefinition，字节流的方式</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">// 遍历，封装，类似于 XML 的解析方式，注册到容器中</span></span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern</code> ：将 package 转化为 ClassLoader 类资源搜索路径 packageSearchPath，例如：<code>com.sea.spring.boot</code> 转化为 <code>classpath*:com/sea/spring/boot/**/*.class</code></p></li><li><p><code>resources = getResourcePatternResolver().getResources(packageSearchPath)</code>：加载路径下的资源</p></li><li><p><code>for (Resource resource : resources) </code>：遍历所有的资源</p><p><code>metadataReader = getMetadataReaderFactory().getMetadataReader(resource)</code>：获取元数据阅读器</p><p><code>if (isCandidateComponent(metadataReader))</code>：<strong>当前类不匹配任何排除过滤器，并且匹配一个包含过滤器</strong>，返回 true</p><ul><li><p>includeFilters 由 <code>registerDefaultFilters()</code> 设置初始值，方法有 @Component，没有 @Service，因为 @Component 是 @Service 的元注解，Spring 在读取 @Service 时也读取了元注解，并将 @Service 作为 @Component 处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class))</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// 拥有了 Component 功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>candidates.add(sbd)</code>：添加到返回结果的 list</p></li></ul></li></ul><p>参考文章：<a href="https://my.oschina.net/floor/blog/4325651">https://my.oschina.net/floor/blog/4325651</a></p><hr><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h4><p>打开 @Autowired 源码，注释上写 Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor</p><p>AutowiredAnnotationBeanPostProcessor 间接实现 InstantiationAwareBeanPostProcessor，就具备了实例化前后（而不是初始化前后）管理对象的能力，实现了 BeanPostProcessor，具有初始化前后管理对象的能力，实现 BeanFactoryAware，具备随时拿到 BeanFactory 的能力，所以这个类<strong>具备一切后置处理器的能力</strong></p><p><strong>在容器启动，为对象赋值的时候，遇到 @Autowired 注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是 Autowired 的原理</strong></p><p>作用时机：</p><ul><li>Spring 在每个 Bean 实例化之后，调用 AutowiredAnnotationBeanPostProcessor 的 <code>postProcessMergedBeanDefinition()</code> 方法，查找该 Bean 是否有 @Autowired 注解，进行相关元数据的获取</li><li>Spring 在每个 Bean 调用 <code>populateBean()</code> 进行属性注入的时候，即调用 <code>postProcessProperties()</code> 方法，查找该 Bean 属性是否有 @Autowired 注解，进行相关数据的填充</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Spring全家桶" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="SSM框架" scheme="http://example.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SSM%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring全家桶" scheme="http://example.com/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="JavaWeb" scheme="http://example.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="http://example.com/2022/08/16/JavaSE/"/>
    <id>http://example.com/2022/08/16/JavaSE/</id>
    <published>2022-08-16T15:00:43.275Z</published>
    <updated>2022-08-17T12:19:21.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table><thead><tr><th align="center"></th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中，方法外</td><td align="center">方法中或者方法的形参</td><td align="center">在类中，方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无，赋值后才能使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方法</td><td align="center">对象调用</td><td align="center"></td><td align="center">对象调用，类名调用</td></tr><tr><td align="center">存储位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区（JDK8 以后移到堆中）</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center"></td><td align="center">类变量，静态成员变量</td></tr></tbody></table><p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p><p>初学时笔记内容参考视频：<a href="https://www.bilibili.com/video/BV1TE41177mP%EF%BC%8C%E9%9A%8F%E7%9D%80%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B7%B1%E5%85%A5%E5%8F%88%E5%A2%9E%E5%8A%A0%E5%BE%88%E5%A4%9A%E7%9F%A5%E8%AF%86">https://www.bilibili.com/video/BV1TE41177mP，随着学习的深入又增加很多知识</a></p><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li><li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li><li>默认值是 <code>0</code></li><li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li><li>例子：<code>byte a = 100，byte b = -50</code></li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li><li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li><li>默认值是 <code>0</code></li><li>例子：<code>short s = 1000，short r = -20000</code></li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li><li>一般地整型变量默认为 int 类型</li><li>默认值是 <code>0</code></li><li>例子：<code>int a = 100000, int b = -200000</code></li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li><li>这种类型主要使用在需要比较大整数的系统上</li><li>默认值是 <code> 0L</code></li><li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li><li>float 在储存大型浮点数组的时候可节省内存空间</li><li>默认值是 <code>0.0f</code></li><li>浮点数不能用来表示精确的值，如货币</li><li>例子：<code>float f1 = 234.5F</code></li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li><li>浮点数的默认类型为 double 类型</li><li>double 类型同样不能表示精确的值，如货币</li><li>默认值是 <code>0.0d</code></li><li>例子：<code>double d1 = 123.4</code></li></ul><p><strong>boolean：</strong></p><ul><li>boolean 数据类型表示一位的信息</li><li>只有两个取值：true 和 false</li><li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li><li>默认值是 <code>false</code></li><li>例子：<code>boolean one = true</code></li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li><li>最小值是 <code>\u0000</code>（即为 0）</li><li>最大值是 <code>\uffff</code>（即为 65535）</li><li>char 数据类型可以<strong>存储任何字符</strong></li><li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li></ul><hr><h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul><li><p>float 与 double：</p><p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//1.1f 字面量才是 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> (<span class="type">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1245</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (<span class="type">int</span>) l2;</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换：</p><p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p><p>使用 +&#x3D; 或者 ++ 运算符会执行类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;<span class="comment">//s1++;</span></span><br><span class="line"><span class="comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span></span><br><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p><p>包装类的作用：</p><ul><li>包装类作为类首先拥有了 Object 类的方法</li><li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）</span><br><span class="line"><span class="type">byte</span>                      Byte</span><br><span class="line"><span class="type">short</span>                     Short</span><br><span class="line"><span class="type">int</span>                       Integer</span><br><span class="line"><span class="type">long</span>                      Long</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>                     Float</span><br><span class="line"><span class="type">double</span>                    Double</span><br><span class="line"><span class="type">char</span>                      Character</span><br><span class="line"><span class="type">boolean</span>                   Boolean</span><br></pre></td></tr></table></figure><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p><ul><li><p>可以把基本数据类型的值转换成字符串类型的值</p><ol><li>调用 toString() 方法</li><li>调用 Integer.toString(基本数据类型的值) 得到字符串</li><li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li></ol></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p><ol><li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li><li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClass02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.把基本数据类型的值转成字符串</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="comment">// a.调用toString()方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr</span> <span class="operator">=</span> it.toString();</span><br><span class="line">        System.out.println(itStr+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr1</span> <span class="operator">=</span> Integer.toString(it);</span><br><span class="line">        System.out.println(itStr1+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr2</span> <span class="operator">=</span> it + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(itStr2+<span class="number">1</span>);<span class="comment">// 1001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.valueOf(numStr);</span><br><span class="line">        System.out.println(numInt+<span class="number">1</span>);<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">doubleStr</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleDb</span> <span class="operator">=</span> Double.valueOf(doubleStr);</span><br><span class="line">        System.out.println(doubleDb+<span class="number">0.1</span>);<span class="comment">//100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul><li><p>有了基本数据类型，为什么还要引用数据类型？</p><blockquote><p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p><p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p></blockquote></li><li><p>引用数据类型那么好，为什么还用基本数据类型？</p><blockquote><p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p></blockquote></li><li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p><blockquote><p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p></blockquote></li><li><p>&#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值<br>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</p></blockquote></li></ul><hr><h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p><p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackegeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">12</span> ;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> a ;   <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 引用数据类型的默认值可以为null</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c ;      <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(<span class="number">12</span>);  <span class="comment">// 手工装箱！</span></span><br><span class="line">        <span class="comment">// Integer it1 = new Integer(12); // 手工装箱！</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="number">111</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it33</span> <span class="operator">=</span> it3.intValue(); <span class="comment">// 手工拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 【缓存池】，本质上是一个数组</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li><p>new Integer(123)：每次都会新建一个对象</p></li><li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><p><strong>基本类型对应的缓存池如下：</strong></p><ul><li>Boolean values true and false</li><li>all byte values</li><li>Short values between -128 and 127</li><li>Long values between -128 and 127</li><li>Integer values between -128 and 127</li><li>Character in the range \u0000 to \u007F (0 and 127)</li></ul><p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 自动装箱，底层调用 Integer.valueOf(1)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// false，因为缓存池最大127</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure><hr><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p><ul><li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li><li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li></ul><p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p><ul><li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li><li>print：<code>PrintStream.write()</code></li></ul><blockquote><p>使用引用数据类型的API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p><p>创建数组：</p><ul><li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li><li>数据类型 数组名[]：<code>int arr[]</code></li></ul><p>静态初始化：</p><ul><li><code>数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;</code>：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li><li><code>数据类型[] 数组名 = &#123;元素1,元素2,...&#125;</code>：<code>int[] arr = &#123;44,55,66&#125;</code></li></ul><p>动态初始化</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li></ul><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul><li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p></li><li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p></li><li><p><strong>赋值：</strong><code>arr[0] = 10</code></p></li></ul><hr><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给 CPU 使用</td></tr><tr><td>本地方法栈</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区</td><td>存储可以运行的 class 文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new 来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td></tr></tbody></table><p><strong>内存分配图</strong>：Java 内存分配</p><ul><li><p>一个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>两个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>多个数组指向相同内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li></ul><hr><h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4><ul><li><p>索引越界异常：ArrayIndexOutOfBoundsException </p></li><li><p>空指针异常：NullPointerException </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p><p>解决方案：给数组一个真正的堆内存空间引用即可</p></li></ul><hr><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p><p>初始化：</p><ul><li><p>动态初始化：数据类型[][] 变量名 &#x3D; new 数据类型[m] [n]，<code>int[][] arr = new int[3][3]</code></p><ul><li>m 表示这个二维数组，可以存放多少个一维数组，行</li><li>n 表示每一个一维数组，可以存放多少个元素，列</li></ul></li><li><p>静态初始化</p><ul><li><code>数据类型[][] 变量名 = new 数据类型 [][]&#123;&#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; `  * `数据类型[][] 变量名 = &#123;&#123;元素1, 元素2...&#125;, &#123;元素1, 元素2...&#125;...&#125;`  * `int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li></ul></li></ul><p>遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        步骤:</span></span><br><span class="line"><span class="comment">            1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line"><span class="comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(arr[i]);</span></span><br><span class="line">            <span class="comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line">            <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>i++ 与 ++i 的区别？</p><p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p></li><li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p><p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p><p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p></li><li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p></li><li><p>同或：两位相同为 1，相异为 0</p></li><li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p></li><li><p>break：跳出一层循环</p></li><li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p><ul><li><p>正数的原码反码补码相同，最高位为 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure></li><li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">100</span> 原码:<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span><span class="comment">//32位</span></span><br><span class="line">-<span class="number">100</span> 反码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011011</span></span><br><span class="line">-<span class="number">100</span> 补码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011100</span></span><br></pre></td></tr></table></figure><p>补码 → 原码：符号位不变，其余位置取反加 1</p></li></ul><p>运算符：</p><ul><li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li><li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li><li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li></ul><p>运算规则：</p><ul><li><p>正数的左移与右移，空位补 0</p></li><li><p>负数原码的左移与右移，空位补 0</p><p>负数反码的左移与右移，空位补 1</p><p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p></li><li><p>无符号移位，空位补 0</p></li></ul></li></ul><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p><ul><li>形式参数，用于定义方法的时候使用的参数，只能是变量</li><li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li></ul><p>实参：调用方法时传递的数据可以是常量，也可以是变量</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p><p>格式：数据类型… 参数名称</p><p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p><p>可变参数的注意事项：</p><ul><li>一个形参列表中可变参数只能有一个</li><li>可变参数必须放在形参列表的<strong>最后面</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">sum(); <span class="comment">// 可以不传输参数。</span></span><br><span class="line">sum(<span class="number">10</span>); <span class="comment">// 可以传输一个参数。</span></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 可以传输多个参数。</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">90</span>&#125;); <span class="comment">// 可以传输一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p><p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p><p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p><hr><h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line"><span class="comment">//方法体;</span></span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 (参数) ;</span><br></pre></td></tr></table></figure><ul><li>方法名：调用方法时候使用的标识</li><li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li><li>方法体：完成功能的代码块</li><li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li></ul><p>如果方法操作完毕</p><ul><li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li><li>非 void 类型的方法，推荐用变量接收调用</li></ul><p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>方法不能嵌套定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p><ol><li>多个方法在<strong>同一个类</strong>中</li><li>多个方法具有<strong>相同的方法名</strong></li><li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li></ol><p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p><p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p><p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">/*正确格式*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ul><li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li><li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li><li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li></ul><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法，选取的第二阶段</span></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span></span><br><span class="line">    </span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span></span><br><span class="line">       <span class="comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此不提倡可变长参数方法的重载</p><hr><h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p><ul><li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li><li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li></ul><hr><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p><p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p><ul><li><p>基本数据类型：形式参数的改变，不影响实际参数</p><p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">change(number);</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">number = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型：形式参数的改变，影响实际参数的值</p><p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p><p>定义枚举的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">第一行都是罗列枚举实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的特点：</p><ul><li>枚举类是用 final 修饰的，枚举类不能被继承</li><li>枚举类默认继承了 java.lang.Enum 枚举类</li><li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li><li>枚举类相当于是多例设计模式</li><li>每个枚举项都是一个实例，是一个静态成员变量</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E  o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <T> T  valueOf(Class<T> type,String  name)</td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类的编译以后源代码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Season&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season[] values();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>API 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        <span class="type">Season</span> <span class="variable">s</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(s);<span class="comment">//SPRING</span></span><br><span class="line">        System.out.println(s.ordinal()); <span class="comment">// 0，该值代表索引，summer 就是 1</span></span><br><span class="line">        s.s.doSomething();</span><br><span class="line">        <span class="comment">// 获取全部枚举</span></span><br><span class="line">        Season[] ss = Season.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Season.SPRING.compareTo(Season.WINTER);</span><br><span class="line">        System.out.println(result);<span class="comment">//-3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug条件断点.png" alt="Debug条件断点" style="zoom:50%;" /><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p><p>面向对象三大特征：<strong>封装，继承，多态</strong></p><p>两个概念：类和对象</p><ul><li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li><li>对象：是真实存在的实例， 实例 &#x3D;&#x3D; 对象，<strong>对象是类的实例化</strong></li><li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li></ul><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li><li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li><li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分</span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line"><span class="number">1.</span>成员变量(Field):  描述类或者对象的属性信息的。</span><br><span class="line">        <span class="number">2.</span>成员方法(Method):描述类或者对象的行为信息的。</span><br><span class="line"><span class="number">3.</span>构造器(Constructor): 初始化一个对象返回。</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">  &#125;</span><br><span class="line">类中有且仅有这五种成分，否则代码报错！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：初始化类的一个对象返回</p><p>分类：无参数构造器，有参数构造器</p><p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p><p>构造器初始化对象的格式：类名 对象名称 &#x3D; new 构造器</p><ul><li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li><li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li></ul><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p><p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p><p>导包格式：<code>import 包名.类名</code></p><p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p><hr><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p><p>封装最初的目的：提高代码的安全性和复用性，组件化</p><p>封装的步骤：</p><ol><li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li><li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li></ol><p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p><ul><li>this 关键字代表了当前对象的引用</li><li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li><li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li><li>this 可以区分变量是访问的成员变量还是局部变量</li></ul><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p><p>按照有无 static 修饰，成员变量和方法可以分为：</p><ul><li><p>成员变量：</p><ul><li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li><li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li></ul></li><li><p>成员方法：</p><ul><li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li><li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li></ul></li></ul><hr><h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p><ul><li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p><ul><li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li><li>对象.静态成员变量（不推荐）</li></ul></li><li><p>实例成员变量：</p><ul><li>对象.实例成员变量（先创建对象）</li></ul></li></ul><p>成员方法的访问语法：</p><ul><li><p>静态方法：有 static 修饰，属于类</p><ul><li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li><li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li></ul></li><li><p>实例方法：无 static 修饰，属于对象</p><ul><li>对象.实例方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// a.类名.静态方法</span></span><br><span class="line">        Student.inAddr();</span><br><span class="line">        inAddr();</span><br><span class="line">        <span class="comment">// b.对象.实例方法</span></span><br><span class="line">        <span class="comment">// Student.eat(); // 报错了！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        sea.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p>内存问题：</p><ul><li><p>栈内存存放 main 方法和地址</p></li><li><p>堆内存存放对象和变量</p></li><li><p>方法区存放 class 和静态变量（jdk8 以后移入堆）</p></li></ul><p>访问问题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li><li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li><li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li><li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li><li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li><li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li></ul><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p><ul><li>被继承的类称为：父类&#x2F;超类</li><li>继承父类的类称为：子类</li></ul><p>继承的作用：</p><ul><li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li><li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li><li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li></ul><p>继承的特点：</p><ol><li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li><li><strong>单继承</strong>：一个类只能继承一个直接父类</li><li>多层继承：一个类可以间接继承多个父类（家谱）</li><li>一个类可以有多个子类</li><li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li></ol><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类不能继承父类的东西：</p><ul><li>子类不能继承父类的构造器，子类有自己的构造器</li><li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li><li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// c.run();</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        System.out.println(Cat.schoolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span><span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p><p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wmain</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();w</span><br><span class="line">        w.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类狼&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部name</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类对象的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的</span></span><br><span class="line">        System.out.println(name1); <span class="comment">// 父类的</span></span><br><span class="line">        <span class="comment">//System.out.println(name2); // 报错。子类父类都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类动物名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;父类&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p><p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p><p>方法重写的校验注解：@Override</p><ul><li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li><li>@Override 优势：可读性好，安全，优雅</li></ul><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul><p>继承中的隐藏问题：</p><ul><li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li><li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        w.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>为什么子类构造器会先调用父类构造器？</p><ol><li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li><li>参考 JVM → 类加载 → 对象创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的有参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么 Java 是单继承的？</strong></p><p>答：反证法，假如 Java 可以多继承，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> , B &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.test(); </span><br><span class="line">        <span class="comment">// 出现了类的二义性！所以Java不能多继承！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p><p>总结与拓展：</p><ul><li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li><li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li></ul><p>注意：</p><ul><li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li><li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li><li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;天蓬元帅&quot;</span>, <span class="number">1000</span> );</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;齐天大圣&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;清华大学&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Study</span> <span class="keyword">extends</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Study</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age , schoolName) ; </span><br><span class="line">       <span class="comment">// 根据参数匹配调用父类构造器</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String schoolName ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 借用兄弟构造器的功能！</span></span><br><span class="line">        <span class="built_in">this</span>(name , age , <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......get + set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p><ul><li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li><li>final 可以修饰方法，方法就不能被重写</li><li>final 修饰变量总规则：变量有且仅能被赋值一次</li></ul><p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p><hr><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p><p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p><p>final 修饰静态成员变量可以在哪些地方赋值：</p><ol><li><p>定义的时候赋值一次</p></li><li><p>可以在静态代码块中赋值一次</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line"><span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span></span><br><span class="line">        SCHOOL_NAME1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p><p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p><ol><li>定义的时候赋值一次</li><li>可以在实例代码块中赋值一次</li><li>可以在每个构造器中赋值一次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在实例代码块中赋值一次。</span></span><br><span class="line">        name1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造器赋值一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalDemo</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalDemo</span>();</span><br><span class="line">        <span class="comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p></blockquote><p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p><p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p><p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;🐕跑&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p><ul><li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li><li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li></ul><blockquote><p>抽象在学术上本身意味着不能实例化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！</span></span><br><span class="line">        <span class="comment">//a.run(); // 抽象方法不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、static 与 abstract 能同时使用吗？</p><p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p><hr><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p><p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作文模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoMa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaoMa.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeText</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;\t内容&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.写一个模板类：代表了作文模板。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;\t\t\t\t\t标题&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;\t开头&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;\t结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(title+<span class="string">&quot;\n&quot;</span>+start);</span><br><span class="line">        System.out.println(writeText());</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正文部分定义成抽象方法，交给子类重写！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">writeText</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p><p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 interface 接口名称&#123;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p></li><li><p>静态方法：静态方法必须有方法体</p></li><li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//默认补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p><ul><li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li><li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li><li>接口与接口继承关系：<strong>多继承</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 实现类名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">修饰符 interface 接口名 extend 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多个接口的使用注意事项：</p><ol><li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p></li><li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p></li><li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p></li><li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.run();</span><br><span class="line">        s.rule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Food</span>, Person&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以直接 interface Person extend Food,</span></span><br><span class="line"><span class="comment">//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p><ul><li>默认方法（就是普通实例方法）<ul><li>必须用 default 修饰，默认会 public 修饰</li><li>必须用接口的实现类的对象来调用</li><li>必须有默认实现</li></ul></li><li>静态方法<ul><li>默认会 public 修饰</li><li>接口的静态方法必须用接口的类名本身来调用</li><li>调用格式：ClassName.method()</li><li>必须有默认实现</li></ul></li><li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        m.run();</span><br><span class="line">        m.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span></span><br><span class="line">        InterfaceJDK8.inAddr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法！！</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// a.默认方法（就是之前写的普通实例方法）</span></span><br><span class="line">    <span class="comment">// 必须用接口的实现类的对象来调用。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始跑步🏃‍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.静态方法</span></span><br><span class="line">    <span class="comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们在武汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span></span><br><span class="line">    <span class="comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>默认的方法实现</td><td>可以有默认的方法实现</td><td>接口完全是抽象的，jdk8 以后有默认的实现</td></tr><tr><td>实现</td><td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常Java类的区别</td><td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td><td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td></tr><tr><td>main方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口可以继承一个或多个其它接口，接口不可继承类</td></tr><tr><td>速度</td><td>比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td></tr><tr><td>添加新方法</td><td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td><td>如果往接口中添加方法，那么必须改变实现该接口的类</td></tr></tbody></table><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p><p>多态的格式：</p><ul><li>父类类型范围 &gt; 子类类型范围</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p>多态的执行：</p><ul><li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li><li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li></ul><p>多态的使用规则：</p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>存在方法重写</li></ul><p>多态的优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li><li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li></ul><p>多态的劣势： </p><ul><li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.run();</span><br><span class="line">        <span class="comment">//c.eat();//报错  编译看左边 需要强转</span></span><br><span class="line">        go(c);</span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Dog</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal d)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote><p>基本数据类型的转换：</p><ol><li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li><li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li></ol></blockquote><p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p><p><strong>父类引用指向子类对象</strong></p><ul><li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li><li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;<span class="comment">// 向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p><ul><li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li><li>强制类型转换的格式：<strong>类型 变量名称 &#x3D; (类型)(对象或者变量)</strong></li><li>有继承&#x2F;实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Dog d = (Dog)a;</span></span><br><span class="line">        <span class="comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p><p>概念：定义在一个类里面的类就是内部类</p><p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p><p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p><hr><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p><p>静态内部类中的成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>特点与外部类是完全一样的，只是位置在别人里面</li><li>可以定义静态成员</li></ul><p>静态内部类的访问格式：外部类名称.内部类名称</p><p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称.内部类构造器</p><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?可以，外部类的静态成员只有一份，可以被共享</li><li>静态内部类中是否可以直接访问外部类的实例成员?不可以，外部类的成员必须用外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量</span></span><br><span class="line">         System.out.println(age);</span><br><span class="line">         <span class="comment">//System.out.println(salary);报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p><p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p><p>实例内部类的访问格式：外部类名称.内部类名称</p><p>创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类构造器.new 内部构造器</p><ul><li><code>Outter.Inner in = new Outter().new Inner()</code></li></ul><p><strong>实例内部类可以访问外部类的全部成员</strong></p><ul><li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li><li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li></ul><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p><p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        class&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;</span><br><span class="line"><span class="comment">//方法重写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类不能定义静态成员</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li><li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);</span><br><span class="line">                <span class="comment">//System.out.println(n);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.run();</span><br><span class="line">        a.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始go~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p><table><thead><tr><th>四种修饰符访问权限</th><th align="center">private</th><th align="center">缺省</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下的子类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下其他类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的子类中</td><td align="center">X</td><td align="center">X</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的其他类中</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">√</td></tr></tbody></table><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见</li><li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li></ul><hr><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代码块特点： <ul><li>必须有 static 修饰，只能访问静态资源</li><li>会与类一起优先加载，且自动触发执行一次</li></ul></li><li>静态代码块作用：<ul><li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li><li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块,属于类，与类一起加载一次!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">// 在静态代码块中进行静态资源的初始化操作</span></span><br><span class="line">        schoolName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法被执行&quot;</span>);</span><br><span class="line">        System.out.println(schoolName);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块被触发执行~~~~~~~</span></span><br><span class="line"><span class="comment">main方法被执行</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">[3, 4, 5] */</span></span><br></pre></td></tr></table></figure><hr><h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例代码块的特点：</p><ul><li>无 static 修饰，属于对象</li><li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li></ul></li><li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;代码块&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">()</span>&#123; &#125;<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeDemo</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">        System.out.println(c.name);</span><br><span class="line">        System.out.println(c.lists);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeDemo02</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p><p>Object 类常用方法：</p><ul><li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul><li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li><li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li></ul></li><li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li><li><code>protected Object clone()</code>：创建并返回此对象的副本</li></ul><p>只要两个对象的内容一样，就认为是相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">           sex == student.sex &amp;&amp;</span><br><span class="line">           Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：&#x3D;&#x3D; 和 equals 的区别</p><ul><li>&#x3D;&#x3D; 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li><li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li></ul><p>hashCode 的作用：</p><ul><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li><li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li></ul><hr><h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p><p>深浅拷贝（克隆）的概念：</p><ul><li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p><p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p></li><li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p></li></ul><p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p><ul><li><p>Clone &amp; Copy：<code>Student s = new Student</code></p><p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p><p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p></li><li><p>Shallow Clone &amp; Deep Clone：</p><p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p><ul><li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li><li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p><p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        s.date = (Date) date.clone();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>SDP → 创建型 → 原型模式</p><hr><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p><p>Objects 的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行非空判断，从而可以避免空指针异常</span></span><br><span class="line">    <span class="keyword">return</span> a == b || a != <span class="literal">null</span> &amp;&amp; a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>public static boolean isNull(Object obj)</code>：判断变量是否为 null ，为 null 返回 true</p></li><li><p><code>public static String toString(对象)</code>：返回参数中对象的字符串表示形式</p></li><li><p><code>public static String toString(对象, 默认字符串)</code>：返回对象的字符串表示形式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(Objects.equals(s1 , s2));<span class="comment">//推荐使用</span></span><br><span class="line">        <span class="comment">// System.out.println(s1.equals(s2)); // 空指针异常</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(Objects.isNull(s1));</span><br><span class="line">        System.out.println(s1 == <span class="literal">null</span>);<span class="comment">//直接判断比较好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p><p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure><hr><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p><ul><li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p></li><li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p></li><li><p><code>public int length()</code>：返回此字符串的长度</p></li><li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p></li><li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p></li><li><p><code>public char charAt(int index)</code>：取索引处的值</p></li><li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p></li><li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p></li><li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p></li><li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p></li><li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p></li><li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p></li><li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p></li><li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>-<span class="number">78</span>;</span><br><span class="line">s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure><hr><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p><ul><li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li><li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li><li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li></ul><p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p><ul><li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li><li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li></ul><p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p><ul><li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li><li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;" /></li></ul><p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p><ul><li><p>对象 1：new StringBuilder()</p></li><li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p></li><li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;" /></li><li><p>StringBuilder 的 toString()：</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 6：new String(“ab”)</li><li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li></ul><hr><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool &#x2F; StringTable &#x2F; 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p><ul><li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li><li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li><li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li><li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li></ul><hr><h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p><ul><li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li><li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li></ul><p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 串池</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">// 返回的是堆内地址</span></span><br><span class="line">        <span class="comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        <span class="comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值</li><li>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</li></ul><p>结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 仅放入串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">// 仅放入堆</span></span><br><span class="line"><span class="comment">// 上面两条指令的结果和下面的 效果 相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2 == str2.intern());<span class="comment">//false，字符串池中存在，直接返回已经存在的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">launcher_name</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_name</span> <span class="operator">=</span> <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_profile_name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221-b11&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p><p>演示 StringTable 位置：</p><ul><li><p><code>-Xmx10m</code> 设置堆内存 10m</p></li><li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p></li><li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(j).intern());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p><hr><h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p><ul><li><p>调整 -XX:StringTableSize&#x3D;桶个数，数量越少，性能越差</p></li><li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//很多数据</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul><li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li><li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li><li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li><li>防止子类继承，破坏 String 的 API 的使用</li></ul><hr><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p><ul><li>String : <strong>不可变</strong>的字符序列，线程安全</li><li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li><li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li></ul><p>相同点：底层使用 char[] 存储</p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li><li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li></ul><p>常用API : </p><ul><li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li><li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li><li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li></ul><p>存储原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//new byte[16] </span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure><p>append 源码：扩容为二倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span></span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到目标字符数组中</span></span><br><span class="line"><span class="comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p><p>常用API：</p><ul><li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li><li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li><li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//按照数字顺序排列指定的数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//1,数组必须有序</span></span><br><span class="line">        <span class="comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span></span><br><span class="line">        <span class="comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span></span><br><span class="line">            <span class="comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p><p>使用步骤：</p><ol><li><p>导入包：<code>import java.util.Random</code></p></li><li><p>创建对象：<code>Random r = new Random()</code></p></li><li><p>随机整数：<code>int num = r.nextInt(10)</code></p><ul><li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li><li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li></ul></li><li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p></li></ol><hr><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p><p>静态方法：</p><ul><li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p></li><li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p></li><li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p><ul><li>参数一：原数组</li><li>参数二：从原数组的哪个位置开始赋值</li><li>参数三：目标数组</li><li>参数四：从目标数组的哪个位置开始赋值</li><li>参数五：赋值几个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.exit(0); // 0代表正常终止!!</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//定义sdf 按照格式输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">System.out.println( (endTime - startTime)/<span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);<span class="comment">//程序用时</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> ,<span class="number">60</span> ,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span></span><br><span class="line">        <span class="comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">2</span>, arr2, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p><ul><li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li></ul><p>方法：</p><ul><li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li></ul><p>时间记录的两种方式：</p><ol><li>Date 日期对象</li><li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s &#x3D; 1000ms</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + <span class="number">121</span>*<span class="number">1000</span>;<span class="comment">//过121s是什么时间</span></span><br><span class="line">        System.out.println(time);<span class="comment">//1602856875485</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d1);<span class="comment">//Fri Oct 16 22:01:15 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="comment">//运行一万次输出需要多长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p><ol><li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li><li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li></ol><p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p><p>SimpleDateFormat  简单日期格式化类：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li><li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li><li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li><li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li></ul><blockquote><p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);</span></span><br><span class="line"><span class="string">    String time = sdf.format(date);</span></span><br><span class="line"><span class="string">    System.out.println(time);//2020-10-18 19:58:34</span></span><br><span class="line"><span class="string">    //过121s后是什么时间</span></span><br><span class="line"><span class="string">    long time = date.getTime();</span></span><br><span class="line"><span class="string">    time+=121;</span></span><br><span class="line"><span class="string">    System.out.println(sdf.formate(time));</span></span><br><span class="line"><span class="string">    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致</span></span><br><span class="line"><span class="string">    Date newDate = sdf.parse(d);</span></span><br><span class="line"><span class="string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p><p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p><p>Calendar 的方法：</p><ul><li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li><li><code>public int get(int field)</code>：取日期中的某个字段信息</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li><li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li><li><code>public final Date getTime()</code>：拿到此刻日期对象</li><li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInsance(); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> rightNow.get(Calendar.YEAR);<span class="comment">//获取年</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> rightNow.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月要+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    rightNow.set(Calendar.YEAR , <span class="number">2099</span>);<span class="comment">//修改某个字段</span></span><br><span class="line">    rightNow.add(Calendar.HOUR , <span class="number">15</span>);<span class="comment">//加15小时  -15就是减去15小时</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> rightNow.getTime();<span class="comment">//日历对象</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rightNow.getTimeInMillis();<span class="comment">//时间毫秒值</span></span><br><span class="line">    <span class="comment">//700天后是什么日子</span></span><br><span class="line">    rightNow.add(Calendar.DAY_OF_YEAR , <span class="number">701</span>);</span><br><span class="line">    Date <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(sdf.format(d));<span class="comment">//输出700天后的日期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p><ul><li>LocalDate       表示日期（年月日）  </li><li>LocalTime       表示时间（时分秒）</li><li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li></ul><p>构造方法：</p><ul><li>public static LocalDateTime now()：获取当前系统时间 </li><li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li></ul><p>常用API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中的第几天（1-31）</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中的第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr><tr><td>public LocalDate  toLocalDate()</td><td>转换成为一个 LocalDate 对象（年月日）</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成为一个 LocalTime 对象（时分秒）</td></tr><tr><td>public String format(指定格式)</td><td>把一个 LocalDateTime 格式化成为一个字符串</td></tr><tr><td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td><td>把一个日期字符串解析成为一个 LocalDateTime 对象</td></tr><tr><td>public static DateTimeFormatter ofPattern(String pattern)</td><td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> localDateTime.format(pattern);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(s, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears (long years)</td><td>添加或者减去年</td></tr><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年</td></tr></tbody></table><p><strong>时间间隔</strong> Duration 类API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public int getYears()</td><td>获得这段时间的年数</td></tr><tr><td>public int getMonths()</td><td>获得此期间的总月数</td></tr><tr><td>public int getDays()</td><td>获得此期间的天数</td></tr><tr><td>public long toTotalMonths()</td><td>获取此期间的总月数</td></tr><tr><td>public static Durationbetween(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public long toSeconds()</td><td>获得此时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获得此时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获得此时间间隔的纳秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate2);</span><br><span class="line">        System.out.println(period);<span class="comment">//P28Y11M11D</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime2);</span><br><span class="line">        System.out.println(duration);<span class="comment">//PT21H57M58S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p><p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取 a 的 b 次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td>public static int max(int a,int b)</td><td>返回较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回较小值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数。</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">4.00000001</span>));<span class="comment">//4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">4.99999999</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">    <span class="comment">//取一位整数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//取一位整数和两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">    <span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">    <span class="comment">//取所有整数部分</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">    <span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));<span class="comment">//2.99792E8</span></span><br><span class="line">    <span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));<span class="comment">//29.9792E7</span></span><br><span class="line">    <span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));<span class="comment">//299,792,458</span></span><br><span class="line">    <span class="comment">//将格式嵌入文本</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p><p>构造方法：</p><ul><li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li><li><code>public BigDecimal(double val)</code></li><li><code>public BigDecimal(String val)</code></li></ul><p>常用API：</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li><li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li><li><code>public int intValue()</code>：转为 int 其他类型相同</li><li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span></span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b ;</span><br><span class="line">        System.out.println(c);<span class="comment">//0.30000000000000004</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把浮点数转换成大数据对象运算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//a1.divide(b1);也可以</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>BigDecimal 是用来进行精确计算的</li><li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li><li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line"><span class="comment">//参数1：表示参与运算的BigDecimal 对象。</span></span><br><span class="line"><span class="comment">//参数2：表示小数点后面精确到多少位</span></span><br><span class="line"><span class="comment">//参数3：舍入模式  </span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_UP  进一法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_FLOOR 去尾法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure><hr><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p><p>比如检验 qq 号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQRegex</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq!=<span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数</span></span><br><span class="line">&#125;<span class="comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><hr><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p><hr><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 \ 本身</td></tr><tr><td>()</td><td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td></tr></tbody></table><hr><h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td></tr><tr><td>\d</td><td>数字字符，0~9 中的任意一个，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于  [ ^0-9]</td></tr><tr><td>\w</td><td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td></tr><tr><td>\W</td><td>对\w取非，等价于[ ^\w]</td></tr><tr><td>\s</td><td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p><hr><h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td></tr><tr><td>[a-d[m-p]]</td><td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td></tr><tr><td>[a-z&amp;&amp;[m-p]]</td><td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td></tr><tr><td>[^]</td><td>取反</td></tr></tbody></table><ul><li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p></li><li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p></li></ul><hr><h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li><li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li></ul><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>X?</td><td>X 一次或一次也没，有相当于 {0,1}</td></tr><tr><td>X*</td><td>X 不出现或出现任意次，相当于 {0,}</td></tr><tr><td>X+</td><td>X 至少一次，相当于 {1,}</td></tr><tr><td>X{n}</td><td>X 恰好 n 次</td></tr><tr><td>{n,}</td><td>X 至少 n 次</td></tr><tr><td>{n,m}</td><td>X 至少 n 次，但是不超过 m 次</td></tr></tbody></table><hr><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr></tbody></table><hr><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p><ul><li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li><li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li></ul><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|  (分支结构)</td><td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td></tr><tr><td>()  (捕获组)</td><td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br/>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br/>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression)   非捕获组</td><td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td></tr></tbody></table><hr><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p><ul><li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p></li><li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p></li><li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p></li><li><p>应用 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li><li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li><li>实例：43438n44</li></ul></li><li><p>应用 2：爬虫</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;x&lt;/h1&gt;<span class="comment">//匹配</span></span><br><span class="line">&lt;h2&gt;x&lt;/h2&gt;<span class="comment">//匹配</span></span><br><span class="line">&lt;h3&gt;x&lt;/h1&gt;<span class="comment">//不匹配</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p><ul><li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p></li><li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p></li><li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>(?&#x3D;exp)</td><td>断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td>(?&lt;&#x3D;exp)</td><td>断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td>(?!exp)</td><td>断言此位置的后面不能匹配表达式exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言此位置的前面不能匹配表达式exp</td></tr></tbody></table></li></ul><hr><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p><ul><li>IGNORECASE 忽略大小写模式<ul><li>匹配时忽略大小写。</li><li>默认情况下，正则表达式是要区分大小写的。</li></ul></li><li>SINGLELINE 单行模式<ul><li>整个文本看作一个字符串，只有一个开头，一个结尾。</li><li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li></ul></li><li>MULTILINE 多行模式<ul><li>每行都是一个字符串，都有开头和结尾。</li><li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li></ul></li></ul><hr><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p><ul><li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li><li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li><li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li></ul><p>Matcher 类：</p><ul><li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li><li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li><li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li><li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);</span><br><span class="line"><span class="comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span></span><br><span class="line"><span class="comment">//System.out.println(b);//false</span></span><br><span class="line"><span class="comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line"><span class="comment">//System.out.println(b2);//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//asfsdf2</span></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//3323</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//group(),group(0)匹配整个表达式的子字符串</span></span><br><span class="line">System.out.println(m.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="comment">//不需要加多余的括号</span></span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aa232**ssd445&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">1</span>));<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">2</span>));<span class="comment">//aa     ssd</span></span><br><span class="line">            System.out.println(m.group(<span class="number">3</span>));<span class="comment">//232    445 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li><li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li></ul><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false 判断a是否在abc之外的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false 是否a是整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true 是否是字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));<span class="comment">//false 只能检验单个字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 验证。必须是数字和字符  必须是4位</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dsd22&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;A3dy&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机号码格式正确！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;.......&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1111@qq.com  zhy@pic.com.cn</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱格式正确！&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// .是任意字符 \\.就是点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li><li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 1.split的基础用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line"><span class="comment">// 以“，”分割成字符串数组</span></span><br><span class="line">    String[] nameArrs = names.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.split集合正则表达式做分割</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> <span class="string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;</span><br><span class="line">    <span class="comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span></span><br><span class="line">String[] nameArrs1 = names1.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用正则表达式定位出内容，替换成/</span></span><br><span class="line">System.out.println(names1.replaceAll(<span class="string">&quot;\\w+&quot;</span>,<span class="string">&quot;/&quot;</span>));<span class="comment">//风清扬/张无忌/周芷若</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">System.out.println(names3.replaceAll(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;-&quot;</span>));<span class="comment">//风清扬-张无忌-周芷若</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p><p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p><p>数组：类型和长度一旦定义出来就都固定</p><p>作用：</p><ul><li>在开发中，很多时候元素的个数是不确定的</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li></ul><hr><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><ul><li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p></li><li><p>栈（stack）：后进先出，先进后出 （LIFO）</p></li><li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p><p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p></li><li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p></li><li><p>树：</p><ul><li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） </p><p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p></li><li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p><p>特点：<strong>红黑树的增删查改性能都好</strong></p></li></ul></li></ul><p>各数据结构时间复杂度对比：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png"></p><p>图片来源：<a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p><hr><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p><p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection集合的体系:</span><br><span class="line">                      Collection&lt;E&gt;(接口)</span><br><span class="line">                 /                         \</span><br><span class="line">          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)</span><br><span class="line">      /               \                  /             \</span><br><span class="line"> HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类)</span><br><span class="line"> /</span><br><span class="line">LinkedHashSet&lt;&gt;(实现类)</span><br></pre></td></tr></table></figure><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><hr><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sets.add(<span class="string">&quot;MyBatis&quot;</span>);</span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        sets.add(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">        sets.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(sets)<span class="comment">//[]无序的;</span></span><br><span class="line">        System.out.println(sets.contains(<span class="string">&quot;java&quot;</span>));<span class="comment">//true 存在</span></span><br><span class="line">        Object[] arrs = sets.toArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c1.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;ee&quot;</span>);</span><br><span class="line">        c1.addAll(c2);<span class="comment">// c1:[java,ee]  c2:[ee];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器</p><ul><li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li><li><code>E next()</code>：获取下一个元素值</li><li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li><li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li></ul></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        System.out.println(lists); <span class="comment">// lists = [aa, bb, cc]</span></span><br><span class="line"><span class="comment">//迭代器流程</span></span><br><span class="line">        <span class="comment">// 1.得到集合的迭代器对象。</span></span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="comment">// 2.使用while循环遍历。</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>List 集合继承了 Collection 集合全部的功能。</p><p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p><p>List 系列集合：</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引</p></li></ul><hr><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//多态</span></span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);<span class="comment">//可以重复</span></span><br><span class="line">    lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; lists.size() ; i++ ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e 插入的元素  elementData底层数组   size 插入的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">// 插入size位置，然后加一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断elementData是不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值和最小需求容量最大的一个</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的容量大于数组长度，进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 索引越界</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将指定索引后的数据后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity&#x2F;2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;<span class="comment">//不需要扩容计算</span></span><br><span class="line">    <span class="comment">//检查新容量是否大于最大数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span></span><br><span class="line">        <span class="comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取下一个元素时首先判断结构是否发生变化</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount 被其他线程改变抛出并发修改异常</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【允许删除操作】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 删除后重置 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code> 数组存储</p></li></ol><hr><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h6><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue); <span class="comment">// [1号, 2号, 3号]</span></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//1号</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//2号</span></span><br><span class="line">        System.out.println(queue);<span class="comment">//[3号]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做一个栈 先进后出</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);<span class="comment">//addFirst(e);</span></span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack); <span class="comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span></span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        System.out.println(stack.pop());<span class="comment">//removeFirst(); 第3颗子弹</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);<span class="comment">// [第1颗子弹]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index&#x3D;0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index&#x3D;-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><hr><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>Set 系列集合：</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p><hr><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT &#x3D; new Object()</strong></p><p>Set 集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。</span><br><span class="line"><span class="number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。</span><br><span class="line">    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）</span><br><span class="line">    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。</span><br><span class="line">    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了</span><br><span class="line">    如果不相同认为不重复。</span><br><span class="line"></span><br><span class="line">            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较</span><br><span class="line">               /                     \</span><br><span class="line">            <span class="literal">false</span>                    <span class="literal">true</span></span><br><span class="line">            /                          \</span><br><span class="line">        不重复                        继续让两个对象进行equals比较</span><br><span class="line">                                       /          \</span><br><span class="line">                                     <span class="literal">false</span>        <span class="literal">true</span></span><br><span class="line">                                      /             \</span><br><span class="line">                                    不重复          重复了</span><br></pre></td></tr></table></figure></li><li><p>Set 系列集合元素无序的根本原因</p><p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><ul><li>JDK 1.8 之前：哈希表 &#x3D; 数组（初始容量16) + 链表  + （哈希算法）</li><li>JDK 1.8 之后：哈希表 &#x3D; 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul><li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li><li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><hr><h5 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h5><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><hr><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>   方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><pre><code>  * 比较者大于被比较者，返回正数  * 比较者小于被比较者，返回负数  * 比较者等于被比较者，返回 0</code></pre></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">Collections.add(students,s1,s2,s3);</span><br><span class="line">        System.out.println(students);<span class="comment">//按照年龄比较 升序</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// o1比较者   o2被比较者</span></span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 重写了比较方法。</span></span><br><span class="line">    <span class="comment">// e1.compareTo(o)</span></span><br><span class="line">    <span class="comment">// 比较者：this</span></span><br><span class="line">    <span class="comment">// 被比较者：o</span></span><br><span class="line">    <span class="comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? <span class="built_in">this</span>.getName().compareTo(o.getName):result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p><hr><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="comment">//实现大顶堆</span></span><br><span class="line"></span><br><span class="line">常用 API：</span><br><span class="line"></span><br><span class="line">* `<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>`：将指定的元素插入到此优先级队列的**尾部**</span><br><span class="line">* `<span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> `：检索并删除此队列的**头元素**，如果此队列为空，则返回 <span class="literal">null</span> </span><br><span class="line">* `<span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>`：检索但不删除此队列的头，如果此队列为空，则返回 <span class="literal">null</span></span><br><span class="line">* `<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>`：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Collections</span><br><span class="line"></span><br><span class="line">java.utils.Collections：集合**工具类**，Collections 并不属于集合，是用来操作集合的工具类</span><br><span class="line"></span><br><span class="line">Collections 有几个常用的API：</span><br><span class="line"></span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... e)</span>`：给集合对象批量添加元素</span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span>`：打乱集合顺序</span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span>`：将集合中元素按照默认规则排序</span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;? <span class="built_in">super</span> T&gt; )</span>`：集合中元素按照指定规则排序</span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>`：返回由指定 list 支持的线程安全 list</span><br><span class="line">* `<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">singleton</span><span class="params">(T o)</span>`：返回一个只包含指定对象的不可变组</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;赵&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">98.5</span>, <span class="number">66.5</span> , <span class="number">59.5</span> , <span class="number">66.5</span> , <span class="number">99.5</span> );</span><br><span class="line">        Collections.shuffle(scores);</span><br><span class="line">        Collections.sort(scores); <span class="comment">// 默认升序排序！</span></span><br><span class="line">        System.out.println(scores);</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(students,s1,s2,s3,s4);</span><br><span class="line">        Collections.sort(students,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key&#x3D;value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map集合的体系：</span><br><span class="line">        Map&lt;K , V&gt;(接口,Map集合的祖宗类)</span><br><span class="line">       /                      \</span><br><span class="line">      TreeMap&lt;K , V&gt;           HashMap&lt;K , V&gt;(实现类,经典的，用的最多)</span><br><span class="line">                                 \</span><br><span class="line">                                  LinkedHashMap&lt;K, V&gt;(实现类)</span><br></pre></td></tr></table></figure><p>Map 集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(.....);</span><br><span class="line">        System.out.println(maps.isEmpty());<span class="comment">//false</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(<span class="string">&quot;....&quot;</span>);<span class="comment">//返回键值对象</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();<span class="comment">//获取Map集合中所有的键，</span></span><br><span class="line">        <span class="comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        <span class="comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//(1)键找值</span></span><br><span class="line">    Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key : keys) &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Iterator&lt;String&gt; iterator = hm.keySet().iterator();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)键值对</span></span><br><span class="line">    <span class="comment">//(2.1)普通方式</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">             System.out.println(entry.getKey() + <span class="string">&quot;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2.2)迭代器方式</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) Lamda</span></span><br><span class="line">    maps.forEach((k,v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;==&gt;&quot;</span> + v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 &#x3D; 数组 + 链表，8 &#x3D; 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由数组+链表组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1nJ411J7AA">https://www.bilibili.com/video/BV1nJ411J7AA</a></p><hr><h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>HashMap 继承关系如下图所示：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li></ul><hr><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>HashMap 构造方法指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity)<span class="comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合最大容量 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合最大容量的上限是：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span></span><br></pre></td></tr></table></figure></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p> 为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="number">0.75</span>，平均参数约为<span class="number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="number">0.5</span>)*pow(<span class="number">0.5</span>, k)/factorial(k))</span><br><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br><span class="line">一个bin中链表长度达到<span class="number">8</span>个元素的概率为<span class="number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="number">8</span>这个数字</span><br></pre></td></tr></table></figure></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)&#x3D;3，链表的平均查找长度为 n&#x2F;2，当长度为 8 时，平均查找长度为 8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，而 log(6)&#x3D;2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小于 6 则会从红黑树转回链表</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p> 原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>HashMap 中<strong>存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></li><li><p>记录 HashMap 的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br></pre></td></tr></table></figure></li><li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希表的加载因子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size&#x2F;capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p><p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)<span class="comment">//构造指定初始容量和加载因子的空HashMap</span></span><br></pre></td></tr></table></figure></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;&#x3D; threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p></li></ul></li></ol><hr><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"><span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// 最后调用了tableSizeFor</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putMapEntries 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">            <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s &#x2F; loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p></li><li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p><p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span></span><br><span class="line">    <span class="comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  <span class="comment">//。。。。。。。。。。。。。。</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="comment">// 如果这里允许覆盖，就直接返回了</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数量大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;" /><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY &#x3D; 64 就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;<span class="comment">//int cap = 10</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n&#x3D;0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位或之后是13</span></span><br><span class="line"><span class="comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span></span><br></pre></td></tr></table></figure></li><li><p>第二次右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位或之后是15</span></span><br><span class="line"><span class="comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span></span><br></pre></td></tr></table></figure><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure></li><li><p>JDK 11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">//无符号右移，高位补0</span></span><br><span class="line"><span class="comment">//-1补码: 11111111 11111111 11111111 11111111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最高位之前的0的位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始化的threshold赋值给newCap</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// oldCap 旧数组大小，2 的 n 次幂</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;<span class="comment">//指向低位链表头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;<span class="comment">//指向低位链表尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;<span class="comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span></span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果低位链表首节点不为null，说明有这个链表存在</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果链表下的元素小于等于6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span></span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span></span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//需要构建新的红黑树了</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span></span><br><span class="line">    <span class="comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;<span class="comment">//临时变量，储存要返回的节点信息</span></span><br><span class="line">        <span class="comment">//key和value都相等，直接返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="comment">//跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//把当前节点p指向e 继续遍历</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line">        <span class="comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//node是首节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//node不是首节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//LinkedHashMap</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><hr><h5 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h5><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.keySet().iterator();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 底层获取的是 KeyIterator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 回调 HashMap.HashIterator#nextNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> nextNode().key; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for 【fast-fail】，快速失败</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// iterator.next() 会调用这个函数</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li><li><p>维护顺序的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>put()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用父类HashMap的put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">→ afterNodeInsertion(evict);<span class="comment">// evict为true</span></span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);<span class="comment">//移除头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断 p 是否是首节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//是头节点 让p后继节点成为头节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 判断p是否是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 不是尾节点 让p后继节点指向p的前驱节点</span></span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 是尾节点 让last指向p的前驱节点</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 判断last是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// last为空说明p是尾节点或者只有p一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// last和p相互连接</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用HashMap的remove方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,<span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span></span><br><span class="line">→ afterNodeRemoval(node);</span><br></pre></td></tr></table></figure><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 让p节点与前驱节点和后继节点断开链接</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断p是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是头节点 让head指向p的后继节点</span></span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);<span class="comment">//把1放入尾部</span></span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());<span class="comment">//[3, 1, 4]只能存3个，移除2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p><p>成员属性：</p><ul><li><p>Entry 节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;<span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;<span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;<span class="comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator == <span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p><hr><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p><ul><li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p></li><li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p></li><li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p></li><li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.size = size;</span><br><span class="line">          <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">          <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">          <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">              v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">              <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                  <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">              <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">              <span class="built_in">this</span>.eden.clear();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 泛型</span><br><span class="line"></span><br><span class="line">#### 概述</span><br><span class="line"></span><br><span class="line">泛型（Generic）：</span><br><span class="line"></span><br><span class="line">* 泛型就是一个标签：&lt;数据类型&gt;</span><br><span class="line">* 泛型可以在编译阶段约束只能操作某种数据类型。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">* JDK <span class="number">1.7</span> 开始之后，泛型后面的申明可以省略不写</span><br><span class="line">* **泛型和集合都只能支持引用数据类型，不支持基本数据类型**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ArrayList&lt;Object&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">lists.add(<span class="number">99.9</span>);</span><br><span class="line">lists.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">lists.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lists1.add(<span class="number">10</span>);</span><br><span class="line">lists1.add(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>泛型类：使用了泛型定义的类就是泛型类</p><p>泛型类格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">泛型变量建议使用 E , T , K , V</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;String&gt;();</span><br><span class="line">        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;自定义泛型类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><p>泛型方法：定义了泛型的方法就是泛型方法</p><p>泛型方法的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p><p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] num = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> arrToString(nums);</span><br><span class="line">     </span><br><span class="line">        String[] name = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> arrToString(names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">arrToString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        --------------</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><p>泛型接口：使用了泛型定义的接口就是泛型接口。</p><p>泛型接口的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentData</span>();</span><br><span class="line">        d.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        ................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;重写所有方法&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符：？</p><ul><li>? 可以用在使用泛型的时候代表一切类型</li><li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li><li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;AD&gt; ads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        run(bmws);</span><br><span class="line">        <span class="comment">//run(dogs);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ArrayList&lt;? extends Car&gt; car)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AD</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">异常的体系:</span><br><span class="line">         Throwable(根类，不是异常类)</span><br><span class="line">      /              \</span><br><span class="line">    Error           Exception（异常，需要研究和处理）</span><br><span class="line">                    /            \</span><br><span class="line">                   编译时异常     RuntimeException(运行时异常)</span><br></pre></td></tr></table></figure><p>Exception 异常的分类:</p><ul><li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li><li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li></ul><hr><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点终止当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。。。。。。。&quot;</span>);</span><br><span class="line">        chu( <span class="number">10</span> ,<span class="number">0</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b ;<span class="comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p><p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p><p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h5><p>可以处理异常，并且出现异常后代码也不会死亡</p><ul><li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;...finall&#123;</span><br><span class="line"><span class="comment">//资源释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace(); <span class="comment">// **直接打印异常栈信息**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Throwable成员方法:</strong></p><ul><li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li><li><code>public String toString()</code>：返回此可抛出的简短描述</li><li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h5><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseDate(<span class="string">&quot;2013-03-23 10:19:23&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseDate</span><span class="params">(String time)</span> <span class="keyword">throws</span> Exception&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常：NumberFormatException</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。。。&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.数组索引越界异常: ArrayIndexOutOfBoundsException。</span></span><br><span class="line">        <span class="type">int</span>[] arrs = &#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span>&#125;;</span><br><span class="line">        System.out.println(arrs[<span class="number">3</span>]); <span class="comment">//出现了数组索引越界异常。代码在此处直接执行死亡！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.空指针异常 : NullPointerException。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        System.out.println(name); <span class="comment">// 直接输出没有问题</span></span><br><span class="line">        System.out.println(name.length());<span class="comment">//出现了空指针异常。代码直接执行死亡！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 3.类型转换异常：ClassCastException。 */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="string">&quot;齐天大圣&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> (Integer) o;  <span class="comment">// 此处出现了类型转换异常。代码在此处直接执行死亡！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 5.数学操作异常：ArithmeticException。 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span> ; <span class="comment">// 此处出现了数学操作异常。代码在此处直接执行死亡！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 6.数字转换异常： NumberFormatException。 */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;23aa&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(num); <span class="comment">//出现了数字转换异常。代码在此处执行死亡！</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h4><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            chu(<span class="number">10</span> / <span class="number">0</span>);<span class="comment">//ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作成功！&quot;</span>);<span class="comment">//没输出</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;操作失败！&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>  &#123; System.out.println( a / b );&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>用在捕获处理的异常格式中的，放在最后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>: <span class="number">1</span>次。</span><br><span class="line"><span class="keyword">catch</span>：<span class="number">0</span>-N次  (如果有<span class="keyword">finally</span>那么<span class="keyword">catch</span>可以没有!!)</span><br><span class="line"><span class="keyword">finally</span>: <span class="number">0</span>-<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(chu());<span class="comment">//一定会输出 finally,优先级比return高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">return</span> a ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====finally被执行&quot;</span>);</span><br><span class="line">            <span class="comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/cang.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==finally被执行===&quot;</span>);</span><br><span class="line">            <span class="comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h3><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li></ul><p>throws：用在方法上，用于抛出方法中的异常</p><p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIllegalException &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>)&#123;<span class="comment">//年龄在0-200之间</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;/ age is illegal!&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄是：&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    Alt + Insert-&gt;Constructor </span><br><span class="line">&#125;<span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//运行时异常</span></span><br></pre></td></tr></table></figure><hr><h3 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h3><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li><li>在 try&#x2F;catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//请输入一个合法的年龄</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入您的年年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄：&quot;</span>+age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;您的年龄是瞎输入的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda 表达式的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line"><span class="comment">//被重写方法的方法体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h4 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h4><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p><ul><li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; System.out.println(s) );</span><br></pre></td></tr></table></figure><hr><h4 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h4><p>Comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//...s1 s2 s3</span></span><br><span class="line">        Collections.addAll(lists , s1 , s2 , s3);</span><br><span class="line">        Collections.sort(lists, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.getAge() - t2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 参数类型可以省略,最简单的</span></span><br><span class="line">        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists.forEach( s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 方法引用！</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义集合加入几个Student元素</span></span><br><span class="line"><span class="comment">// 使用静态方法进行简化！</span></span><br><span class="line">Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));</span><br><span class="line"><span class="comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span></span><br><span class="line">Collections.sort(lists, Student::compareByAge);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1 , Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        <span class="comment">// 对象是 System.out = new PrintStream();</span></span><br><span class="line">        <span class="comment">// 实例方法：println()</span></span><br><span class="line">        <span class="comment">// 前后参数正好都是一个</span></span><br><span class="line">        lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h4><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Patricia&quot;</span>,<span class="string">&quot;Dlei&quot;</span> , <span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Boom&quot;</span>, <span class="string">&quot;Cao&quot;</span> ,<span class="string">&quot;black&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>,<span class="string">&quot;cao&quot;</span>,<span class="string">&quot;after&quot;</span>,<span class="string">&quot;sa&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span></span><br><span class="line">        <span class="comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span></span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.compareToIgnoreCase(s2);<span class="comment">//按照元素的首字符(忽略大小写)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特定类型的方法引用：</span></span><br><span class="line">        Arrays.sort(strs,  String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合默认只能转成Object类型的数组。</span></span><br><span class="line">        Object[] objs = lists.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span></span><br><span class="line">        String[] strs = lists.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String[] strs1 = lists.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]);</span><br><span class="line">        String[] strs2 = lists.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p><ul><li>可以解决已有集合类库或者数组 API 的弊端</li><li>Stream 流简化集合和数组的操作</li><li>链式编程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p><p>数组：Arrays.stream(数组)   &#x2F;  Stream.of(数组);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collection集合获取Stream流。</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; listStream = c.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map集合获取流</span></span><br><span class="line"><span class="comment">// 先获取键的Stream流。</span></span><br><span class="line">Stream&lt;String&gt; keysStream = map.keySet().stream();</span><br><span class="line"><span class="comment">// 在获取值的Stream流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = map.values().stream();</span><br><span class="line"><span class="comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组获取流</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaEE&quot;</span> ,<span class="string">&quot;Spring Boot&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;String&gt; arrStream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><hr><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>逐一处理（遍历）</td></tr><tr><td>long count</td><td>返回流中的元素数</td></tr><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream<T> skip(long n)</td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</td><td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</td><td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td></tr><tr><td>Stream<T> distinct()</td><td>返回由该流的不同元素组成的流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>); list.add(<span class="string">&quot;周芷若&quot;</span>); list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>); list.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">        <span class="comment">//取以张开头并且名字是三位数的</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).count();</span><br><span class="line"><span class="comment">//取前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).limit(<span class="number">2</span>).forEach(...);</span><br><span class="line"><span class="comment">//跳过前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).skip(<span class="number">2</span>).forEach(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：把名称都加上“张三的:+xxx”</span></span><br><span class="line">list.stream().map(s -&gt; <span class="string">&quot;张三的&quot;</span> + s).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 需求：把名称都加工厂学生对象放上去!!</span></span><br><span class="line"><span class="comment">// list.stream().map(name -&gt; new Student(name));</span></span><br><span class="line">list.stream.map(Student::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">                                          </span><br><span class="line"><span class="comment">//数组流</span></span><br><span class="line">Stream&lt;Integer&gt; s1 = Stream.of(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">//集合流</span></span><br><span class="line">Stream&lt;String&gt; s2 = list.stream();</span><br><span class="line"><span class="comment">//合并流</span></span><br><span class="line">Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);</span><br><span class="line">s3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure><hr><h4 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h4><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreach终结方法</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">    .filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h4 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h4><p>收集 Stream：把 Stream 流的数据转回到集合中去</p><ul><li>Stream 流：工具</li><li>集合：目的</li></ul><p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p><p>Collectors 方法：</p><ul><li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li><li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li><li><code>Object[] toArray()</code>：把元素收集数组中</li><li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));    </span><br><span class="line">    <span class="comment">//把stream流转换成Set集合。</span></span><br><span class="line">    Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成List集合。</span></span><br><span class="line">    <span class="comment">//重新定义，因为资源已经被关闭了</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成数组。</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    Object[] arr = stream2.toArray();</span><br><span class="line">    <span class="comment">// 可以借用构造器引用申明转换成的数组类型！！！</span></span><br><span class="line">    String[] arr1 = stream2.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h4><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p><p>File 类构造器：</p><ul><li><code>public File(String pathname)</code>：根据路径获取文件对象</li><li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li></ul><p>File 类创建文件对象的格式：</p><ul><li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p><ul><li>绝对路径：从磁盘的的盘符一路走到目的位置的路径<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li><li>一般是定位某个操作系统中的某个文件对象</li></ul></li><li><strong>相对路径</strong>：不带盘符的（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件，可以跨平台</li></ul></li></ul></li><li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象：使用绝对路径</span></span><br><span class="line">        <span class="comment">// 文件路径分隔符：</span></span><br><span class="line">        <span class="comment">//      -- a.使用正斜杠： /</span></span><br><span class="line">        <span class="comment">//      -- b.使用反斜杠： \\</span></span><br><span class="line">        <span class="comment">//      -- c.使用分隔符API:File.separator</span></span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator</span></span><br><span class="line"><span class="comment">//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 获取文件的大小，字节大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建文件对象：使用相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day09Demo/src/dlei.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建文件对象：代表文件夹。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片资源&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists());<span class="comment">// 判断路径是否存在！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getAbsolutePath()</td><td>返回此 File 的绝对路径名字符串</td></tr><tr><td>String getPath()</td><td>获取创建文件对象的时候用的路径</td></tr><tr><td>String getName()</td><td>返回由此 File 表示的文件或目录的名称</td></tr><tr><td>long length()</td><td>返回由此 File 表示的文件的长度（大小）</td></tr><tr><td>long length(FileFilter filter)</td><td>文件过滤器</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/图片/test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><p>方法列表：</p><ul><li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li><li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li><li><code>boolean isFile()</code>：此 File 表示的是否为文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// a.判断文件路径是否存在</span></span><br><span class="line">System.out.println(f.exists()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span></span><br><span class="line">System.out.println(f.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span></span><br><span class="line">System.out.println(f.isDirectory()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h5 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h5><p>方法列表：</p><ul><li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li><li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li><li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li><li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.创建新文件，创建成功返回true ,反之</span></span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f.delete());</span><br><span class="line">        <span class="comment">// 不能删除非空文件夹，只能删除空文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/it/aaaaa&quot;</span>);</span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/bbbb&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d.创建多级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><ul><li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li><li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li><li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified(); <span class="comment">// 最后修改时间！</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>递归实现文件搜索（非规律递归）</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去某个目录下搜索某个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 搜索文件的目录。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName 搜索文件的名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir , String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断是否存在该路径，是否是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">        <span class="comment">// 2.提取当前目录下的全部一级文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">files</span> <span class="operator">=</span> dir.listFiles();<span class="comment">// 可能是null/也可能是空集合[]</span></span><br><span class="line">        <span class="comment">// 3.判断是否存在一级文件对象,判断是否不为空目录</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.判断一级文件对象</span></span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="comment">// 5.判断file是文件还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 6.判断该文件是否为我要找的文件对象</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;<span class="comment">//模糊查找</span></span><br><span class="line">                        sout(f.getAbsolutePath());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 启动它（拓展）</span></span><br><span class="line">                            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                            r.exec(f.getAbsolutePath());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span></span><br><span class="line">                    searchFiles(file,fileName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>字符集：为字符编制的一套编号规则</p><p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p><p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 &#x3D; 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a  97</span><br><span class="line">b  98</span><br><span class="line"></span><br><span class="line">A  65</span><br><span class="line">B  66</span><br><span class="line"></span><br><span class="line">0  48</span><br><span class="line">1  49</span><br></pre></td></tr></table></figure><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p><p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p><ul><li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li><li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li></ul><p>编码前与编码后的编码集必须一致才不会乱码</p><hr><h3 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>IO 输入输出流：输入&#x2F;输出流</p><ul><li>Input：输入</li><li>Output：输出</li></ul><p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p><p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p><p>IO 流的分类：</p><ul><li>按照流的方向分为：输入流，输出流。<ul><li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li></ul></li><li>按照流的内容分为：字节流，字符流<ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li></ul></li></ul><p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IO 流的体系：</span><br><span class="line">        字节流                                   字符流</span><br><span class="line">  字节输入流              字节输出流            字符输入流         字符输出流</span><br><span class="line">InputStream           OutputStream          Reader            <span class="title function_">Writer</span>   <span class="params">(抽象类)</span></span><br><span class="line">FileInputStream       FileOutputStream      FileReader        <span class="title function_">FileWriter</span><span class="params">(实现类)</span></span><br><span class="line">BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="title function_">BufferedWriter</span><span class="params">(实现类缓冲流)</span></span><br><span class="line">                                           InputStreamReader OutputStreamWriter</span><br><span class="line">ObjectInputStream     ObjectOutputStream</span><br></pre></td></tr></table></figure><hr><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h5><p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p><p>构造方法：</p><ul><li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li><li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象</li></ul><p>方法：</p><ul><li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li><li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li><li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li><li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象定位dlei01.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/dlei01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span></span><br><span class="line"><span class="comment">//int code1 = is.read(); // 读取一滴水，一个字节</span></span><br><span class="line"><span class="comment">//System.out.println((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.使用while读取字节数</span></span><br><span class="line">        <span class="comment">// 定义一个整数变量存储字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>((ch = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p><p>采取下面的方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//简化写法，底层实质上创建了File对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];<span class="comment">//开发中使用byte[1024]</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取了多少就倒出多少！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"><span class="comment">// 读取全部的</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer);</span><br><span class="line">System.out.println(rs);</span><br></pre></td></tr></table></figure><hr><h5 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h5><p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p><p>构造方法：</p><ul><li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li><li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li><li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li><li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li></ul><p>API：</p><ul><li><p><code>public void write(int a)</code>：写一个字节出去 </p></li><li><p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p></li><li><p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p></li><li><p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p><ul><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot;)</code>：覆盖数据管道</li><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot; , true)</code>：追加数据的管道</li></ul></li></ul><p>说明：</p><ul><li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li><li>换行用：<strong>os.write(“\r\n”.getBytes())</strong></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/out05&quot;</span>);</span><br><span class="line">os.write(<span class="number">97</span>);<span class="comment">//a</span></span><br><span class="line">os.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">os.write(<span class="string">&quot;我爱Java&quot;</span>.getBytes());</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><h5 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h5><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//（1）创建一个字节输入流管道与源文件接通。</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（2）创建一个字节输出流与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（3）创建一个字节数组作为桶</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//（4）从字节输入流管道中读取数据，写出到字节输出流管道即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**（5）关闭资源！ */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h5><p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p><p>构造器：</p><ul><li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li><li><code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li></ul><p>方法：</p><ul><li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li><li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li></ul><p>结论：</p><ul><li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li><li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li></ul><p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span>&#123;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个字符输入流管道与源文件路径接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h5><p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p><p>构造器：</p><ul><li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li><li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li><li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li><li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li></ul><p>方法：</p><ul><li><code>public void write(int c)</code>：写一个字符出去</li><li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li><li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li><li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li><li><code>fw.write(&quot;\r\n&quot;)</code>：换行</li></ul><p>读写字符文件数据建议使用字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">fw.write(<span class="number">97</span>);   <span class="comment">// 字符a</span></span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 字符b</span></span><br><span class="line">fw.write(<span class="string">&quot;Java是最优美的语言！&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">fw.close;</span><br></pre></td></tr></table></figure><hr><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>缓冲流可以提高字节流和字符流的读写数据的性能</p><p>缓冲流分为四类：</p><ul><li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li><li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li><li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li><li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li></ul><hr><h5 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h5><p>字节缓冲输入流：BufferedInputStream</p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p><p>构造器：<code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个低级的字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span></span><br><span class="line">        <span class="type">BufferInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferInputStream</span>(is);</span><br><span class="line">        <span class="comment">// 3.定义一个字节数组按照循环读取。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h5><p>字节缓冲输出流：BufferedOutputStream</p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.写一个原始的字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输出流包装成一个高级的缓冲字节输出流</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 3.写数据出去</span></span><br><span class="line">        bos.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bos.write(<span class="number">100</span>);</span><br><span class="line">        bos.write(<span class="string">&quot;我爱中国&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h5><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p><p>复制流：</p><ul><li>使用低级的字节流按照一个一个字节的形式复制文件</li><li>使用低级的字节流按照一个一个字节数组的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li></ul><p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p><hr><h5 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h5><p>字符缓冲输入流：BufferedReader</p><p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p><p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个原始的字符输入流读取源文件</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">    <span class="comment">// 定义一个字符串变量存储每行数据</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">    <span class="comment">//淘汰数组循环读取</span></span><br><span class="line">    <span class="comment">//char[] buffer = new char[1024];</span></span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    <span class="comment">//while((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.println(new String(buffer , 0 , len));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h5><p>符缓冲输出流：BufferedWriter</p><p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code></p><p> 原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p><p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>,<span class="literal">true</span>);<span class="comment">//追加</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    </span><br><span class="line">    bw.write(<span class="string">&quot;我爱学习Java&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//换行</span></span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h5><p>字符型缓冲流高效的原因：（空间换时间）</p><ul><li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li><li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li></ul><p>字节型缓冲流高效的原因：</p><ul><li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li><li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。</li></ul><p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p><hr><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><h5 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h5><p>字符流读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码编码            文件编码         中文情况。</span><br><span class="line">UTF-8              UTF-8           不乱码!</span><br><span class="line">GBK                GBK             不乱码!</span><br><span class="line">UTF-8              GBK             乱码!</span><br></pre></td></tr></table></figure><ul><li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li><li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li></ul><hr><h5 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h5><p>字符输入转换流：InputStreamReader</p><p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li><li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.提取GBK文件的原始字节流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\Netty.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        <span class="comment">// 3.包装成缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h5><p>字符输出转换流：OutputStreamWriter</p><p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;我在学习Java&quot;</span>);   </span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><hr><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 &#x3D;&gt; 文件中</p><p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 &#x3D;&gt; 对象</p><p>transient 关键字修饰的成员变量，将不参与序列化</p><hr><h5 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h5><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p><p>作用：把内存中的 Java 对象数据保存到文件中去</p><p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建User用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;seazean&quot;</span>,<span class="string">&quot;980823&quot;</span>,<span class="string">&quot;七十一&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建低级的字节输出流通向目标文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.通过对象字节输出流序列化对象：</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">// 5.释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化对象成功~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">// get+set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化为二进制数据</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(obj);<span class="comment">// 将该对象序列化为二进制数据</span></span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] bytes = bos.toByteArray();</span><br></pre></td></tr></table></figure><hr><h5 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h5><p>对象反序列化（对象字节输入流）：ObjectInputStream</p><p>作用：读取序列化的对象文件恢复到 Java 对象中</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p><p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)ois.readObject();<span class="comment">//反序列化</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流 PrintStream &#x2F; PrintWriter</p><p>打印流的作用：</p><ul><li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li><li>PrintStream&#x2F;PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li><li><strong>System.out.print() 底层基于打印流实现的</strong></li></ul><p>构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><p>System 类：</p><ul><li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        ps.println(任何类型的数据);</span><br><span class="line">        ps.print(不换行);</span><br><span class="line">        ps.write(<span class="string">&quot;我爱你&quot;</span>.getBytes());</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean0==&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/log.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 让系统的输出流向打印流</span></span><br><span class="line"><span class="comment">//不输出在控制台，输出到文件里</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean1==&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean2==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><p>try-with-resources：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    <span class="comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span></span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p><p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"><span class="comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （2）创建一个字节输出流与目标文件接通。*/</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （5）关闭资源！是自动进行的 */</span></span><br><span class="line">)&#123;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p><p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p><p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key&#x3D;value</p><p>Properties 方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key, String value)</td><td>设置集合的键和值，底层调用 Hashtable 方法 put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String>   stringPropertyNames()</td><td>所有键的名称的集合</td></tr><tr><td>synchronized void load(Reader r)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>synchronized void load(InputStream in)</td><td>加载属性文件的数据到属性集对象中去</td></tr><tr><td>void store(Writer w, String comments)</td><td>将此属性列表(键和元素对)写入 Properties 表</td></tr><tr><td>void store(OutputStream os, String comments)</td><td>保存数据到属性文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.创建一个属性集对象：Properties的对象。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//&#123;&#125;</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span> , <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>);</span><br><span class="line">        properties.store(os,<span class="string">&quot;i am very happy!!我保存了用户数据!&quot;</span>);</span><br><span class="line">        <span class="comment">//参数一：被保存数据的输出管道</span></span><br><span class="line">        <span class="comment">//参数二：保存心得。就是对象保存的数据进行解释说明！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//底层基于map集合</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        </span><br><span class="line">Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(s);</span><br><span class="line">            System.out.println(s + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h3><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p><p>构造器：</p><ul><li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li><li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li></ul><p>常用方法：</p><ul><li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li><li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li><li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    rf.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">    rf.seek(<span class="number">5</span>);<span class="comment">//helloxxxxld</span></span><br><span class="line">    rf.write(<span class="string">&quot;xxxx&quot;</span>.getBytes());</span><br><span class="line">    rf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h3><p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p><p>commons-io 工具包提供了很多有关 IO 操作的类：</p><table><thead><tr><th>包</th><th align="left">功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td align="left">有关 Streams、Readers、Writers、Files 的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td align="left">输入流相关的实现类，包含 Reader 和 InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td align="left">输出流相关的实现类，包含 Writer 和 OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td align="left">序列化相关的类</td></tr></tbody></table><p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.完成文件复制！</span></span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>), </span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.完成文件复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyFileToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片服务器&quot;</span>) ,</span><br><span class="line">                                           <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span></span><br><span class="line">        Files.copy(Paths.get(<span class="string">&quot;Demo/src/books.xml&quot;</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new11.txt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p><p>单元测试：</p><ul><li>单元：在 Java 中，一个类就是一个单元</li><li>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试</li></ul><p></p><p>Junit 单元测试框架的作用：</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li><li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li></ul><p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p><p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p><ul><li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li><li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li></ul><p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p><ul><li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li><li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li></ul><p>作用：</p><ul><li>开始执行的方法：初始化资源</li><li>执行完之后的方法：释放资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">     <span class="comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">/**断言预期结果的正确性。</span></span><br><span class="line"><span class="comment">         * 参数一：测试失败的提示信息。</span></span><br><span class="line"><span class="comment">         * 参数二：期望值。</span></span><br><span class="line"><span class="comment">         * 参数三：实际值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="string">&quot;success&quot;</span>,rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.chu(<span class="number">10</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h3><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p><ul><li><p>构造器对象：Constructor</p></li><li><p>成员变量对象：Field</p></li><li><p>成员方法对象：Method</p></li></ul><p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p><p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p><ul><li><code>Class c = HelloWorld.class</code></li></ul><p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p><p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p><p>反射的优点：</p><ul><li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li></ul><p>反射的缺点：</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li><li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li><li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li></ul><hr><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h4><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p><ul><li>类名.class</li><li>类的对象.getClass()</li><li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li></ul><p>Class 类下的方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getSimpleName()</td><td>获得类名字符串：类名</td></tr><tr><td>String getName()</td><td>获得类全名：包名+类名</td></tr><tr><td>T newInstance()</td><td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span></span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class _03反射_获取Class类对象.Student</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> swk.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName(&quot;类的全限名&quot;)</span></span><br><span class="line">        <span class="comment">// 直接去加载该类的class文件。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;_03反射_获取Class类对象.Student&quot;</span>);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获取类名本身（简名）Student</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取类的全限名_03反射_获取Class类对象.Student</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h4><p>获取构造器的 API：</p><ul><li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li><li>Constructor getDeclaredConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li><li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li><li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li></ul><p>Constructor 的常用 API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>创建对象，注入构造器需要的数据</td></tr><tr><td>void setAccessible(true)</td><td>修改访问权限，true 攻破权限（暴力反射）</td></tr><tr><td>String getName()</td><td>以字符串形式返回此构造函数的名称</td></tr><tr><td>int getParameterCount()</td><td>返回参数数量</td></tr><tr><td>Class&lt;?&gt;[] getParameterTypes</td><td>返回参数类型数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位全部构造器，只要申明了就可以拿到</span></span><br><span class="line">        Constructor[] cons = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历这些构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor con : cons) &#123;</span><br><span class="line">            System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位某个构造器，根据参数匹配，只要申明了就可以获取</span></span><br><span class="line">        <span class="comment">//Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//有参数的！!</span></span><br><span class="line">        <span class="comment">// c.构造器名称和参数</span></span><br><span class="line">        System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用无参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位无参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// c.暴力打开私有构造器的访问权限</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// d.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(); <span class="comment">// 最终还是调用无参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用有参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位有参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class , <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// c.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>); <span class="comment">// 最终还是调用有参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><p>获取 Field 成员变量 API：</p><ul><li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li><li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li><li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li><li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到</li></ul><p>Field 的方法：给成员变量赋值和取值</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td></tr><tr><td>Object get(Object obj)</td><td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td></tr><tr><td>void setAccessible(true)</td><td>暴力反射，设置为可以直接访问私有类型的属性</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回 Class 对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo</span> &#123;</span><br><span class="line">    <span class="comment">//获取全部成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.获取全部申明的成员变量对象</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName()+<span class="string">&quot;-&gt;&quot;</span>+field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某个成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.定位某个成员变量对象 :根据名称定位！！</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(ageF.getName()+<span class="string">&quot;-&gt;&quot;</span>+ageF.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_1</span> <span class="operator">=</span> <span class="string">&quot;宠物学校&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射的第一步获取Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.定位name成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// c.为这个成员变量赋值！</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(d,<span class="string">&quot;泰迪&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;</span></span><br><span class="line">        <span class="comment">// d.获取成员变量的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> name.get(d)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(value);<span class="comment">//泰迪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>获取 Method 方法 API：</p><ul><li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li><li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li><li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li><li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li></ul><p>Method 常用 API：</p><ul><li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="comment">//获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.获取全部申明的方法!</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历这些方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    + method.getParameterCount()+<span class="string">&quot;-&gt;&quot;</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">// c.触发方法执行!</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> run.invoke(d);</span><br><span class="line">        System.out.println(o);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力反射！</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//参数一：被触发方法所在的对象  参数二：方法需要的入参值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> eat.invoke(d,<span class="string">&quot;肉&quot;</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span>&#123;System.out.println(<span class="string">&quot;狗吃&quot;</span>+name);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;在吉山区有一只单身狗！&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p><ol><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        scores.add(<span class="number">99.3</span>);</span><br><span class="line">        scores.add(<span class="number">199.3</span>);</span><br><span class="line">        scores.add(<span class="number">89.5</span>);</span><br><span class="line">        <span class="comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span></span><br><span class="line">        <span class="comment">// a.先得到集合对象的Class文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> scores.getClass();</span><br><span class="line">        <span class="comment">// b.从ArrayList的Class对象中定位add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        <span class="comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span></span><br><span class="line">        add.invoke(scores, <span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">        System.out.println(scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p><ul><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li><li><strong>父类中的注解是不能被子类继承的</strong></li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><hr><h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">     <span class="comment">// 注解属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解的格式：@注解名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Book</span></span><br><span class="line"><span class="meta">@MyTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBook</span> &#123;</span><br><span class="line">    <span class="comment">//方法变量都可以注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><h4 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h4><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p><p>属性的格式：</p><ul><li>格式 1：数据类型 属性名()</li><li>格式 2：数据类型 属性名() default 默认值</li></ul><p>属性适用的数据类型:</p><ul><li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li><li>以上类型的数组形式都支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span> &#123;</span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span></span><br><span class="line"><span class="meta">     price = 19.9 , address = &quot;北京&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义一个注解</span></span><br><span class="line"><span class="meta">@interface</span> MyBook&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String[] authors(); <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;武汉&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><p>注解的特殊属性名称：value</p><ul><li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li><li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Book(&quot;/deleteBook.action&quot;)</span></span><br><span class="line"><span class="meta">@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是 sun 公司提供的，用来注解自定义注解</p><p>元注解有四个：</p><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">    <span class="comment">// @MyTest // 只能注解方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 申明只能注解方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 申明注解从写代码一直到运行还在，永远存活！！</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>注解解析相关的接口：</p><ul><li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li><li>AnnotatedElement：该接口定义了与注解解析相关的方法</li><li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li></ul><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定位Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// 2.判断这个类上是否使用了某个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="comment">// 3.获取这个注解对象</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)c.getDeclarAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.authors()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)run.getDeclaredAnnotation(Book.class);</span><br><span class="line">           sout(上面的三个);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;波仔&quot;,&quot;波妞&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line">    <span class="meta">@Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;dlei&quot;,&quot;播客&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">// 类和成员方法上使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解永久存活</span></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] authors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="注解模拟"><a href="#注解模拟" class="headerlink" title="注解模拟"></a>注解模拟</h3><p>注解模拟写一个 Junit 框架的基本使用</p><ol><li>定义一个自定义注解 MyTest，只能注解方法，存活范围一直都在。</li><li>定义若干个方法，只要有 @MyTest 注解的方法就能被触发执行，没有这个注解的方法不能执行！！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;===test01===&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;===test02===&quot;</span>);&#125;</span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;===test03===&quot;</span>);&#125;</span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;===test04===&quot;</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TestDemo</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestDemo</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TestDemo.class;</span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">                method.invoke(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 只能注解方法！</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直都活着</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>XML介绍：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li><li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li><li>XML 标签没有被预定义，需要自行定义标签</li><li>XML 被设计为具有自我描述性，易于阅读</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的区别</strong>：</p><ul><li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li><li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li><li>HTML 旨在显示信息，而 XML 旨在传输信息</li></ul><hr><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>person.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;110&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="comment">&lt;!--年龄--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--姓名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>/&gt;</span><span class="comment">&lt;!--性别--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p><ul><li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p><ul><li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li><li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li><li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes&#x2F;no</li></ul></li><li><p><strong>元素</strong>        </p><ul><li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li><li>格式 2：<code>&lt;person/&gt;</code></li><li>普通元素的结构由开始标签、元素体、结束标签组成</li><li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;&#x2F;&gt;</li></ul></li><li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p><ul><li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li><li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li><li>必须存在一个根标签，有且只能有一个</li></ul></li><li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p><ul><li>属性是元素的一部分，它必须出现在元素的开始标签中</li><li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li><li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li><li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li></ul></li><li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p></li><li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p><table><thead><tr><th align="center">字符</th><th align="center">预定义的转义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center"><code> &amp;gt;</code></td><td align="center">大于</td></tr><tr><td align="center">“</td><td align="center"><code> &amp;quot;</code></td><td align="center">双引号</td></tr><tr><td align="center">‘</td><td align="center"><code> &amp;apos;</code></td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center"><code> &amp;amp;</code></td><td align="center">和号</td></tr></tbody></table></li><li><p><strong>字符区</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">文本数据</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><ul><li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li></ul></li><li><p>CDATA 部分由 “<![CDATA[" 开始，由 "]]>“ 结束；</p><ul><li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p></li><li><p>规则：</p><ul><li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li><li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;../css/xml.css&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.属性信息：id , desc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>32<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span></span><br><span class="line">        select * from student where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age <span class="symbol">&amp;gt;</span> 10;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符</span></span><br><span class="line"><span class="comment">        或者也可以选择使用字符数据区，里面的内容可以随便了！</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql2</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><h5 id="DTD-定义"><a href="#DTD-定义" class="headerlink" title="DTD 定义"></a>DTD 定义</h5><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p><p>DTD 规则：</p><ul><li><p>约束元素的嵌套层级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;</span><br></pre></td></tr></table></figure></li><li><p>约束元素体里面的数据</p></li><li><p>语法</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 标签名字 标签类型&gt;</span><br></pre></td></tr></table></figure></li><li><p>判断元素<br>     简单元素：没有子元素。<br>     复杂元素：有子元素的元素；</p><ul><li>标签类型</li></ul><table><thead><tr><th>标签类型</th><th>代码写法</th><th>说明</th></tr></thead><tbody><tr><td>PCDATA</td><td>(#PCDATA)</td><td>被解释的字符串数据</td></tr><tr><td>EMPTY</td><td>EMPTY</td><td>即空元素，例如&lt;hr&#x2F;&gt;</td></tr><tr><td>ANY</td><td>ANY</td><td>即任意类型</td></tr></tbody></table><ul><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;</span><br><span class="line">   &lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;</span><br><span class="line">   &lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;</span><br><span class="line">   &lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br></pre></td></tr></table></figure></li><li><p>数量词</p><table><thead><tr><th>数量词符号</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>表示元素出现一次</td></tr><tr><td>*</td><td>表示元素可以出现0到多个</td></tr><tr><td>+</td><td>表示元素可以出现至少1个</td></tr><tr><td>?</td><td>表示元素可以是0或1个</td></tr><tr><td>,</td><td>表示元素需要按照顺序显示</td></tr><tr><td>|</td><td>表示元素需要选择其中的某一个</td></tr></tbody></table></li></ul></li><li><p>属性声明</p><ul><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ATTLIST 标签名称 </span><br><span class="line">属性名称1 属性类型1 属性说明1</span><br><span class="line">属性名称2 属性类型2 属性说明2</span><br><span class="line">…</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性类型</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>CDATA</td><td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td></tr><tr><td>ID</td><td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td></tr><tr><td>ENUMERATED</td><td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td></tr></tbody></table></li><li><p>属性说明</p><table><thead><tr><th>属性说明</th><th>含义</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>代表属性是必须有的</td></tr><tr><td>#IMPLIED</td><td>代表属性可有可无</td></tr><tr><td>#FIXED</td><td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td></tr></tbody></table></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ATTLIST 书&lt;!--设置&quot;书&quot;元素的的属性列表--&gt;</span><br><span class="line">id ID #REQUIRED &lt;!--&quot;id&quot;属性值为必须有--&gt;</span><br><span class="line">编号 CDATA #IMPLIED    &lt;!--&quot;编号&quot;属性可有可无--&gt;</span><br><span class="line">出版社 (清华|北大|传智播客) &quot;传智播客&quot; &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“传智播客”--&gt;</span><br><span class="line">type CDATA #FIXED &quot;IT&quot;            &lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h5 id="DTD-引入"><a href="#DTD-引入" class="headerlink" title="DTD 引入"></a>DTD 引入</h5><ul><li><p>引入本地 dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径&#x27;&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 xml 文件内部引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 [ dtd文件内容 ]&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入网络 dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素的名称 PUBLIC &quot;DTD文件名称&quot; &quot;DTD文档的URL&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是persondtd.dtd文件中的内容,已经提前写好--&gt;</span><br><span class="line">&lt;!ELEMENT persons (person)&gt;</span><br><span class="line">&lt;!ELEMENT person (name,age)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入本地DTD--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">persons</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;persondtd.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--内部引入DTD--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE persons [</span><br><span class="line">        &lt;!ELEMENT persons (person)&gt;</span><br><span class="line">        &lt;!ELEMENT person (name,age)&gt;</span><br><span class="line">        &lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">        ]&gt;</span><br><span class="line"></span><br><span class="line">&lt;persons&gt;</span><br><span class="line">    &lt;person&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入网络DTD--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE persons PUBLIC &quot;dtd文件的名称&quot; &quot;dtd文档的URL&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;persons&gt;</span><br><span class="line">    &lt;person&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="DTD-实现"><a href="#DTD-实现" class="headerlink" title="DTD 实现"></a>DTD 实现</h5><p>persondtd.dtd 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;</span><br><span class="line">&lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;</span><br><span class="line">&lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE persons SYSTEM &#x27;persondtd.dtd&#x27;&gt;</span><br><span class="line"></span><br><span class="line">&lt;persons&gt;</span><br><span class="line">    &lt;person id=&quot;001&quot;&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">    &lt;person id = &quot;002&quot;&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><h5 id="XSD-定义"><a href="#XSD-定义" class="headerlink" title="XSD 定义"></a>XSD 定义</h5><ol><li>Schema 语言也可作为 XSD（XML Schema Definition）</li><li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li><li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li><li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li><li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li></ol><hr><h5 id="XSD-规则"><a href="#XSD-规则" class="headerlink" title="XSD 规则"></a>XSD 规则</h5><ol><li>创建一个文件，这个文件的后缀名为 .xsd</li><li>定义文档声明</li><li>schema 文件的根标签为： <schema></li><li>在 <schema> 中定义属性：<ul><li>xmlns&#x3D;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li><li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li></ul></li><li>在<schema>中定义属性 ：<ul><li>targetNamespace &#x3D; 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li><li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li></ul></li><li>在<schema>中定义属性 ：<ul><li>elementFormDefault&#x3D;”qualified“，表示当前 schema 文件是一个质量良好的文件。</li></ul></li><li>通过 element 定义元素</li><li><strong>判断当前元素是简单元素还是复杂元素</strong></li></ol><p>person.xsd</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;</span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;</span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span>  &lt;!--本文件是质量好的--&gt;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;      &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">        &lt;complexType&gt;             &lt;!--复杂的元素--&gt;</span><br><span class="line">            &lt;sequence&gt;  &lt;!--里面的元素必须按照顺序定义--&gt;</span><br><span class="line">                &lt;element name = <span class="string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="XSD-引入"><a href="#XSD-引入" class="headerlink" title="XSD 引入"></a>XSD 引入</h5><ol><li>在根标签上定义属性 xmlns&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a></li><li><strong>通过 xmlns 引入约束文件的名称空间</strong></li><li>给某一个 xmlns 属性添加一个标识，用于区分不同的名称空间，格式为 <code>xmlns:标识=&quot;名称空间url&quot;</code> ，标识可以是任意的，但是一般取值都是 xsi</li><li>通过 xsi:schemaLocation 指定名称空间所对应的约束文件路径，格式为 <code>xsi:schemaLocation = &quot;名称空间url 文件路径</code></li></ol><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;persons</span><br><span class="line">xmlms:xis=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> &lt;!--被别人约束--&gt;</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>                  &lt;!--约束文件的名称空间--&gt;</span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"> &lt;person&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="XSD-属性"><a href="#XSD-属性" class="headerlink" title="XSD 属性"></a>XSD 属性</h5><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span></span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;</span><br><span class="line">        &lt;complexType&gt;</span><br><span class="line">            &lt;sequence&gt;</span><br><span class="line">                &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                &lt;element name = <span class="string">&quot;person&quot;</span>&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                        &lt;!--定义的位置是sequence的外面，complexType的里面--&gt;</span><br><span class="line">                        &lt;!--定义属性，required( 必须的)/optional( 可选的)--&gt;</span><br><span class="line">                        &lt;attribute name=<span class="string">&quot;id&quot;</span> type=<span class="string">&quot;string&quot;</span> use=<span class="string">&quot;required&quot;</span>&gt;</span><br><span class="line">&lt;/attribute&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                    </span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;persons</span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xmlns=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">    &lt;person id=<span class="string">&quot;001&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h3><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p><p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p><p>Dom4J 实现：</p><ul><li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p></li><li><p>SAXReader 常用 API：</p><ul><li><code>public Document read(File file)</code>：Reads a Document from the given File</li><li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li></ul></li><li><p>Java Class 类 API：</p><ul><li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li></ul></li></ul><hr><h4 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h4><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span></span><br><span class="line">        <span class="comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span></span><br><span class="line">        <span class="comment">// 这里的“/”是直接去src类路径下寻找文件。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="string">&quot;/books.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        System.out.println(document);</span><br><span class="line"><span class="comment">//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]</span></span><br><span class="line"><span class="comment">// 4.从document文档树对象中提取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());<span class="comment">//books</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0001&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一本书&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>  JavaWeb开发教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>    张孝祥<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元   <span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元<span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h4><p>Element 元素的 API:</p><ul><li>String getName()：取元素的名称。</li><li>List<Element> elements()：获取当前元素下的全部子元素（一级）</li><li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</li><li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.获取根元素下的全部子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements = root.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.获取根源下的全部book子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements1 = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements1) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.获取根源下的指定的某个元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(son.getName());</span><br><span class="line">        <span class="comment">// 默认会提取第一个名称一样的子元素对象返回！</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son1</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(son1.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Element 元素的 API：</p><ul><li>List<Attribute> attributes()：获取元素的全部属性对象</li><li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li><li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li></ul><p>Attribute 对象的 API：</p><ul><li>String getName()：获取属性名称</li><li>String getValue()：获取属性值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.获取book子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取book元素的全部属性对象</span></span><br><span class="line">        List&lt;Attribute&gt; attributes = bookEle.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName()+<span class="string">&quot;-&gt;&quot;</span>+attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.获取Book元素的某个属性对象</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">descAttr</span> <span class="operator">=</span> bookEle.attribute(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(descAttr.getName()+<span class="string">&quot;-&gt;&quot;</span>+descAttr.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.可以直接获取元素的属性值</span></span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;desc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>Element：</p><ul><li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li><li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li><li>String getText()：直接获取当前元素的文本内容</li><li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.得到第一个子元素book</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.直接拿到当前book元素下的子元素文本值</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;author&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;sale&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;sale&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.先获取到子元素对象，再获取该文本值</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookNameEle</span> <span class="operator">=</span> bookEle.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(bookNameEle.getText());</span><br><span class="line">        System.out.println(bookNameEle.getTextTrim());<span class="comment">// 去前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p><p>XPath 常用API：</p><ul><li>List<Node> selectNodes(String var1) : 检索出一批节点集合</li><li>Node selectSingleNode(String var1) : 检索出一个节点返回</li></ul><p>XPath 提供的四种检索数据的写法：</p><ol><li>绝对路径：&#x2F;根元素&#x2F;子元素&#x2F;子元素</li><li>相对路径：.&#x2F;子元素&#x2F;子元素 (.代表了当前元素)</li><li>全文搜索：<ul><li>&#x2F;&#x2F;元素：在全文找这个元素</li><li>&#x2F;&#x2F;元素1&#x2F;元素2：在全文找元素1下面的一级元素 2</li><li>&#x2F;&#x2F;元素1&#x2F;&#x2F;元素2：在全文找元素1下面的全部元素 2</li></ul></li><li>属性查找：<ul><li>&#x2F;&#x2F;@属性名称：在全文检索属性对象</li><li>&#x2F;&#x2F;元素[@属性名称]：在全文检索包含该属性的元素对象</li><li>&#x2F;&#x2F;元素[@属性名称&#x3D;值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contact.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        <span class="comment">//1.使用绝对路径定位全部的name名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            System.out.println(nameNode.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.相对路径。从根元素开始检索，.代表很根元素</span></span><br><span class="line">        List&lt;Node&gt; nameNodes2 = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.1 在全文中检索name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//name&quot;</span>);<span class="comment">//全部的</span></span><br><span class="line">        <span class="comment">//3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="comment">//3.3 在全文中检索所有contact下的直接name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact/name&quot;</span>);<span class="comment">//不包括sql和外面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1 检索全部属性对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//@id&quot;</span>);<span class="comment">//包括sql4</span></span><br><span class="line">        <span class="comment">//4.2 在全文检索包含该属性的元素对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//contact[@id]&quot;</span>);</span><br><span class="line">        <span class="comment">//4.3 在全文检索包含该属性的元素且属性值为该值的元素对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeEle</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//contact[@id=2]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element)nodeEle;</span><br><span class="line">        System.out.println(ele.elementTextTrim(<span class="string">&quot;name&quot;</span>));<span class="comment">//xi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小白<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>bai@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小黑<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hei@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sql4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小虎<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hu@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>外面的名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><hr><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p><ul><li><p>静态变量的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决序列化问题</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p></li><li><p>防止反序列化破坏单例的方式：</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private&#x2F;protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p></li><li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p></li><li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p></li></ul></li><li><p>静态代码块的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.INSTANCE.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Singleton&gt; &#123; <span class="comment">// Enum实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li><p>线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><hr><h4 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p><ul><li><p>Singleton</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化接口</span></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h5><ul><li><p>反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 反射破解单例模式需要添加的代码</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>Runtime 类就是使用的单例设计模式中的饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> currentRuntime;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代售点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><hr><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"><span class="comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用 Proxy 获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//必须时代理ji</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);<span class="comment">//InvocationHandler对象传递给父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><hr><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span>&#123;</span><br><span class="line">    <span class="comment">// InvocationHandler 为空则抛出异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一份 interfaces</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置可访问的权限</span></span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 的静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类型的名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：Proxy.newInstance 时传递的</span></span><br><span class="line">    <span class="comment">//参数二：Proxy.newInstance 时传递的接口集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 遍历接口集合</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载接口类到 JVM</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证接口 interfaces 集合中没有重复的接口</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">        <span class="comment">// 【生成的代理类访问修饰符 public final】 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span></span><br><span class="line">        <span class="comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 获取访问修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取当前接口的全限定名 包名.类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="comment">// 获取包名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取唯一的编号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// 包名+ $proxy + 数字，比如 $proxy1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代理工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//因为返回值为void</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><hr><h4 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h4><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h3&gt;&lt;h4 id=&quot;变量类型&quot;&gt;&lt;a href=&quot;#变量类型&quot; class=&quot;headerlink&quot; title=&quot;变量类型&quot;&gt;&lt;/a&gt;变量类型&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://example.com/categories/Java/JavaSE/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2022/08/16/JVM/"/>
    <id>http://example.com/2022/08/16/JVM/</id>
    <published>2022-08-16T11:06:36.440Z</published>
    <updated>2022-08-17T12:21:06.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作</p><p>特点：</p><ul><li>Java 虚拟机基于<strong>二进制字节码</strong>执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><p>Java 代码执行流程：<code>Java 程序 --（编译）--&gt; 字节码文件 --（解释执行）--&gt; 操作系统（Win，Linux）</code></p><p>JVM 结构：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-概述图.png" style="zoom: 80%;" /><p>JVM、JRE、JDK 对比：</p><ul><li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li><li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-JRE关系.png" style="zoom: 80%;" /><p>参考书籍：<a href="https://book.douban.com/subject/34907497/">https://book.douban.com/subject/34907497/</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1yE411Z7AP">https://www.bilibili.com/video/BV1yE411Z7AP</a></p><hr><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p><ul><li>基于栈式架构的特点：<ul><li>设计和实现简单，适用于资源受限的系统</li><li>使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现<ul><li>零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器</li><li>一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数</li></ul></li><li>不需要硬件的支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点：<ul><li>需要硬件的支持，可移植性差</li><li>性能更好，执行更高效，寄存器比内存快</li><li>以一地址指令、二地址指令、三地址指令为主</li></ul></li></ul><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡</p><ul><li><p><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</p></li><li><p><strong>运行</strong>：</p><ul><li><p>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</p></li><li><p>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，<strong>JVM 使用的是守护线程，main() 和其他线程使用的是用户线程</strong>，守护线程会随着用户线程的结束而结束</p></li><li><p>执行一个 Java 程序时，真真正正在执行的是一个 <strong>Java 虚拟机的进程</strong></p></li><li><p>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</p><p>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</p></li></ul></li><li><p><strong>死亡</strong>：</p><ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><hr><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h3><p>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</p><p>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行</p><ul><li><p>Java1.8 以前的内存结构图：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java7%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li><li><p>Java1.8 之后的内存结果图：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><p>线程运行诊断：</p><ul><li>定位：jps 定位进程 ID</li><li>jstack 进程 ID：用于打印出给定的 Java 进程 ID 或 core file 或远程调试服务的 Java 堆栈信息</li></ul><p>常见 OOM 错误：</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><h3 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><h5 id="Java-栈"><a href="#Java-栈" class="headerlink" title="Java 栈"></a>Java 栈</h5><p>Java 虚拟机栈：Java Virtual Machine Stacks，<strong>每个线程</strong>运行时所需要的内存</p><ul><li><p>每个方法被执行时，都会在虚拟机栈中创建一个栈帧 stack frame（<strong>一个方法一个栈帧</strong>）</p></li><li><p>Java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的</strong></p></li><li><p>虚拟机栈是<strong>每个线程私有的</strong>，每个线程只能有一个活动栈帧，对应方法调用到执行完成的整个过程</p></li><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，每个栈帧中存储着：</p><ul><li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的定义</li><li>操作数栈或表达式栈和其他一些附加信息</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚拟机栈.png" style="zoom:50%;" /></li></ul><p>设置栈内存大小：<code>-Xss size</code>   <code>-Xss 1024k</code></p><ul><li>在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</li></ul><p>虚拟机栈特点：</p><ul><li><p>栈内存<strong>不需要进行GC</strong>，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</p></li><li><p>栈内存分配越大越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）</p></li><li><p>方法内的局部变量是否<strong>线程安全</strong>：</p><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>异常：</p><ul><li>栈帧过多导致栈内存溢出 （超过了栈的容量），会抛出 OutOfMemoryError 异常</li><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常</li></ul><hr><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量表也被称之为局部变量数组或本地变量表，本质上定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p><ul><li>表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li><li>表的容量大小是在编译期确定的，保存在方法的 Code 属性的 maximum local variables 数据项中</li><li>表中的变量只在当前方法调用中有效，方法结束栈帧销毁，局部变量表也会随之销毁</li><li>表中的变量也是重要的垃圾回收根节点，只要被表中数据直接或间接引用的对象都不会被回收</li></ul><p>局部变量表最基本的存储单元是 <strong>slot（变量槽）</strong>：</p><ul><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束，JVM 为每一个 slot 都分配一个访问索引，通过索引即可访问到槽中的数据</li><li>存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress 类型的变量</li><li>32 位以内的类型只占一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占两个 slot</li><li>局部变量表中的槽位是可以<strong>重复利用</strong>的，如果一个局部变量过了其作用域，那么之后申明的新的局部变量就可能会复用过期局部变量的槽位，从而达到节省资源的目的</li></ul><hr><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>栈：可以使用数组或者链表来实现</p><p>操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</p><ul><li><p>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，是执行引擎的一个工作区</p></li><li><p>Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p></li><li><p>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈中</strong></p></li></ul><p>栈顶缓存技术 ToS（Top-of-Stack Cashing）：将栈顶元素全部缓存在 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行的效率</p><p>基于栈式架构的虚拟机使用的零地址指令更加紧凑，完成一项操作需要使用很多入栈和出栈指令，所以需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数，由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度，所以需要栈顶缓存技术</p><hr><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接是指向运行时常量池的方法引用，涉及到栈操作已经是类加载完成，这个阶段的解析是<strong>动态绑定</strong></p><ul><li><p>为了支持当前方法的代码能够实现动态链接，每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.png"></p></li><li><p>在 Java 源文件被编译成的字节码文件中，所有的变量和方法引用都作为符号引用保存在 class 的常量池中</p><p>常量池的作用：提供一些符号和常量，便于指令的识别</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png"></p></li></ul><hr><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><p>Return Address：存放调用该方法的 PC 寄存器的值</p><p>方法的结束有两种方式：正常执行完成、出现未处理的异常，在方法退出后都返回到该方法被调用的位置</p><ul><li>正常：调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的<strong>下一条指令的地址</strong></li><li>异常：返回地址是要通过异常表来确定</li></ul><p>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者</p><p>异常完成出口：方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，本方法的异常表中没有搜素到匹配的异常处理器，导致方法退出</p><p>两者区别：通过异常完成出口退出的不会给上层调用者产生任何的返回值</p><h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p><hr><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈是为虚拟机执行本地方法时提供服务的</p><p>JNI：Java Native Interface，通过使用 Java 本地接口书写程序，可以确保代码在不同的平台上方便移植</p><ul><li><p>不需要进行 GC，与虚拟机栈类似，也是线程私有的，有 StackOverFlowError 和 OutOfMemoryError 异常</p></li><li><p>虚拟机栈执行的是 Java 方法，在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li><li><p>本地方法一般是由其他语言编写，并且被编译为基于本机硬件和操作系统的程序</p></li><li><p>当某个线程调用一个本地方法时，就进入了不再受虚拟机限制的世界，和虚拟机拥有同样的权限</p><ul><li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong></li><li>直接从本地内存的堆中分配任意数量的内存</li><li>可以直接使用本地处理器中的寄存器</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-本地方法栈.png" style="zoom:67%;" /></li></ul><p>图片来源：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a></p><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Program Counter Register 程序计数器（寄存器）</p><p>作用：内部保存字节码的行号，用于记录正在执行的字节码指令地址（如果正在执行的是本地方法则为空）</p><p>原理：</p><ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul><p>特点：</p><ul><li>是线程私有的</li><li><strong>不会存在内存溢出</strong>，是 JVM 规范中唯一一个不出现 OOM 的区域，所以这个空间不会进行 GC</li></ul><p>Java 反编译指令：<code>javap -v Test.class</code></p><p>#20：代表去 Constant pool 查看该地址的指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out;</span></span><br><span class="line"><span class="number">3</span>: astore_1 <span class="comment">// --</span></span><br><span class="line"><span class="number">4</span>: aload_1 <span class="comment">// out.println(1);</span></span><br><span class="line"><span class="number">5</span>: iconst_1 <span class="comment">// --</span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">9</span>: aload_1 <span class="comment">// out.println(2);</span></span><br><span class="line"><span class="number">10</span>: iconst_2 <span class="comment">// --</span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br></pre></td></tr></table></figure><hr><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题</p><p>存放哪些资源：</p><ul><li>对象实例：类初始化生成的对象，<strong>基本数据类型的数组也是对象实例</strong>，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放于方法区，JDK7 开始放置于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li></ul><p>设置堆内存指令：<code>-Xmx Size</code></p><p>内存溢出：new 出对象，循环添加字符数据，当堆中没有内存空间可分配给实例，也无法再扩展时，就会抛出 OutOfMemoryError 异常</p><p>堆内存诊断工具：（控制台命令）</p><ol><li>jps：查看当前系统中有哪些 Java 进程</li><li>jmap：查看堆内存占用情况 <code>jhsdb jmap --heap --pid 进程id</code></li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测</li></ol><p>在 Java7 中堆内会存在<strong>年轻代、老年代和方法区（永久代）</strong>：</p><ul><li>Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区。Survivor 区某一时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。在 Eden 区变满的时候，GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间</li><li>Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区</li><li>Perm 代主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理</li></ul><p>分代原因：不同对象的生命周期不同，70%-99% 的对象都是临时对象，优化 GC 性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机使用的最大堆内存量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xms : 245M</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xmx : 3641M</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区：是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</p><p>方法区是一个 JVM 规范，<strong>永久代与元空间都是其一种实现方式</strong></p><p>方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)</p><p>方法区的 GC：针对常量池的回收及对类型的卸载，比较难实现</p><p>为了<strong>避免方法区出现 OOM</strong>，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，<strong>静态变量和字符串常量池等放入堆中</strong></p><p>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p><p>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了<strong>类在编译期间生成的字面量、符号引用</strong>，JVM 为每个已加载的类维护一个常量池</p><ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul><p>运行时常量池是方法区的一部分</p><ul><li>常量池（编译器生成的字面量和符号引用）中的数据会在类加载的加载阶段放入运行时常量池</li><li>类在解析阶段将这些符号引用替换成直接引用</li><li>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</li></ul><hr><h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>虚拟机内存：Java 虚拟机在执行的时候会把管理的内存分配成不同的区域，受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报 OOM</p><p>本地内存：又叫做<strong>堆外内存</strong>，线程共享的区域，本地内存这块区域是不会受到 JVM 的控制的，不会发生 GC；因此对于整个 Java 的执行效率是提升非常大，但是如果内存的占用超出物理内存的大小，同样也会报 OOM</p><p>本地内存概述图：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-内存图对比.png" style="zoom: 67%;" /><hr><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>PermGen 被元空间代替，永久代的<strong>类信息、方法、常量池</strong>等都移动到元空间区</p><p>元空间与永久代区别：元空间不在虚拟机中，使用的本地内存，默认情况下，元空间的大小仅受本地内存限制</p><p>方法区内存溢出：</p><ul><li><p>JDK1.8 以前会导致永久代内存溢出：java.lang.OutOfMemoryError: PerGen space</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 以后会导致元空间内存溢出：java.lang.OutOfMemoryError: Metaspace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li></ul><p>元空间内存溢出演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_8</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Demo1_8</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1_8</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域</p><p>直接内存详解参考：NET → NIO → 直接内存</p><hr><h3 id="变量位置"><a href="#变量位置" class="headerlink" title="变量位置"></a>变量位置</h3><p>变量的位置不取决于它是基本数据类型还是引用数据类型，取决于它的<strong>声明位置</strong></p><p>静态内部类和其他内部类：</p><ul><li><p><strong>一个 class 文件只能对应一个 public 类型的类</strong>，这个类可以有内部类，但不会生成新的 class 文件</p></li><li><p>静态内部类属于类本身，加载到方法区，其他内部类属于内部类的属性，加载到堆（待考证）</p></li></ul><p>类变量：</p><ul><li>类变量是用 static 修饰符修饰，定义在方法外的变量，随着 Java 进程产生和销毁</li><li>在 Java8 之前把静态变量存放于方法区，在 Java8 时存放在堆中的静态变量区</li></ul><p>实例变量：</p><ul><li>实例（成员）变量是定义在类中，没有 static 修饰的变量，随着类的实例产生和销毁，是类实例的一部分</li><li>在类初始化的时候，从运行时常量池取出直接引用或者值，<strong>与初始化的对象一起放入堆中</strong></li></ul><p>局部变量：</p><ul><li>局部变量是定义在类的方法中的变量</li><li>在所在方法被调用时<strong>放入虚拟机栈的栈帧</strong>中，方法执行结束后从虚拟机栈中弹出，</li></ul><p>类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？</p><ul><li>类常量池与运行时常量池都存储在方法区，而字符串常量池在 Jdk7 时就已经从方法区迁移到了 Java 堆中</li><li>在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符</li><li><strong>在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池</strong></li><li>对于文本字符，会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池</li></ul><p>什么是字面量？什么是符号引用？</p><ul><li><p>字面量：java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这个1便是字面量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;iloveu&quot;</span>;<span class="comment">//iloveu便是字面量</span></span><br></pre></td></tr></table></figure></li><li><p>符号引用：在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址</p></li></ul><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h4><p>不分配内存的对象无法进行其他操作，JVM 为对象分配内存的过程：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象</p><ul><li>如果内存规整，使用指针碰撞（Bump The Pointer）。所有用过的内存在一边，空闲的内存在另外一边，中间有一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离</li><li>如果内存不规整，虚拟机需要维护一个空闲列表（Free List）分配。已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li></ul><hr><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做<strong>快速分配策略</strong></p><ul><li>栈上分配使用的是栈来进行对象内存的分配</li><li>TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存</li></ul><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p><p>问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpg"></p><p>JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在堆中分配内存</p><p>栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存</p><p>参数设置：</p><ul><li><p><code>-XX:UseTLAB</code>：设置是否开启 TLAB 空间</p></li><li><p><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%</p></li><li><p><code>-XX:TLABRefillWasteFraction</code>：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg"></p><hr><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>即时编译（Just-in-time Compilation，JIT）是一种通过在运行时将字节码翻译为机器码，从而改善性能的技术，在 HotSpot 实现中有多种选择：C1、C2 和 C1+C2，分别对应 Client、Server 和分层编译</p><ul><li>C1 编译速度快，优化方式比较保守；C2 编译速度慢，优化方式比较激进</li><li>C1+C2 在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译</li></ul><p>逃逸分析并不是直接的优化手段，而是一个代码分析方式，通过动态分析对象的作用域，为优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸</p><ul><li>方法逃逸：当一个对象在方法中定义之后，被外部方法引用<ul><li>全局逃逸：一个对象的作用范围逃出了当前方法或者当前线程，比如对象是一个静态变量、全局变量赋值、已经发生逃逸的对象、作为当前方法的返回值</li><li>参数逃逸：一个对象被作为方法参数传递或者被参数引用</li></ul></li><li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li></ul><p>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配</p><ul><li><p>同步消除</p><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的<strong>同步锁</strong>，通过 <code>-XX:+EliminateLocks</code> 可以开启同步消除 ( - 号关闭)</p></li><li><p>标量替换</p><ul><li><p>标量替换：如果把一个对象拆散，将其成员变量恢复到基本类型来访问</p></li><li><p>标量 (scalar) ：不可分割的量，如基本数据类型和 reference 类型</p><p>聚合量 (Aggregate)：一个数据可以继续分解，对象一般是聚合量</p></li><li><p>如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替</p></li><li><p>参数设置：</p><ul><li><code>-XX:+EliminateAllocations</code>：开启标量替换</li><li><code>-XX:+PrintEliminateAllocations</code>：查看标量替换情况</li></ul></li></ul></li><li><p>栈上分配</p><p>JIT 编译器在编译期间根据逃逸分析的结果，如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需 GC</p><p>User 对象的作用域局限在方法 fn 中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会生成 User 对象，大大减轻 GC 的压力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">//warm up</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count ; i++) &#123;</span><br><span class="line">            sum += fn(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(age);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> user.getAge();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><h5 id="分代介绍"><a href="#分代介绍" class="headerlink" title="分代介绍"></a>分代介绍</h5><p>Java8 时，堆被分为了两份：新生代和老年代（1:2），在 Java7 时，还存在一个永久代</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><p><strong>Minor GC 和 Full GC</strong>：</p><ul><li>Minor GC：回收新生代，新生代对象存活时间很短，所以 Minor GC 会频繁执行，执行的速度比较快</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，所以 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li></ul><p> Eden 和 Survivor 大小比例默认为 8:1:1</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-分代收集算法.png" style="zoom: 67%;" /><hr><h5 id="分代分配"><a href="#分代分配" class="headerlink" title="分代分配"></a>分代分配</h5><p>工作机制：</p><ul><li><strong>对象优先在 Eden 分配</strong>：当创建一个对象的时候，对象会被分配在新生代的 Eden 区，当 Eden 区要满了时候，触发 YoungGC</li><li>当进行 YoungGC 后，此时在 Eden 区存活的对象被移动到 to 区，并且当前对象的年龄会加 1，清空 Eden 区</li><li>当再一次触发 YoungGC 的时候，会把 Eden 区中存活下来的对象和 to 中的对象，移动到 from 区中，这些对象的年龄会加 1，清空 Eden 区和 to 区</li><li>To 区永远是空 Survivor 区，From 区是有数据的，每次 MinorGC 后两个区域互换</li><li>From 区和 To 区 也可以叫做 S0 区和 S1 区</li></ul><p>晋升到老年代：</p><ul><li><p><strong>长期存活的对象进入老年代</strong>：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p><p><code>-XX:MaxTenuringThreshold</code>：定义年龄的阈值，对象头中用 4 个 bit 存储，所以最大值是 15，默认也是 15</p></li><li><p><strong>大对象直接进入老年代</strong>：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象</p><p><code>-XX:PretenureSizeThreshold</code>：大于此值的对象直接在老年代分配</p></li><li><p><strong>动态对象年龄判定</strong>：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p></li></ul><p>空间分配担保：</p><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</li><li>如果不成立，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC；如果小于或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC</li></ul><hr><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>内存垃圾回收机制主要集中的区域就是线程共享区域：<strong>堆和方法区</strong></p><p>Minor GC 触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</p><p>FullGC 同时回收新生代、老年代和方法区，只会存在一个 FullGC 的线程进行执行，其他的线程全部会被<strong>挂起</strong>，有以下触发条件：</p><ul><li><p>调用 System.gc()：</p><ul><li>在默认情况下，通过 System.gc() 或 Runtime.getRuntime().gc() 的调用，会显式触发 FullGC，同时对老年代和新生代进行回收，但是虚拟机不一定真正去执行，无法保证对垃圾收集器的调用</li><li>不建议使用这种方式，应该让虚拟机管理内存。一般情况下，垃圾回收应该是自动进行的，无须手动触发；在一些特殊情况下，如正在编写一个性能基准，可以在运行之间调用 System.gc()</li></ul></li><li><p>老年代空间不足：</p><ul><li>为了避免引起的 Full GC，应当尽量不要创建过大的对象以及数组</li><li>通过 -Xmn 参数调整新生代的大小，让对象尽量在新生代被回收掉不进入老年代，可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</li></ul></li><li><p>空间分配担保失败</p></li><li><p>JDK 1.7 及以前的永久代（方法区）空间不足</p></li><li><p>Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p></li></ul><p>手动 GC 测试，VM参数：<code>-XX:+PrintGcDetails</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">    System.gc();<span class="comment">//输出: 不会被回收, FullGC时被放入老年代</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    buffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc();<span class="comment">//输出: 正常被回收</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     System.gc();<span class="comment">//输出: 不会被回收, FullGC时被放入老年代</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.gc();<span class="comment">//输出: 正常被回收，slot复用，局部变量过了其作用域 buffer置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点 (Safepoint)：程序执行时并非在所有地方都能停顿下来开始 GC，只有在安全点才能停下</p><ul><li>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题</li><li>大部分指令的执行时间都非常短，通常会根据是否具有让程序长时间执行的特征为标准，选择些执行时间较长的指令作为 Safe Point， 如方法调用、循环跳转和异常跳转等</li></ul><p>在 GC 发生时，让所有线程都在最近的安全点停顿下来的方法：</p><ul><li>抢先式中断：没有虚拟机采用，首先中断所有线程，如果有线程不在安全点，就恢复线程让线程运行到安全点</li><li>主动式中断：设置一个中断标志，各个线程运行到各个 Safe Point 时就轮询这个标志，如果中断标志为真，则将自己进行中断挂起</li></ul><p>问题：Safepoint 保证程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但是当线程处于 Waiting 状态或 Blocked 状态，线程无法响应 JVM 的中断请求，运行到安全点去中断挂起，JVM 也不可能等待线程被唤醒，对于这种情况，需要安全区域来解决</p><p>安全区域 (Safe Region)：指在一段代码片段中，<strong>对象的引用关系不会发生变化</strong>，在这个区域中的任何位置开始 GC 都是安全的</p><p>运行流程：</p><ul><li><p>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</p></li><li><p>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了则继续运行，否则线程必须等待 GC 完成，收到可以安全离开 SafeRegion 的信号</p></li></ul><hr><h3 id="垃圾判断"><a href="#垃圾判断" class="headerlink" title="垃圾判断"></a>垃圾判断</h3><h4 id="垃圾介绍"><a href="#垃圾介绍" class="headerlink" title="垃圾介绍"></a>垃圾介绍</h4><p>垃圾：<strong>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</strong></p><p>作用：释放没用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象</p><p>垃圾收集主要是针对堆和方法区进行，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段，判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></p><hr><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</p><p>优点：</p><ul><li>回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收</li><li>在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象</li></ul><p>缺点：</p><ul><li><p>每次对象被引用时，都需要去更新计数器，有一点时间开销</p></li><li><p>浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。</p></li><li><p><strong>无法解决循环引用问题，会引发内存泄露</strong>（最大的缺点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">// a = 1</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">// b = 1</span></span><br><span class="line">        a.instance = b;<span class="comment">// b = 2</span></span><br><span class="line">        b.instance = a;<span class="comment">// a = 2</span></span><br><span class="line">        a = <span class="literal">null</span>;<span class="comment">// a = 1</span></span><br><span class="line">        b = <span class="literal">null</span>;<span class="comment">// b = 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"></p><hr><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p><p>GC Roots 对象：</p><ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li></ul><p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</p><hr><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象</p><p>分析工作必须在一个保障<strong>一致性的快照</strong>中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因</p><p>基本原理：</p><ul><li><p>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p></li><li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p></li><li><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-可达性分析算法.png" style="zoom: 50%;" /></li></ul><hr><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><h6 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h6><p>三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：</p><ul><li>白色：尚未访问过</li><li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li><li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li></ul><p>当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：</p><ol><li>初始时，所有对象都在白色集合</li><li>将 GC Roots 直接引用到的对象挪到灰色集合</li><li>从灰色集合中获取对象：<ul><li>将本对象引用到的其他对象全部挪到灰色集合中</li><li>将本对象挪到黑色集合里面</li></ul></li><li>重复步骤 3，直至灰色集合为空时结束</li><li>结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收</li></ol><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法过程.gif" style="zoom: 67%;" /><p>参考文章：<a href="https://www.jianshu.com/p/12544c0ad5c1">https://www.jianshu.com/p/12544c0ad5c1</a></p><hr><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生</p><p><strong>多标情况：</strong>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为<strong>浮动垃圾</strong></p><ul><li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li><li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法多标情况.png" style="zoom: 50%;" /><p><strong>漏标情况：</strong></p><ul><li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li><li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li><li>结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法漏标情况.png" style="zoom:50%;" /><p>代码角度解释漏标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">G</span> <span class="operator">=</span> objE.fieldG; <span class="comment">// 读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 写</span></span><br></pre></td></tr></table></figure><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p><blockquote><p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p></blockquote><p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p><ul><li><p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描</p><p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p><p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p></li><li><p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p><p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了，并且原始快照中本来就应该是灰色对象），最后重新扫描该对象的引用关系</p><p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p></li><li><p>**读屏障 (Load Barrier)**：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p></li></ul><p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p><ul><li>CMS：写屏障 + 增量更新</li><li>G1：写屏障 + SATB</li><li>ZGC：读屏障</li></ul><hr><h4 id="finalization"><a href="#finalization" class="headerlink" title="finalization"></a>finalization</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p><p>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</p><p>生存 OR 死亡：如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用，此对象需要被回收。但事实上这时候它们暂时处于缓刑阶段。<strong>一个无法触及的对象有可能在某个条件下复活自己</strong>，所以虚拟机中的对象可能的三种状态：</p><ul><li>可触及的：从根节点开始，可以到达这个对象</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活</li><li>不可触及的：对象的 finalize() 被调用并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 <strong>finalize() 只会被调用一次</strong>，等到这个对象再被标记为可回收时就必须回收</li></ul><p>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用，原因：</p><ul><li>finalize() 时可能会导致对象复活</li><li>finalize() 方法的执行时间是没有保障的，完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li><li>一个糟糕的 finalize() 会严重影响 GC 的性能</li></ul><hr><h4 id="引用分析"><a href="#引用分析" class="headerlink" title="引用分析"></a>引用分析</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关，Java 提供了四种强度不同的引用类型</p><ol><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致<strong>内存泄漏</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//使用 new 一个新对象的方式来创建强引用</span></span><br></pre></td></tr></table></figure></li><li><p>软引用（SoftReference）：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>仅（可能有强引用，一个对象可以被多个引用）</strong>有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>配合<strong>引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li><li>软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure></li><li><p>弱引用（WeakReference）：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li><li>WeakHashMap 用来存储图片信息，可以在内存不足的时候及时回收，避免了 OOM</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用（PhantomReference）：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，能在这个对象被回收时收到一个系统通知</li><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>终结器引用（finalization）</p></li></ol><hr><h4 id="无用属性"><a href="#无用属性" class="headerlink" title="无用属性"></a>无用属性</h4><h5 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h5><p>方法区主要回收的是无用的类</p><p>判定一个类是否是无用的类，需要同时满足下面 3 个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 <code>ClassLoader</code> 已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是可以</strong>，而并不是和对象一样不使用了就会必然被回收</p><hr><h5 id="废弃常量"><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h5><p>在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该常量，说明常量 “abc” 是废弃常量，如果这时发生内存回收的话<strong>而且有必要的话</strong>（内存不够用），”abc” 就会被系统清理出常量池</p><hr><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>类加载时（第一次访问），这个类中所有静态成员就会被加载到静态变量区，该区域的成员一旦创建，直到程序退出才会被回收</p><p>如果是静态引用类型的变量，静态变量区只存储一份对象的引用地址，真正的对象在堆内，如果要回收该对象可以设置引用为 null</p><p>参考文章：<a href="https://blog.csdn.net/zhengzhb/article/details/7331354">https://blog.csdn.net/zhengzhb/article/details/7331354</a></p><hr><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清理，交换两个内存的角色，完成垃圾的回收</p><p>应用场景：如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之则不适合</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p><p>算法优点：</p><ul><li>没有标记和清除过程，实现简单，运行速度快</li><li>复制过去以后保证空间的连续性，不会出现碎片问题</li></ul><p>算法缺点：</p><ul><li>主要不足是<strong>只使用了内存的一半</strong></li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小</li></ul><p>现在的商业虚拟机都采用这种收集算法<strong>回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间</p><hr><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除算法，是将垃圾回收分为两个阶段，分别是<strong>标记和清除</strong></p><ul><li><p><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></p></li><li><p><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到<strong>空闲列表</strong>的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块</p></li><li><p><strong>分配阶段</strong>：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，如果找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表</p></li></ul><p>算法缺点：</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存，需要维护一个空闲链表</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记清除算法.png" style="zoom: 67%;" /><hr><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>标记整理（压缩）算法是在标记清除算法的基础之上，做了优化改进的算法</p><p>标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是<strong>将存活对象都向内存另一端移动</strong>，然后清理边界以外的垃圾，从而<strong>解决了碎片化</strong>的问题</p><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理效率比较低</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记整理算法.png" style="zoom:67%;" /><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的 2 倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><hr><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>垃圾收集器分类：</p><ul><li>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器<ul><li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</li></ul></li><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器<ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul></li><li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器<ul><li>压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表</li></ul></li><li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器</li></ul><p>GC 性能指标：</p><ul><li><strong>吞吐量</strong>：程序的运行时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率</li><li>内存占用：Java 堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><p><strong>垃圾收集器的组合关系</strong>：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>新生代收集器：Serial、ParNew、Parallel Scavenge</p><p>老年代收集器：Serial old、Parallel old、CMS</p><p>整堆收集器：G1</p><ul><li>红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器</li></ul><p>查看默认的垃圾收回收器：</p><ul><li><p><code>-XX:+PrintcommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数  进程 ID</p></li></ul><hr><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用<strong>复制算法</strong>，新生代基本都是复制算法</p><p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成</p><p><strong>Serial old</strong>：执行老年代垃圾回收的串行收集器，内存回收算法使用的是<strong>标记-整理算法</strong>，同样也采用了串行回收和 STW 机制</p><ul><li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li><li>Serial old 在 Server 模式下主要有两个用途：<ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li></ul></li></ul><p>开启参数：<code>-XX:+UseSerialGC</code> 等价于新生代用 Serial GC 且老年代用 Serial old GC</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Serial%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</p><p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p><hr><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Par 是 Parallel 并行的缩写，New 是只能处理的是新生代</p><p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间</p><p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong>ParNew GC 能与 CMS 收集器配合工作</strong></p><p>相关参数：</p><ul><li><p><code>-XX：+UseParNewGC</code>：表示年轻代使用并行收集器，不影响老年代</p></li><li><p><code>-XX:ParallelGCThreads</code>：默认开启和 CPU 数量相同的线程数</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p><ul><li>对于新生代，回收次数频繁，使用并行方式高效</li><li>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><hr><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>Parallel Scavenge 收集器是应用于新生代的并行垃圾回收器，<strong>采用复制算法</strong>、并行回收和 Stop the World 机制</p><p>Parallel Old 收集器：是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong></p><p>对比其他回收器：</p><ul><li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间</li><li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li><li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong>，可以通过一个开关参数打开 GC Ergonomics</li></ul><p>应用场景：</p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li></ul><p>停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p><p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParallelScavenge%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>参数配置：</p><ul><li><code>-XX：+UseParallelGC</code>：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务</li><li><code>-XX：+UseParalleloldcc</code>：手动指定老年代使用并行回收收集器执行内存回收任务<ul><li>上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的</li></ul></li><li><code>-XX:+UseAdaptivesizepplicy</code>：设置 Parallel Scavenge 收集器具有<strong>自适应调节策略</strong>，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li><li><code>-XX:ParallelGcrhreads</code>：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]&#x2F;8]</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒<ul><li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li><li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数</li></ul></li><li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 &#x3D;1&#x2F;(N+1)，用于衡量吞吐量的大小<ul><li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1</li><li>与 <code>-xx:MaxGCPauseMillis</code> 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例</li></ul></li></ul><hr><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS 全称 Concurrent Mark Sweep，是一款<strong>并发的、使用标记-清除</strong>算法、针对老年代的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong></p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验</p><p>分为以下四个流程：</p><ul><li>初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）</li><li>并发清除：清除标记为可以回收对象，<strong>不需要移动存活对象</strong>，所以这个阶段可以与用户线程同时并发的</li></ul><p>Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的<strong>对象的地址改变</strong>，影响用户线程继续执行</p><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：并发收集、低延迟</p><p>缺点：</p><ul><li><p>吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p></li><li><p>CMS 收集器<strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p><p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间</p></li><li><p>标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</p></li></ul><p>参数设置：</p><ul><li><p><code>-XX：+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务</p><p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即：ParNew + CMS + Serial old的组合</p></li><li><p><code>-XX:CMSInitiatingoccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收</li><li>JDK6 及以上版本默认值为 92%</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长</p></li><li><p><code>-XX:CMSFullGCsBeforecompaction</code>：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p></li><li><p><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量</p><ul><li>CMS 默认启动的线程数是 (ParallelGCThreads+3)&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数</li><li>收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li></ul></li></ul><hr><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="G1-特点"><a href="#G1-特点" class="headerlink" title="G1 特点"></a>G1 特点</h5><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>应用于新生代和老年代</strong>、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&gt;4 ~ 6G），在 JDK9 之后默认使用 G1</p><p>G1 对比其他处理器的优点：</p><ul><li><p>并发与并行：</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li><li>其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会<strong>调用应用程序线程加速垃圾回收</strong>过程</li></ul></li><li><p><strong>分区算法</strong>：</p><ul><li><p>从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</p></li><li><p>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收</p></li><li><p><strong>新的区域 Humongous</strong>：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC</p></li><li><p>G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p></li><li><p>Region 结构图：</p></li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1-Region%E5%8C%BA%E5%9F%9F.png"></p><ul><li><p>空间整合：</p><ul><li>CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片</li></ul></li><li><p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p><ul><li>由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</li></ul><ul><li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</li></ul></li></ul><p>G1 垃圾收集器的缺点：</p><ul><li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高</li><li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间</li></ul><p>应用场景：</p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li><li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li></ul><hr><h5 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h5><p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-G1记忆集.png" style="zoom:67%;" /><ul><li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li><li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li></ul><p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p><ul><li>字长精度</li><li>对象精度</li><li>卡精度(卡表)</li></ul><p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p><p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p><ul><li>CSet of Young Collection</li><li>CSet of Mix Collection</li></ul><hr><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发</p><ul><li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程</li><li>标记完成马上开始混合回收过程</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1回收过程.png" style="zoom: 50%;" /><p>顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收</p><ul><li><p><strong>Young GC</strong>：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收</p><p><strong>回收过程</strong>：</p><ol><li>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</li><li>更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系<ul><li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li><li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li></ul></li><li>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</li><li>复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li><li>处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作</li></ol></li><li><p>**Concurrent Mark **：</p><ul><li>初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC</li><li>并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（<strong>实时回收</strong>），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（<strong>防止漏标</strong>）</li><li>筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p></li><li><p><strong>Mixed GC</strong>：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC</p><p>注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制</p><p>在 G1 中，Mixed GC 可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</p></li><li><p><strong>Full GC</strong>：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC</p><p>产生 Full GC 的原因：</p><ul><li>晋升时没有足够的空间存放晋升的对象</li><li>并发处理过程完成之前空间耗尽，浮动垃圾</li></ul></li></ul><hr><h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1&#x2F;2000</li><li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms</li><li><code>-XX:+ParallelGcThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8</li><li><code>-XX:ConcGCThreads</code>：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1&#x2F;4左右</li><li><code>-XX:InitiatingHeapoccupancyPercent</code>：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li><li><code>-XX:+ClassUnloadingWithConcurrentMark</code>：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li><li><code>-XX:G1NewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5％） </li><li><code>-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最大百分比（默认60％） </li><li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 to space（Survivor中的 to 区）溢出</li></ul><hr><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：</p><ol><li>开启 G1 垃圾收集器</li><li>设置堆的最大内存</li><li>设置最大的停顿时间（STW）</li></ol><p>不断调优暂停时间指标：</p><ul><li><code>XX:MaxGCPauseMillis=x</code> 可以设置启动应用程序暂停的时间，G1会根据这个参数选择 CSet 来满足响应时间的设置</li><li>设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成50ms就不太合理</li><li>暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC</li><li>对这个参数的调优是一个持续的过程，逐步调整到最佳状态</li></ul><p>不要设置新生代和老年代的大小：</p><ul><li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标</li><li>设置了新生代大小相当于放弃了 G1 的自动调优，我们只需要设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小</li></ul><hr><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>ZGC 收集器是一个可伸缩的、低延迟的垃圾收集器，基于 Region 内存布局的，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记压缩算法</strong></p><ul><li>在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了读屏障</li><li>染色指针：直接<strong>将少量额外的信息存储在指针上的技术</strong>，从 64 位的指针中拿高 4 位来标识对象此时的状态<ul><li>染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li><li>可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize() 方法才能被访问到（Finalizable）</li><li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作</li><li>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</li></ul></li><li>内存多重映射：多个虚拟地址指向同一个物理地址</li></ul><p>可并发的标记压缩算法：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，<strong>并更新引用</strong>，不会像 G1 一样必须等待垃圾回收完成才能访问</p><p>ZGC 目标：</p><ul><li>停顿时间不会超过 10ms</li><li>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）</li><li>可支持几百 M，甚至几 T 的堆大小（最大支持4T）</li></ul><p>ZGC 的工作过程可以分为 4 个阶段：</p><ul><li>并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿</li><li>并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）</li><li>并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的<strong>每个 Region 维护一个转发表</strong>（Forward Table），记录从旧地址到新地址的转向关系</li><li>并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销</li></ul><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><p>优点：高吞吐量、低延迟</p><p>缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾</p><p>参考文章：<a href="https://www.cnblogs.com/jimoer/p/13170249.html">https://www.cnblogs.com/jimoer/p/13170249.html</a></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC  不同：</p><ul><li>最小化地使用内存和并行开销，选 Serial GC</li><li>最大化应用程序的吞吐量，选 Parallel GC</li><li>最小化 GC 的中断或停顿时间，选 CMS GC</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png"></p><hr><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="泄露溢出"><a href="#泄露溢出" class="headerlink" title="泄露溢出"></a>泄露溢出</h4><p>内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。由于代码的实现不同就会出现很多种内存泄漏问题，让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏</p><p>内存溢出（out of memory）指的是申请内存时，没有足够的内存可以使用</p><p>内存泄漏和内存溢出的关系：内存泄漏的越来越多，最终会导致内存溢出</p><hr><h4 id="几种情况"><a href="#几种情况" class="headerlink" title="几种情况"></a>几种情况</h4><h5 id="静态集合"><a href="#静态集合" class="headerlink" title="静态集合"></a>静态集合</h5><p>静态集合类的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。原因是<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏</p><hr><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类持有外部类的情况，如果一个外部类的实例对象调用方法返回了一个内部类的实例对象，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象也不会被回收，造成内存泄漏</p><hr><h5 id="连接相关"><a href="#连接相关" class="headerlink" title="连接相关"></a>连接相关</h5><p>数据库连接、网络连接和 IO 连接等，当不再使用时，需要显式调用 close 方法来释放与连接，垃圾回收器才会回收对应的对象，否则将会造成大量的对象无法被回收，从而引起内存泄漏</p><hr><h5 id="不合理域"><a href="#不合理域" class="headerlink" title="不合理域"></a>不合理域</h5><p>变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏；如果没有及时地把对象设置为 null，也有可能导致内存泄漏的发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = readFromNet();<span class="comment">// 从网络中接受数据保存到 msg 中</span></span><br><span class="line">        saveDB(msg);<span class="comment">// 把 msg 保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 readFromNet 方法把接收消息保存在 msg 中，然后调用 saveDB 方法把内容保存到数据库中，此时 msg 已经可以被回收，但是 msg 的生命周期与对象的生命周期相同，造成 msg 不能回收，产生内存泄漏</p><p>解决：</p><ul><li>msg 变量可以放在 receiveMsg 方法内部，当方法使用完，msg 的生命周期也就结束，就可以被回收了</li><li>在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</li></ul><hr><h5 id="改变哈希"><a href="#改变哈希" class="headerlink" title="改变哈希"></a>改变哈希</h5><p>当一个对象被存储进 HashSet 集合中以后，就<strong>不能修改这个对象中的那些参与计算哈希值的字段</strong>，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值不同，这种情况下使用该对象的当前引用作为的参数去 HashSet 集合中检索对象返回 false，导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏</p><hr><h5 id="缓存泄露"><a href="#缓存泄露" class="headerlink" title="缓存泄露"></a>缓存泄露</h5><p>内存泄漏的一个常见来源是缓存，一旦把对象引用放入到缓存中，就会很容易被遗忘</p><p>使用 WeakHashMap 代表缓存，当除了自身有对 key 的引用外没有其他引用，map 会自动丢弃此值</p><hr><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序并没有明显错误，但 pop 函数存在内存泄漏问题，因为 pop 函数只是把栈顶索引下移一位，并没有把上一个出栈索引处的引用置空，导致<strong>栈数组一直强引用着已经出栈的对象</strong></p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="对象访存"><a href="#对象访存" class="headerlink" title="对象访存"></a>对象访存</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>一个 Java 对象内存中存储为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充 （Padding）</p><p>对象头：</p><ul><li><p>普通对象：分为两部分</p><ul><li><p><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">25</span>) + age(<span class="number">4</span>) + lock(<span class="number">3</span>) = 32bit<span class="comment">#32位系统</span></span><br><span class="line">unused(<span class="number">25</span>+<span class="number">1</span>) + hash(<span class="number">31</span>) + age(<span class="number">4</span>) + lock(<span class="number">3</span>) = 64bit<span class="comment">#64位系统</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Klass Word</strong>：类型指针，<strong>指向该对象的 Class 类对象的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 <strong>Java 中的一个引用的大小</strong>）</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-----------------------------------------------------</span>|</span><br><span class="line">|<span class="params">   Object Header (64 bits)   </span>|</span><br><span class="line">|<span class="params">---------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|  Mark Word (<span class="number">32</span> bits)|<span class="params">  Klass Word (32 bits)   </span>|</span><br><span class="line">|<span class="params">---------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure></li><li><p>数组对象：如果对象是一个数组，那在对象头中还有一块数据用于记录数组长度（12 字节）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">   Object Header (96 bits)     </span>|</span><br><span class="line">|<span class="params">-----------------------</span>|-----------------------------|<span class="params">-------------------------</span>|</span><br><span class="line">|<span class="params">  Mark Word(32bits)    </span>|   Klass Word(32bits)   |<span class="params">   array length(32bits)  </span>|</span><br><span class="line">|<span class="params">-----------------------</span>|-----------------------------|<span class="params">-------------------------</span>|</span><br></pre></td></tr></table></figure></li></ul><p>实例数据：实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来</p><p>对齐填充：Padding 起占位符的作用。64 位系统，由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p><p>32 位系统：</p><ul><li><p>一个 int 在 java 中占据 4byte，所以 Integer 的大小为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要补位4byte</span></span><br><span class="line"><span class="number">4</span>(Mark Word) + <span class="number">4</span>(Klass Word) + <span class="number">4</span>(data) + <span class="number">4</span>(Padding) = 16byte</span><br></pre></td></tr></table></figure></li><li><p><code>int[] arr = new int[10]</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于需要8位对齐，所以最终大小为56byte</span></span><br><span class="line"><span class="number">4</span>(Mark Word) + <span class="number">4</span>(Klass Word) + <span class="number">4</span>(length) + <span class="number">4</span>*<span class="number">10</span>(<span class="number">10</span>个int大小) + <span class="number">4</span>(Padding) = 56sbyte</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实际大小"><a href="#实际大小" class="headerlink" title="实际大小"></a>实际大小</h4><p>浅堆（Shallow Heap）：<strong>对象本身占用的内存，不包括内部引用对象的大小</strong>，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐</p><p>JDK7 中的 String：2个 int 值共占 8 字节，value 对象引用占用 4 字节，对象头 8 字节，对齐后占 24 字节，为 String 对象的浅堆大小，与 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash32;</span><br></pre></td></tr></table></figure><p>保留集（Retained Set）：对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括 A 本身），所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合</p><p>深堆（Retained Heap）：指对象的保留集中所有的对象的浅堆大小之和，一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</p><p>对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小</p><p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，<strong>A 的实际大小为 A、C、D 三者之和</strong>，A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-对象的实际大小.png" style="zoom: 67%;" /><p>内存分析工具 MAT 提供了一种叫支配树的对象图，体现了对象实例间的支配关系</p><p>基本性质：</p><ul><li><p>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆</p></li><li><p>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B</p></li><li><p>支配树的边与对象引用图的边不直接对应</p></li></ul><p>左图表示对象引用图，右图表示左图所对应的支配树：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E6%94%AF%E9%85%8D%E6%A0%91.png"></p><p>比如：对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此对象 D 是对象 F 的直接支配者</p><p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/nkq31c">https://www.yuque.com/u21195183/jvm/nkq31c</a></p><hr><h4 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h4><ul><li><p>尽量使用基本数据类型</p></li><li><p>满足容量前提下，尽量用小字段</p></li><li><p>尽量用数组，少用集合，数组中是可以使用基本类型的，但是集合中只能放包装类型，如果需要使用集合，推荐比较节约内存的集合工具：fastutil</p><p>一个 ArrayList 集合，如果里面放了 10 个数字，占用多少内存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><p>Mark Word 占 4byte，Klass Word 占 4byte，一个 int 字段占 4byte，elementData 数组占 12byte，数组中 10 个 Integer 对象占 10×16，所以整个集合空间大小为 184byte（深堆）</p></li><li><p>时间用 long&#x2F;int 表示，不用 Date 或者 String</p></li></ul><hr><h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><p>JVM 是通过<strong>栈帧中的对象引用</strong>访问到其内部的对象实例：</p><ul><li><p>句柄访问：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</p><p>优点：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p></li><li><p>直接指针（HotSpot 采用）：Java 堆对象的布局必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的对象地址</p><p>优点：速度更快，<strong>节省了一次指针定位的时间开销</strong></p><p>缺点：对象被移动时（如进行 GC 后的内存重新排列），对象的 reference 也需要同步更新</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"></p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/afraidToForget/p/12584866.html">https://www.cnblogs.com/afraidToForget/p/12584866.html</a></p><hr><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Java 中，对象的生命周期包括以下几个阶段：</p><ol><li><pre><code> 创建阶段 (Created)：</code></pre></li><li><pre><code> 应用阶段 (In Use)：对象至少被一个强引用持有着</code></pre></li><li><pre><code> 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用</code></pre></li><li><pre><code> 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用</code></pre></li><li><pre><code> 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法</code></pre></li><li><pre><code> 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完 finalize() 方法后仍然处于不可达状态时进入该阶段</code></pre></li><li><pre><code> 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配</code></pre></li></ol><p>参考文章：<a href="https://blog.csdn.net/sodino/article/details/38387049">https://blog.csdn.net/sodino/article/details/38387049</a></p><hr><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类</p><p>Java 对象创建时机：</p><ol><li><p>使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建</p></li><li><p>使用 Class 类的 newInstance 方法（反射机制）</p></li><li><p>使用 Constructor 类的 newInstance 方法（反射机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Constructor&lt;Student&gt; c = Student.class.getConstructor(Integer.class);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> c.newInstance(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p></li><li><p>使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法</p></li><li><p>使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个<strong>单独的对象</strong>，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口</p></li></ol><p>从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的</p><hr><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>创建对象的过程：</p><ol><li><p>判断对象对应的类是否加载、链接、初始化</p></li><li><p>为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从<strong>隐藏变量</strong>也会被分配空间（继承部分解释了为什么会隐藏）</p></li><li><p>处理并发安全问题：</p><ul><li>采用 CAS 配上自旋保证更新的原子性</li><li>每个线程预先分配一块 TLAB</li></ul></li><li><p>初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中</p></li><li><p>执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化</p><ul><li><p>实例变量初始化与实例代码块初始化：</p><p>对实例变量直接赋值或者使用实例代码块赋值，<strong>编译器会将其中的代码放到类的构造函数中去</strong>，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前</p></li><li><p>构造函数初始化：</p><p><strong>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性</strong>，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数</p></li></ul></li></ol><hr><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><ol><li><p>一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次</p><p>JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值</p></li><li><p>类的初始化过程与类的实例化过程的异同？</p><p>类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）</p></li><li><p>假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（<strong>经典案例</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        staticFunction();<span class="comment">//调用静态方法，触发初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;       <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;    <span class="comment">// 实例构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction</span><span class="params">()</span> &#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">112</span>;     <span class="comment">// 静态变量</span></span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p><code>static StaticTest st = new StaticTest();</code>：</p><ul><li><p>实例实例化不一定要在类初始化结束之后才开始</p></li><li><p>在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，<strong>实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置</strong>，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因</p></li></ul><p>代码等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    &lt;clinit&gt;()&#123;</span><br><span class="line">        a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);<span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);  <span class="comment">// 实例构造器中代码的执行</span></span><br><span class="line">        类变量st被初始化</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">        类变量b被初始化为<span class="number">112</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>包括 7 个阶段：</p><ul><li>加载（Loading）</li><li>链接：验证（Verification）、准备（Preparation）、解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><hr><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>加载是类加载的其中一个阶段，注意不要混淆</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构（Java 类模型）</li><li><strong>在内存中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口</strong></li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li><li>从网络中获取，最典型的应用是 Applet</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码</li></ul><p>将字节码文件加载至方法区后，会<strong>在堆中</strong>创建一个 java.lang.Class 对象，用来引用位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象</p><p>方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：</p><ul><li><code>_java_mirror</code> 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用</li><li><code>_super</code> 即父类、<code>_fields</code> 即成员变量、<code>_methods</code> 即方法、<code>_constants</code> 即常量池、<code>_class_loader</code> 即类加载器、<code>_vtable</code> <strong>虚方法表</strong>、<code>_itable</code> 接口方法表</li></ul><p>加载过程：</p><ul><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li><li>Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类的生命周期-加载.png" style="zoom:80%;" /><p>创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：</p><ul><li>如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类</li><li><strong>基本数据类型由启动类加载器加载</strong></li></ul><hr><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全</p><p>主要包括<strong>四种验证</strong>：</p><ul><li><p>文件格式验证</p></li><li><p>语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过</p><ul><li><p>是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法</p></li></ul></li><li><p>字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型</li><li>栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</li></ul></li><li><p>符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法</p></li></ul><hr><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段为<strong>静态变量（类变量）分配内存并设置初始值</strong>，使用的是方法区的内存：</p><p>说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p><p>类变量初始化：</p><ul><li>static 变量分配空间和赋值是两个步骤：<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li><li>如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化</li><li>如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成</li></ul><p>实例：</p><ul><li><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>常量 value 被初始化为 123 而不是 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故 boolean 的默认值就是 false</p></li></ul><hr><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中类、接口、字段、方法的<strong>符号引用替换为直接引用</strong>（内存地址）的过程：</p><ul><li>符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和<strong>方法描述符</strong>（因为类还没有加载完，很多方法是找不到的）</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中</li></ul><p>例如：在 <code>com.demo.Solution</code> 类中引用了 <code>com.test.Quest</code>，把 <code>com.test.Quest</code> 作为符号引用存进类常量池，在类加载完后，<strong>用这个符号引用去方法区找这个类的内存地址</strong></p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等</p><ul><li>在类加载阶段解析的是非虚方法，静态绑定</li><li>也可以在初始化阶段之后再开始解析，这是为了支持 Java 的<strong>动态绑定</strong></li><li>通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> Load2.class.getClassLoader();</span><br><span class="line">    <span class="comment">// cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D</span></span><br><span class="line">    Class&lt;?&gt; c = classloader.loadClass(<span class="string">&quot;cn.jvm.t3.load.C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// new C();会导致类的解析和初始化，从而解析初始化D</span></span><br><span class="line">    System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 <clinit></p><p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init</p><p>类构造器 <clinit>() 与实例构造器 <init>() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机<strong>调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象</p><p>类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类</p><hr><h5 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h5><p><clinit>()：类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的</p><p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p><ul><li>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</li><li>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法</li><li>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定</li><li>static 不加 final 的变量都在初始化环节赋值</li></ul><p><strong>线程安全</strong>问题：</p><ul><li>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都阻塞等待，直到活动线程执行 <clinit>() 方法完毕</li><li>如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</li></ul><p>特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//i = 0;                // 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法，两者不同的是：</p><ul><li>在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法</li><li>在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 <clinit>() 方法</li><li>只有当父接口中定义的变量使用时，父接口才会初始化</li></ul><hr><h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><p>类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化</p><p><strong>主动引用</strong>：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：</p><ul><li>当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）</li><li>当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化<ul><li>getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）</li><li>putstatic：程序给类的静态变量赋值</li><li>invokestatic ：调用一个类的静态方法</li></ul></li><li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并<strong>不适用于接口</strong></li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类</li><li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ul><p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化，称为被动引用</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化</li><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li><li>常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li><li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li></ul><hr><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行</p><p>实例化即调用 <init>()V ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行</p><p>类实例化过程：<strong>父类的类构造器<clinit>() -&gt; 子类的类构造器<clinit>() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</strong></p><p>new 关键字会创建对象并复制 dup 一个对象引用，一个调用 <init> 方法，另一个用来赋值给接收者</p><hr><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java虚拟机进程终止</p><p>卸载类即该类的 <strong>Class 对象被 GC</strong>，卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成</li></ol><p>在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的</p><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h4><p>类加载方式：</p><ul><li>隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象<ul><li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li><li>在 JVM 启动时，通过三大类加载器加载 class</li></ul></li><li>显式加载：<ul><li>ClassLoader.loadClass(className)：只加载和连接，<strong>不会进行初始化</strong></li><li>Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li></ul></li></ul><p>类的唯一性：</p><ul><li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：<ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同</li></ul></li><li>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li></ul><p>命名空间：</p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>基本特征：</p><ul><li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li><li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li></ul><hr><h4 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h4><p>类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象</p><p>从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li><li>自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范<strong>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</strong>，使用 Java 语言实现，独立于虚拟机</li></ul><p>从 Java 开发人员的角度看：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：<ul><li>处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li><li>类加载器负责加载在 <code>JAVA_HOME/jre/lib</code> 或 <code>sun.boot.class.path</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中</li><li>仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li><li>启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li></ul></li><li>扩展类加载器（Extension ClassLoader）：<ul><li>由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null</li><li>将 <code>JAVA_HOME/jre/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li><li>开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载</li></ul></li><li>应用程序类加载器（Application ClassLoader）：<ul><li>由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension</li><li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li><li>这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器</li><li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器</li></ul></li><li>自定义类加载器：由开发人员自定义的类加载器，上级是 Application</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//获取系统类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层  扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">    System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@610455d6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层 获取不到引导类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">bootStrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">    System.out.println(bootStrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于用户自定义类来说：使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String 类使用引导类加载器进行加载的 --&gt; java核心类库都是使用启动类加载器加载的</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充两个类加载器：</p><ul><li>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联</li><li>ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ul><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p>获取 ClassLoader 的途径：</p><ul><li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li><li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread.getContextClassLoader()</code></li><li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的 ClassLoader：<code>DriverManager.getCallerClassLoader()</code></li></ul><p>ClassLoader 类常用方法：</p><ul><li><code>getParent()</code>：返回该类加载器的超类加载器  </li><li><code>loadclass(String name)</code>：加载名为 name 的类，返回结果为 Class 类的实例，<strong>该方法就是双亲委派模式</strong></li><li><code>findclass(String name)</code>：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用</li><li><code>findLoadedClass(String name)</code>：查找名称为 name 的已经被加载过的类，final 修饰无法重写</li><li><code>defineClass(String name, byte[] b, int off, int len)</code>：将<strong>字节流</strong>解析成 JVM 能够识别的类对象</li><li><code>resolveclass(Class&lt;?&gt; c)</code>：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</li><li><code>InputStream getResourceAsStream(String name)</code>：指定资源名称获取输入流</li></ul><hr><h4 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h4><h5 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h5><p>在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制</p><ul><li><p><strong>全盘加载：</strong>当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入</p></li><li><p><strong>双亲委派：</strong>先让父类加载器加载该 Class，在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。简单来说就是，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，<strong>依次递归</strong>，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载</p></li><li><p><strong>缓存机制：</strong>会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中</p><ul><li>这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因</li></ul></li></ul><hr><h5 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h5><p>双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p><p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p><p>双亲委派机制的优点：</p><ul><li><p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性</p></li><li><p>Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p></li><li><p>保护程序安全，防止类库的核心 API 被随意篡改</p><p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行 main 函数，会出现异常，在类 java.lang.String 中找不到 main 方法，防止恶意篡改核心 API 库。出现该信息是因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法</p></li></ul><p>双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-双亲委派模型.png" style="zoom: 50%;" /><hr><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">       <span class="comment">// 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前类加载器如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断当前类加载器是否有父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)</span></span><br><span class="line">         <span class="comment">// 父类加载器的 loadClass 方法，又会检查自己是否已经加载过</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader</span></span><br><span class="line">          <span class="comment">// 则调用 BootStrap ClassLoader 的方法加载类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载</span></span><br><span class="line">                <span class="comment">// 可以自定义 findClass() 方法</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">// 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="破坏委派"><a href="#破坏委派" class="headerlink" title="破坏委派"></a>破坏委派</h5><p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式</p><p>破坏双亲委派模型的方式：</p><ul><li><p>自定义 ClassLoader</p><ul><li>如果不想破坏双亲委派模型，只需要重写 findClass 方法</li><li>如果想要去破坏双亲委派模型，需要去**重写 loadClass **方法</li></ul></li><li><p>引入线程<strong>上下文类加载器</strong></p><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：</p><ul><li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的</li><li>SPI 的实现类是由系统类加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类</li></ul><p>JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型</p></li><li><p>实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）</p><p>IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p><p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</p><ol><li>将以 java.* 开头的类，委派给父类加载器加载</li><li>否则，将委派列表名单内的类，委派给父类加载器加载</li><li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li><li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li><li>否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载</li><li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li><li>否则，类查找失败</li></ol><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中</p></li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-热替换.png" style="zoom: 33%;" /><hr><h4 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h4><p>沙箱机制（Sandbox）：将 Java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，来保证对代码的有效隔离，防止对本地系统造成破坏</p><p>沙箱<strong>限制系统资源访问</strong>，包括 CPU、内存、文件系统、网络，不同级别的沙箱对资源访问的限制也不一样</p><ul><li>JDK1.0：Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码不可以访问本地资源，其实依赖于沙箱机制。如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现</li><li>JDK1.1：针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限</li><li>JDK1.2：改进了安全机制，增加了代码签名，不论本地代码或是远程代码都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</li><li>JDK1.6：当前最新的安全机制，引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，不同的保护域对应不一样的权限。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-沙箱机制.png" style="zoom:67%;" /><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>对于自定义类加载器的实现，只需要继承 ClassLoader 类，覆写 findClass 方法即可</p><p>作用：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类加载器，读取指定的类路径classPath下的class文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取字节码文件的完整路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> classPath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">// 获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">            <span class="comment">// 获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 具体读入数据并写出的过程</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="type">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">// 调用 defineClass()，将字节数组的数据转换为 Class 的实例。</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> defineClass(<span class="literal">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="literal">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:\Workspace\Project\JVM_study\src\java1\&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        Class clazz = loader.loadClass(&quot;</span>Demo1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>加载此类的类的加载器为：<span class="string">&quot; + clazz.getClassLoader().getClass().getName());//MyClassLoader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>加载当前类的类的加载器的父类加载器为：<span class="string">&quot; + clazz.getClassLoader().getParent().getClass().getName());//sun.misc.Launcher$AppClassLoader</span></span><br><span class="line"><span class="string">    &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="string">        e.printStackTrace();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><p>为了保证兼容性，JDK9 没有改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行做了一些变动：</p><ul><li><p>扩展机制被移除，扩展类加载器由于<strong>向后兼容性</strong>的原因被保留，不过被重命名为平台类加载器（platform classloader），可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取</p></li><li><p>JDK9 基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数个 JMOD 文件），其中 Java 类库就满足了可扩展的需求，那就无须再保留 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，此前使用这个目录或者 <code>java.ext.dirs</code> 系统变量来扩展 JDK 功能的机制就不需要再存在</p></li><li><p>启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code></p></li></ul><hr><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Java 文件编译执行的过程：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><ul><li>类加载器：用于装载字节码文件（.class文件）</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对 JVM 中的垃圾内容进行回收</li></ul><hr><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><h4 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h4><p>Java 语言：跨平台的语言（write once ，run anywhere）</p><ul><li>当 Java 源代码成功编译成字节码后，在不同的平台上面运行<strong>无须再次编译</strong></li><li>让一个 Java 程序正确地运行在 JVM 中，Java 源码就必须要被编译为符合 JVM 规范的字节码</li></ul><p>编译过程中的编译器：</p><ul><li><p>前端编译器： Sun 的全量式编译器 javac、 Eclipse 的增量式编译器 ECJ，<strong>把源代码编译为字节码文件 .class</strong></p><ul><li>IntelliJ IDEA 使用 javac 编译器</li><li>Eclipse 中，当开发人员编写完代码后保存时，ECJ 编译器就会把未编译部分的源码逐行进行编译，而非每次都全量编译，因此 ECJ 的编译效率会比 javac 更加迅速和高效</li><li>前端编译器并不会直接涉及编译优化等方面的技术，具体优化细节移交给 HotSpot 的 JIT 编译器负责</li></ul></li><li><p>后端运行期编译器：HotSpot VM 的 C1、C2 编译器，也就是 JIT 编译器，Graal 编译器</p><ul><li>JIT 编译器：执行引擎部分详解</li><li>Graal 编译器：JDK10 HotSpot 加入的一个全新的即时编译器，编译效果短短几年时间就追平了 C2</li></ul></li><li><p>静态提前编译器：AOT  (Ahead Of Time Compiler）编译器，直接把源代码编译成本地机器代码</p><ul><li><p>JDK 9 引入，是与即时编译相对立的一个概念，即时编译指的是在程序的运行过程中将字节码转换为机器码，AOT 是程序运行之前便将字节码转换为机器码</p></li><li><p>优点：JVM 加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少 Java 应用第一次运行慢的现象</p></li><li><p>缺点：</p><ul><li>破坏了 Java <strong>一次编译，到处运行</strong>，必须为每个不同硬件编译对应的发行包</li><li>降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知</li></ul></li></ul></li></ul><hr><h4 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h4><p>机器码：各种用二进制编码方式表示的指令，与 CPU 紧密相关，所以不同种类的 CPU 对应的机器指令不同</p><p>指令：指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令，例如 mov，inc 等，可读性稍好，但是不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同</p><p>指令集：不同的硬件平台支持的指令是有区别的，每个平台所支持的指令，称之为对应平台的指令集</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><p>汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址</p><ul><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li><li>计算机只认识指令码，汇编语言编写的程序也必须翻译成机器指令码，计算机才能识别和执行</li></ul><p>高级语言：为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言</p><p>字节码：是一种中间状态（中间码）的二进制代码，比机器码更抽象，需要直译器转译后才能成为机器码</p><ul><li>字节码为了实现特定软件运行和软件环境，与硬件环境无关</li><li>通过编译器和虚拟机器实现，编译器将源码编译成字节码，虚拟机器将字节码转译为可以直接执行的指令</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-高级语言执行过程.png" style="zoom:50%;" /><hr><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><p>字节码是一种二进制的类文件，是编译之后供虚拟机解释执行的二进制字节码文件，<strong>一个 class 文件对应一个 public 类型的类或接口</strong></p><p>字节码内容是 <strong>JVM 的字节码指令</strong>，不是机器码，C、C++ 经由编译器直接生成机器码，所以执行效率比 Java 高</p><p>JVM 官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>根据 JVM 规范，类文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_infoconstant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[fields_count];</span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，识别类文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表都以 <code>_info</code> 结尾，用于描述有层次关系的数据，整个 Class 文件本质上就是一张表，由于表没有固定长度，所以通常会在其前面加上个数说明</li></ul><p>获取方式：</p><ul><li>HelloWorld.java 执行 <code>javac -parameters -d . HellowWorld.java</code>指令</li><li>写入文件指令 <code>javap -v xxx.class &gt;xxx.txt</code></li><li>IDEA 插件 jclasslib</li></ul><hr><h5 id="魔数版本"><a href="#魔数版本" class="headerlink" title="魔数版本"></a>魔数版本</h5><p>魔数：每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number），是 Class 文件的标识符，代表这是一个能被虚拟机接受的有效合法的 Class 文件，</p><ul><li><p>魔数值固定为 0xCAFEBABE，不符合则会抛出错误</p></li><li><p>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</p></li></ul><p>版本：4 个 字节，5 6两个字节代表的是编译的副版本号 minor_version，而 7 8 两个字节是编译的主版本号 major_version</p><ul><li>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，反之 JVM 会抛出异常 <code>java.lang.UnsupportedClassVersionError</code></li></ul><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><p>图片来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><hr><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池计数器（constant_pool_count），这个容量计数是从 1 而不是 0 开始，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量池项目，这种情况可用索引值 0 来表示</p><p>constant_pool 是一种表结构，以1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池</p><ul><li><p>字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等</p></li><li><p>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p><ul><li><p>全限定名：com&#x2F;test&#x2F;Demo 这个就是类的全限定名，仅仅是把包名的 <code>.</code> 替换成 <code>/</code>，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 <code>;</code> 表示全限定名结束</p></li><li><p>简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 x 的简单名称就是 x</p></li><li><p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td>J</td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td>Z</td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code>，不同方法间用<code>;</code>隔开</td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table></li></ul></li></ul><p>常量类型和结构：</p><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer</p><hr><h5 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h5><p>访问标识（access_flag），又叫访问标志、访问标记，该标识用两个字节表示，用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public类型，是否定义为 abstract类型等</p><ul><li>类的访问权限通常为 ACC_ 开头的常量</li><li>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的，比如若是 public final 的类，则该标记为 <code>ACC_PUBLIC | ACC_FINAL</code></li><li>使用 <code>ACC_SUPER</code> 可以让类更准确地定位到父类的方法，确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为 public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><hr><h5 id="索引集合"><a href="#索引集合" class="headerlink" title="索引集合"></a>索引集合</h5><p>类索引、父类索引、接口索引集合</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个，除了Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口</p><ul><li>interfaces_count 项的值表示当前类或接口的直接超接口数量</li><li>interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中</li></ul></li></ul><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><hr><h5 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h5><p>字段 fields 用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述</p><p>fields_count（字段计数器），表示当前 class 文件 fields 表的成员个数，用两个字节来表示</p><p>fields[]（字段表）：</p><ul><li><p>表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p>字段访问标识：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table></li><li><p>字段名索引：根据该值查询常量池中的指定索引项即可</p></li><li><p>描述符索引：用来描述字段的数据类型、方法的参数列表和返回值</p><table><thead><tr><th>字符</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>有符号字节型树</td></tr><tr><td>C</td><td>char</td><td>Unicode字符，UTF-16编码</td></tr><tr><td>D</td><td>double</td><td>双精度浮点数</td></tr><tr><td>F</td><td>float</td><td>单精度浮点数</td></tr><tr><td>I</td><td>int</td><td>整型数</td></tr><tr><td>J</td><td>long</td><td>长整数</td></tr><tr><td>S</td><td>short</td><td>有符号短整数</td></tr><tr><td>Z</td><td>boolean</td><td>布尔值true&#x2F;false</td></tr><tr><td>V</td><td>void</td><td>代表void类型</td></tr><tr><td>L Classname</td><td>reference</td><td>一个名为Classname的实例</td></tr><tr><td>[</td><td>reference</td><td>一个一维数组</td></tr></tbody></table></li><li><p>属性表集合：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于常量属性而言，attribute_length 值恒为2</p></li></ul><hr><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，完整描述了每个方法的签名</p><ul><li>如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来</li><li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li><li>methods 表可能会出现由编译器自动添加的方法，比如初始化方法 <cinit> 和实例化方法 <init></li></ul><p><strong>重载（Overload）</strong>一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存</p><p>methods_count（方法计数器）：表示 class 文件 methods 表的成员个数，使用两个字节来表示</p><p>methods[]（方法表）：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述</p><ul><li><p>方法表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attrubutes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table></li><li><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为 enum</td></tr></tbody></table></li></ul><hr><h5 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h5><p>属性表集合，指的是 Class 文件所携带的辅助信息，比如该 Class 文件的源文件的名称，以及任何带有 <code>RetentionPolicy.CLASS</code> 或者 <code>RetentionPolicy.RUNTIME</code> 的注解，这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试。字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息</p><p>attributes_ count（属性计数器）：表示当前文件属性表的成员个数</p><p>attributes[]（属性表）：属性表的每个项的值必须是 attribute_info 结构</p><ul><li><p>属性的通用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;<span class="comment">//属性名索引</span></span><br><span class="line">    u4 attribute_length;<span class="comment">//属性长度</span></span><br><span class="line">    u2 attribute_info;<span class="comment">//属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性类型：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类、方法、字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code 属性</td><td>Java 源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code 属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code 属性</td><td>JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Syothetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编泽器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td></tr><tr><td>RuntirmelnvisibleParameterAnniotation</td><td>方法表</td><td>作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数</td></tr><tr><td>AnnotationDefauit</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存 invokeddynanic 指令引用的引导方式限定符</td></tr></tbody></table></li></ul><hr><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><h5 id="javac"><a href="#javac" class="headerlink" title="javac"></a>javac</h5><p>javac：编译命令，将 java 源文件编译成 class 字节码文件</p><p><code>javac xx.java</code> 不会在生成对应的局部变量表等信息，使用 <code>javac -g xx.java</code> 可以生成所有相关信息</p><hr><h5 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h5><p>javap 反编译生成的字节码文件，根据 class 字节码文件，反解析出当前类对应的 code 区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息</p><p>用法：javap <options> <classes></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的/公共类和成员</span><br><span class="line">-package                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line"> <span class="comment">#常用的以下三个</span></span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-c                       对代码进行反汇编<span class="comment">#反编译</span></span><br><span class="line"></span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-<span class="built_in">cp</span> &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><hr><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h5 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h5><p>Java 字节码属于 JVM 基本执行指令。由一个字节长度的代表某种操作的操作码（opcode）以及零至多个代表此操作所需参数的操作数（operand）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码（零地址指令）</p><p>由于限制了 Java 虚拟机操作码的长度为一个字节（0~255），所以指令集的操作码总数不可能超过 256 条</p><p>在 JVM 的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如 iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据</p><ul><li>i 代表对 int 类型的数据操作</li><li>l 代表 long </li><li>s 代表 short</li><li>b 代表 byte</li><li>c 代表 char</li><li>f 代表 float</li><li>d 代表 double</li></ul><p>大部分的指令都没有支持 byte、char、short、boolean 类型，编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend-）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据</p><p>在做值相关操作时:</p><ul><li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，也可能是对象的引用）被压入操作数栈</li><li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等等操作</li></ul><hr><h5 id="加载存储"><a href="#加载存储" class="headerlink" title="加载存储"></a>加载存储</h5><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</p><p>局部变量压栈指令：将给定的局部变量表中的数据压入操作数栈</p><ul><li>xload、xload_n，x 表示取值数据类型，为 i、l、f、d、a， n 为 0 到 3</li><li>指令 xload_n 表示将第 n 个局部变量压入操作数栈，aload_n 表示将一个对象引用压栈</li><li>指令 xload n 通过指定参数的形式，把局部变量压入操作数栈，局部变量数量超过 4 个时使用这个命令</li></ul><p>常量入栈指令：将常数压入操作数栈，根据数据类型和入栈内容的不同，又分为 const、push、ldc 指令</p><ul><li>push：包括 bipush 和 sipush，区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数</li><li>ldc：如果以上指令不能满足需求，可以使用 ldc 指令，接收一个 8 位的参数，该参数指向常量池中的 int、 float 或者 String 的索引，将指定的内容压入堆栈。ldc_w 接收两个 8 位参数，能支持的索引范围更大，如果要压入的元素是 long 或 double 类型的，则使用 ldc2_w 指令</li><li>aconst_null 将 null 对象引用压入栈，iconst_m1 将 int 类型常量 -1 压入栈，iconst_0 将 int 类型常量 0 压入栈</li></ul><p>出栈装入局部变量表指令：将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</p><ul><li>xstore、xstore_n，x 表示取值类型为 i、l、f、d、a， n 为 0 到 3</li><li>xastore 表示存入数组，x 取值为 i、l、f、d、a、b、c、s</li></ul><p>扩充局部变量表的访问索引的指令：wide</p><hr><h5 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h5><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈</p><p>没有直接支持 byte、 short、 char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理，数组类型也是转换成 int 数组</p><ul><li><p>加法指令：iadd、ladd、fadd、dadd</p></li><li><p>减法指令：isub、lsub、fsub、dsub</p></li><li><p>乘法指令：imu、lmu、fmul、dmul</p></li><li><p>除法指令：idiv、ldiv、fdiv、ddiv</p></li><li><p>求余指令：irem、lrem、frem、drem（remainder 余数）</p></li><li><p>取反指令：ineg、lneg、fneg、dneg （negation 取反）</p></li><li><p>自增指令：iinc（直接<strong>在局部变量 slot 上进行运算</strong>，不用放入操作数栈）</p></li><li><p>位运算指令，又可分为：</p><ul><li>位移指令：ishl、ishr、 iushr、lshl、lshr、 lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li></ul></li><li><p>比较指令：dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p></li></ul><p>运算模式：</p><ul><li>向最接近数舍入模式，JVM 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示形式与该值一样接近，将优先选择最低有效位为零的</li><li>向零舍入模式：将浮点数转换为整数时，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果</li></ul><p>NaN 值：当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义，将使用 NaN 值来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> i / <span class="number">0.0</span>;</span><br><span class="line">System.out.println(j);<span class="comment">//无穷大，NaN: not a number</span></span><br></pre></td></tr></table></figure><p>**分析 i++**：从字节码角度分析：a++ 和 ++a 的区别是先执行 iload 还是先执行 iinc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">4</span> iload_1<span class="comment">//存入操作数栈</span></span><br><span class="line"> <span class="number">5</span> iinc <span class="number">1</span> by <span class="number">1</span><span class="comment">//自增i++</span></span><br><span class="line"> <span class="number">8</span> istore_3<span class="comment">//把操作数栈没有自增的数据的存入局部变量表</span></span><br><span class="line"> <span class="number">9</span> iinc <span class="number">2</span> by <span class="number">1</span><span class="comment">//++i</span></span><br><span class="line"><span class="number">12</span> iload_2<span class="comment">//加载到操作数栈</span></span><br><span class="line"><span class="number">13</span> istore <span class="number">4</span><span class="comment">//存入局部变量表，这个存入没有 _ 符号，_只能到3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);<span class="comment">//11</span></span><br><span class="line">        System.out.println(b);<span class="comment">//34</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); <span class="comment">// 结果是 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>类型转换指令可以将两种不同的数值类型进行相互转换，除了 boolean 之外的七种类型</p><p>宽化类型转换：</p><ul><li><p>JVM 支持以下数值的宽化类型转换（widening numeric conversion），小范围类型到大范围类型的安全转换</p><ul><li>从 int 类型到 long、float 或者 double 类型，对应的指令为 i2l、i2f、i2d</li><li>从 long 类型到 float、 double 类型，对应的指令为 l2f、l2d</li><li>从 float 类型到 double 类型，对应的指令为 f2d</li></ul></li><li><p>精度损失问题</p><ul><li>宽化类型转换是不会因为超过目标类型最大值而丢失信息</li><li>从 int 转换到 float 或者 long 类型转换到 double 时，将可能发生精度丢失</li></ul></li><li><p>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，JVM 把它们当作 int 处理</p></li></ul><p>窄化类型转换：</p><ul><li><p>Java 虚拟机直接支持以下窄化类型转换：</p><ul><li>从 int 类型至 byte、 short 或者 char 类型，对应的指令有 i2b、i2c、i2s</li><li>从 long 类型到 int 类型，对应的指令有 l2i</li><li>从 float 类型到 int 或者 long 类型，对应的指令有:f2i、f2l</li><li>从 double 类型到 int、long 或 float 者类型，对应的指令有 d2i、d2、d2f</li></ul></li><li><p>精度损失问题：</p><ul><li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，转换过程可能会导致数值丢失精度</li><li>将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）时，将遵循以下转换规则：<ul><li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0</li><li>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T 的表示范围之内，那转换结果就是 v，否则将根据 v 的符号，转换为 T 所能表示的最大或者最小正数</li></ul></li></ul></li></ul><hr><h5 id="创建访问"><a href="#创建访问" class="headerlink" title="创建访问"></a>创建访问</h5><p>创建指令：</p><ul><li><p>创建类实例指令：new，接收一个操作数指向常量池的索引，表示要创建的类型，执行完成后将对象的引用压入栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class com/jvm/bytecode/Demo</span></span><br><span class="line"><span class="number">3</span>:  dup</span><br><span class="line"><span class="number">4</span>:  invokespecial   #<span class="number">3</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br></pre></td></tr></table></figure><p><strong>dup 是复制操作数栈栈顶的内容</strong>，需要两份引用原因：</p><ul><li>一个要配合 invokespecial 调用该对象的构造方法 <init>:()V （会消耗掉栈顶一个引用）</li><li>一个要配合 astore_1 赋值给局部变量</li></ul></li><li><p>创建数组的指令：newarray、anewarray、multianewarray</p><ul><li>newarray：创建基本类型数组</li><li>anewarray：创建引用类型数组</li><li>multianewarray：创建多维数组</li></ul></li></ul><p>字段访问指令：对象创建后可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素</p><ul><li>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</li><li>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield</li></ul><p>类型检查指令：检查类实例或数组类型的指令</p><ul><li><p>checkcast：用于检查类型强制转换是否可以进行，如果可以进行 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常</p></li><li><p>instanceof：判断给定对象是否是某一个类的实例，会将判断结果压入操作数栈</p></li></ul><hr><h5 id="方法指令"><a href="#方法指令" class="headerlink" title="方法指令"></a>方法指令</h5><p>方法调用指令：invokevirtual、 invokeinterface、invokespecial、invokestatic、invokedynamic</p><p><strong>方法调用章节详解</strong></p><hr><h5 id="操作数栈-1"><a href="#操作数栈-1" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令</p><ul><li><p>pop、pop2：将一个或两个元素从栈顶弹出，并且直接废弃</p></li><li><p>dup、dup2，dup_x1、dup2_x1，dup_x2、dup2_x2：复制栈顶一个或两个数值并重新压入栈顶</p></li><li><p>swap：将栈最顶端的两个 slot 数值位置交换，JVM 没有提供交换两个 64 位数据类型数值的指令</p></li><li><p>nop：一个非常特殊的指令，字节码为 0x00，和汇编语言中的 nop 一样，表示什么都不做，一般可用于调试、占位等</p></li></ul><hr><h5 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h5><p>比较指令：比较栈顶两个元素的大小，并将比较结果入栈</p><ul><li>lcmp：比较两个 long 类型值</li><li>fcmpl：比较两个 float 类型值（当遇到NaN时，返回-1）</li><li>fcmpg：比较两个 float 类型值（当遇到NaN时，返回1）</li><li>dcmpl：比较两个 double 类型值（当遇到NaN时，返回-1）</li><li>dcmpg：比较两个 double 类型值（当遇到NaN时，返回1）</li></ul><p>条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ifeq</td><td>equals，当栈顶int类型数值等于0时跳转</td></tr><tr><td>ifne</td><td>not equals，当栈顶in类型数值不等于0时跳转</td></tr><tr><td>iflt</td><td>lower than，当栈顶in类型数值小于0时跳转</td></tr><tr><td>ifle</td><td>lower or equals，当栈顶in类型数值小于等于0时跳转</td></tr><tr><td>ifgt</td><td>greater than，当栈顶int类型数组大于0时跳转</td></tr><tr><td>ifge</td><td>greater or equals，当栈顶in类型数值大于等于0时跳转</td></tr><tr><td>ifnull</td><td>为 null 时跳转</td></tr><tr><td>ifnonnull</td><td>不为 null 时跳转</td></tr></tbody></table><p>比较条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>if_icmpeq</td><td>比较栈顶两 int 类型数值大小（下同），当前者等于后者时跳转</td></tr><tr><td>if_icmpne</td><td>当前者不等于后者时跳转</td></tr><tr><td>if_icmplt</td><td>当前者小于后者时跳转</td></tr><tr><td>if_icmple</td><td>当前者小于等于后者时跳转</td></tr><tr><td>if_icmpgt</td><td>当前者大于后者时跳转</td></tr><tr><td>if_icmpge</td><td>当前者大于等于后者时跳转</td></tr><tr><td>if_acmpeq</td><td>当结果相等时跳转</td></tr><tr><td>if_acmpne</td><td>当结果不相等时跳转</td></tr></tbody></table><p>多条件分支跳转指令：</p><ul><li>tableswitch：用于 switch 条件跳转，case 值连续</li><li>lookupswitch：用于 switch 条件跳转，case 值不连续</li></ul><p>无条件跳转指令：</p><ul><li><p>goto：用来进行跳转到指定行号的字节码</p></li><li><p>goto_w：无条件跳转（宽索引）</p></li></ul><hr><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h6 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h6><p>抛出异常指令：athrow 指令</p><p>JVM 处理异常（catch 语句）不是由字节码指令来实现的，而是<strong>采用异常表来完成</strong>的</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        i = <span class="number">10</span>;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">        i = <span class="number">20</span>;   </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><ul><li>多出一个 <strong>Exception table</strong> 的结构，**[from, to) 是前闭后开的检测范围**，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>11 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置，因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: iconst_0</span><br><span class="line">    <span class="number">1</span>: istore_1 <span class="comment">// 0 -&gt; i-&gt;赋值</span></span><br><span class="line">    <span class="number">2</span>: bipush <span class="number">10</span> <span class="comment">// try 10 放入操作数栈顶</span></span><br><span class="line">    <span class="number">4</span>: istore_1 <span class="comment">// 10 -&gt; i 将操作数栈顶数据弹出，存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">5</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】 </span></span><br><span class="line">    <span class="number">7</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">8</span>: goto <span class="number">27</span> <span class="comment">// return -----------------------------------</span></span><br><span class="line">    <span class="number">11</span>: astore_2 <span class="comment">// catch Exceptin -&gt; e ----------------------</span></span><br><span class="line">    <span class="number">12</span>: bipush <span class="number">20</span> <span class="comment">// </span></span><br><span class="line">    <span class="number">14</span>: istore_1 <span class="comment">// 20 -&gt; i </span></span><br><span class="line">    <span class="number">15</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】 </span></span><br><span class="line">    <span class="number">17</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">18</span>: goto <span class="number">27</span> <span class="comment">// return -----------------------------------</span></span><br><span class="line">    <span class="number">21</span>: astore_3 <span class="comment">// catch any -&gt; slot 3 ----------------------</span></span><br><span class="line">    <span class="number">22</span>: bipush <span class="number">30</span> <span class="comment">// 【finally】</span></span><br><span class="line">    <span class="number">24</span>: istore_1 <span class="comment">// 30 -&gt; i </span></span><br><span class="line">    <span class="number">25</span>: aload_3 <span class="comment">// 将局部变量表的slot 3数据弹出，放入操作数栈栈顶</span></span><br><span class="line">    <span class="number">26</span>: athrow <span class="comment">// throw 抛出异常</span></span><br><span class="line">    <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">Exception table:</span><br><span class="line"><span class="comment">// 任何阶段出现任务异常都会执行 finally</span></span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">2</span><span class="number">5</span> <span class="number">11</span> Class java/lang/Exception</span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">21</span> any <span class="comment">// 剩余的异常类型，比如 Error</span></span><br><span class="line"><span class="number">11</span> <span class="number">15</span> <span class="number">21</span> any <span class="comment">// 剩余的异常类型，比如 Error</span></span><br><span class="line">LineNumberTable: ...</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line"><span class="number">12</span> <span class="number">3</span> <span class="number">2</span> e Ljava/lang/Exception;</span><br><span class="line"><span class="number">0</span> <span class="number">28</span> <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line"><span class="number">2</span> <span class="number">26</span> <span class="number">1</span> i I</span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h6><p>finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程（上节案例）</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 -&gt; slot 0 【从栈顶移除了】</span></span><br><span class="line">    <span class="number">3</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">5</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">    <span class="number">6</span>: astore_1 <span class="comment">// catch any 存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">7</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">0</span><span class="number">3</span><span class="number">6</span> any      </span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="return"><a href="#return" class="headerlink" title="return"></a>return</h6><ul><li><p>吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 -&gt; slot 0 【从栈顶移除了】</span></span><br><span class="line">    <span class="number">3</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">5</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">    <span class="number">6</span>: astore_1 <span class="comment">// catch any  存入局部变量表的 slot1</span></span><br><span class="line">    <span class="number">7</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶 int(20)</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line"><span class="number">0</span><span class="number">3</span><span class="number">6</span> any      </span><br></pre></td></tr></table></figure><ul><li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果以 finally 的为准</li><li>字节码中没有 <strong>athrow</strong> ，表明如果在 finally 中出现了 return，会<strong>吞掉异常</strong></li></ul></li><li><p>不吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">    System.out.println(result);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//返回10</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶</span></span><br><span class="line">    <span class="number">2</span>: istore_0 <span class="comment">// 10 赋值给i，放入slot 0</span></span><br><span class="line">    <span class="number">3</span>: iload_0 <span class="comment">// i(10)加载至操作数栈</span></span><br><span class="line">    <span class="number">4</span>: istore_1 <span class="comment">// 10 -&gt; slot 1，【暂存至 slot 1，目的是为了固定返回值】</span></span><br><span class="line">    <span class="number">5</span>: bipush <span class="number">20</span> <span class="comment">// 20 放入栈顶</span></span><br><span class="line">    <span class="number">7</span>: istore_0 <span class="comment">// 20 slot 0</span></span><br><span class="line">    <span class="number">8</span>: iload_1 <span class="comment">// slot 1(10) 载入 slot 1 暂存的值</span></span><br><span class="line">    <span class="number">9</span>: ireturn <span class="comment">// 返回栈顶的 int(10)</span></span><br><span class="line">    <span class="number">10</span>: astore_2<span class="comment">// catch any -&gt; slot 2 存入局部变量表的 slot2</span></span><br><span class="line">    <span class="number">11</span>: bipush <span class="number">20</span></span><br><span class="line">    <span class="number">13</span>: istore_0</span><br><span class="line">    <span class="number">14</span>: aload_2</span><br><span class="line">    <span class="number">15</span>: athrow<span class="comment">// 不会吞掉异常</span></span><br><span class="line">Exception table:</span><br><span class="line">from   to target type</span><br><span class="line">  <span class="number">3</span>   <span class="number">5</span><span class="number">10</span> any  </span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>方法级的同步：是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法</p><p>方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义</p><ul><li>montiorenter：进入并获取对象监视器，即为栈顶对象加锁</li><li>monitorexit：释放并退出对象监视器，即为栈顶对象解锁</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码指令同步控制.png" style="zoom: 33%;" /><hr><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>原始 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -v Demo.class：省略</p><ul><li><p>常量池载入运行时常量池</p></li><li><p>方法区字节码载入方法区</p></li><li><p>main 线程开始运行，分配栈帧内存：（操作数栈stack&#x3D;2，局部变量表locals&#x3D;4）</p></li><li><p><strong>执行引擎</strong>开始执行字节码</p><p><code>bipush 10</code>：将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li></ul><p><code>istore_1</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1.png"></p><p><code>ldc #3</code>：从常量池加载 #3 数据到操作数栈<br>Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算完成</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png"></p><p><code>istore_2</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 2</p><p><code>iload_1</code>：将局部变量表的 slot 1 数据弹出，放入操作数栈栈顶</p><p><code>iload_2</code>：将局部变量表的 slot 2 数据弹出，放入操作数栈栈顶</p><p><code>iadd</code>：执行相加操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B3.png"></p><p><code>istore_3</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 3</p><p><code>getstatic #4</code>：获取静态字段</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B4.png"></p><p><code>iload_3</code>：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B5.png"></p><p><code>invokevirtual #5</code>：</p><ul><li>找到常量池 #5 项</li><li>定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</li><li><strong>生成新的栈帧</strong>（分配 locals、stack等）</li><li>传递参数，执行新栈帧中的字节码</li><li>执行完毕，弹出栈帧</li><li>清除 main 操作数栈内容</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B6.png"></p><p>return：完成 main 方法调用，弹出 main 栈帧，程序结束</p></li></ul><hr><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>执行引擎：Java 虚拟机的核心组成部分之一，类加载主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，需要执行引擎将<strong>字节码指令解释&#x2F;编译为对应平台上的本地机器指令</strong>，进行执行</p><p>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力：</p><ul><li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上</li><li>虚拟机的执行引擎是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系</li></ul><p>Java 是<strong>半编译半解释型语言</strong>，将解释执行与编译执行二者结合起来进行：</p><ul><li>解释器：根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行</li><li>即时编译器（JIT : Just In Time Compiler）：虚拟机运行时将源代码直接编译成<strong>和本地机器平台相关的机器码</strong>后再执行，并存入 Code Cache，下次遇到相同的代码直接执行，效率高</li></ul><hr><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><p>HotSpot VM 采用<strong>解释器与即时编译器并存的架构</strong>，解释器和即时编译器能够相互协作，去选择最合适的方式来权衡编译本地代码和直接解释执行代码的时间</p><p>HostSpot JVM 的默认执行方式：</p><ul><li>当程序启动后，解释器可以马上发挥作用立即执行，省去编译器编译的时间（解释器存在的<strong>必要性</strong>）</li><li>随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</li></ul><p>HotSpot VM 可以通过 VM 参数设置程序执行方式：</p><ul><li>-Xint：完全采用解释器模式执行程序</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><hr><h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><p>热点代码：被 JIT 编译器编译的字节码，根据代码被调用执行的频率而定，一个被多次调用的方法或者一个循环次数较多的循环体都可以被称之为热点代码</p><p>热点探测：JIT 编译器在运行时会针热点代码做出深度优化，将其直接编译为对应平台的本地机器指令进行缓存，以提升程序执行性能</p><p>JIT 编译在默认情况是异步进行的，当触发某方法或某代码块的优化时，先将其放入编译队列，然后由编译线程进行编译，编译之后的代码放在 CodeCache 中，通过 <code>-XX:-BackgroundCompilation</code> 参数可以关闭异步编译</p><ul><li><strong>CodeCache</strong> 用于缓存编译后的机器码、动态生成的代码和本地方法代码 JNI</li><li>如果 CodeCache 区域被占满，编译器被停用，字节码将不会编译为机器码，应用程序继续运行，但运行性能会降低很多</li></ul><p>HotSpot VM 采用的热点探测方式是基于计数器的热点探测，为每一个方法都建立 2 个不同类型的计数器：方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter）</p><ul><li><p>方法调用计数器：用于统计方法被调用的次数，默认阈值在 Client 模式 下是 1500 次，在 Server 模式下是 10000 次（需要进行激进的优化），超过这个阈值，就会触发 JIT 编译，阈值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 设置</p><p>工作流程：当一个方法被调用时， 会先检查该方法是否存在被 JIT 编译过的版本，存在则使用编译后的本地代码来执行；如果不存在则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果超过阈值会向即时编译器<strong>提交一个该方法的代码编译请求</strong></p></li><li><p>回边计数器：统计一个方法中循环体代码执行的次数，在字节码中控制流向后跳转的指令称为回边</p><p>如果一个方法中的循环体需要执行多次，可以优化为为栈上替换，简称 OSR (On StackReplacement) 编译，<strong>OSR 替换循环代码体的入口，C1、C2 替换的是方法调用的入口</strong>，OSR 编译后会出现方法的整段代码被编译了，但是只有循环体部分才执行编译后的机器码，其他部分仍是解释执行</p></li></ul><hr><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>HotSpot VM 内嵌两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器</p><p>C1 编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度，C1 编译器的优化方法：</p><ul><li><p>方法内联：<strong>将调用的函数代码编译到调用点处</strong>，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p><p>方法内联能够消除方法调用的固定开销，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>square 是热点方法，会进行内联，把方法内代码拷贝粘贴到调用者的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>还能够进行常量折叠（constant folding）的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure></li><li><p>冗余消除：根据运行时状况进行代码折叠或削除</p></li><li><p>内联缓存：是一种加快动态绑定的优化技术（方法调用部分详解）</p></li></ul><p>C2 编译器进行耗时较长的优化以及激进优化，优化的代码执行效率更高，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因</p><p>C2 的优化主要是在全局层面，逃逸分析是优化的基础：标量替换、栈上分配、同步消除</p><p>VM 参数设置：</p><ul><li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器</li><li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器</li><li><code>-server -XX:+TieredCompilation</code>：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启</li></ul><p>分层编译策略 (Tiered Compilation)：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：</p><ul><li><p>0 层，解释执行（Interpreter）</p></li><li><p>1 层，使用 C1 即时编译器编译执行（不带 profiling）</p></li><li><p>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</p></li><li><p>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</p></li><li><p>4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）</p><p>说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p></li></ul><p>参考文章：<a href="https://www.jianshu.com/p/20bd2e9b1f03">https://www.jianshu.com/p/20bd2e9b1f03</a></p><hr><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="方法识别"><a href="#方法识别" class="headerlink" title="方法识别"></a>方法识别</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）</p><ul><li><strong>方法描述符是由方法的参数类型以及返回类型所构成</strong>，Java 层面叫方法特征签名</li><li>在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错</li></ul><p>JVM 根据名字和描述符来判断的，只要返回值不一样（方法描述符不一样），其它完全一样，在 JVM 中是允许的，但 Java 语言不允许</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型不同，编译阶段直接报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">invoke</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">invoke</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="调用机制"><a href="#调用机制" class="headerlink" title="调用机制"></a>调用机制</h4><p>方法调用并不等于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>，不是方法的具体运行过程</p><p>在 JVM 中，将符号引用转换为直接引用有两种机制：</p><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程称之为静态链接（类加载的解析阶段）</li><li>动态链接：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接（初始化后的解析阶段）</li></ul><p>对应方法的绑定（分配）机制：静态绑定和动态绑定。绑定是一个字段、方法或者类从符号引用被替换为直接引用的过程，仅发生一次：</p><ul><li>静态绑定：被调用的目标方法在编译期可知，且运行期保持不变，将这个方法与所属的类型进行绑定</li><li>动态绑定：被调用的目标方法在编译期无法确定，只能在程序运行期根据实际的类型绑定相关的方法</li></ul><ul><li>Java 编译器已经区分了重载的方法（静态绑定和动态绑定），因此可以认为虚拟机中不存在重载</li></ul><p>非虚方法：</p><ul><li>非虚方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</li><li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>所有普通成员方法、实例方法、被重写的方法都是虚方法</li></ul><p>动态类型语言和静态类型语言：</p><ul><li><p>在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言</p></li><li><p>静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</p></li><li><p><strong>Java 是静态类型语言</strong>（尽管 Lambda 表达式为其增加了动态特性），JS，Python 是动态类型语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;   <span class="comment">//Java</span></span><br><span class="line">info = <span class="string">&quot;abc&quot;</span>;       <span class="comment">//Python</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h4><h5 id="五种指令"><a href="#五种指令" class="headerlink" title="五种指令"></a>五种指令</h5><p>普通调用指令：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：调用私有实例方法、构造器，和父类的实例方法或构造器，以及所实现接口的默认方法</li><li>invokevirtual：调用所有虚方法（虚方法分派）</li><li>invokeinterface：调用接口方法</li></ul><p>动态调用指令：</p><ul><li>invokedynamic：动态解析出需要调用的方法<ul><li>Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令</li><li>Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式</li></ul></li></ul><p>指令对比：</p><ul><li>普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法</li><li>动态调用指令支持用户确定方法</li><li>invokestatic 和 invokespecial 指令调用的方法称为非虚方法，虚拟机能够直接识别具体的目标方法</li><li>invokevirtual 和 invokeinterface 指令调用的方法称为虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法</li></ul><p>指令说明：</p><ul><li>如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态</li></ul><hr><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>在编译过程中，虚拟机并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法，这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符</p><ul><li>对于静态绑定的方法调用而言，实际引用是一个指向方法的指针</li><li>对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引</li></ul><p>符号引用存储在方法区常量池中，根据目标方法是否为接口方法，分为接口符号引用和非接口符号引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">...</span><br><span class="line">  #<span class="number">16</span> = InterfaceMethodref #<span class="number">27.</span>#<span class="number">29</span><span class="comment">// 接口</span></span><br><span class="line">...</span><br><span class="line">  #<span class="number">22</span> = Methodref          #<span class="number">1.</span>#<span class="number">33</span><span class="comment">// 非接口</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 C 中查找符合名字及描述符的方法</li><li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类</li><li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果有多个符合条件的目标方法，则任意返回其中一个</li></ol><p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 I 中查找符合名字及描述符的方法</li><li>如果没有找到，在 Object 类中的公有实例方法中搜索</li><li>如果没有找到，则在 I 的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致</li></ol><hr><h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo3_9</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3_9</span>();</span><br><span class="line">        d.test1();</span><br><span class="line">        d.test2();</span><br><span class="line">        d.test3();</span><br><span class="line">        d.test4();</span><br><span class="line">        Demo.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几种不同的方法调用对应的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class cn/jvm/t3/bytecode/Demo</span></span><br><span class="line"><span class="number">3</span>:  dup</span><br><span class="line"><span class="number">4</span>:  invokespecial   #<span class="number">3</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>:  astore_1</span><br><span class="line"><span class="number">8</span>:  aload_1</span><br><span class="line"><span class="number">9</span>:  invokespecial   #<span class="number">4</span> <span class="comment">// Method test1:()V</span></span><br><span class="line"><span class="number">12</span>: aload_1</span><br><span class="line"><span class="number">13</span>: invokespecial   #<span class="number">5</span> <span class="comment">// Method test2:()V</span></span><br><span class="line"><span class="number">16</span>: aload_1</span><br><span class="line"><span class="number">17</span>: invokevirtual   #<span class="number">6</span> <span class="comment">// Method test3:()V</span></span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"><span class="number">21</span>: pop</span><br><span class="line"><span class="number">22</span>: invokestatic    #<span class="number">7</span> <span class="comment">// Method test4:()V</span></span><br><span class="line"><span class="number">25</span>: invokestatic    #<span class="number">7</span> <span class="comment">// Method test4:()V</span></span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>invokespecial 调用该对象的构造方法 <init>:()V </li><li>invokevirtual 调用对象的成员方法</li><li><code>d.test4()</code> 是通过<strong>对象引用</strong>调用一个静态方法，在调用 invokestatic 之前执行了 pop 指令，把对象引用从操作数栈弹掉<ul><li>不建议使用 <code>对象.静态方法()</code> 的方式调用静态方法，多了 aload 和 pop 指令</li><li>成员方法与静态方法调用的区别是：执行方法前是否需要对象引用</li></ul></li></ul><hr><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><h5 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h5><p>Java 虚拟机中关于方法重写的判定基于方法描述符，如果子类定义了与父类中非私有、非静态方法同名的方法，只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写</p><p>理解多态：</p><ul><li>多态有编译时多态和运行时多态，即静态绑定和动态绑定</li><li>前者是通过方法重载实现，后者是通过重写实现（子类覆盖父类方法，虚方法表）</li><li>虚方法：运行时动态绑定的方法，对比静态绑定的非虚方法调用来说，虚方法调用更加耗时</li></ul><p>方法重写的本质：</p><ol><li><p>找到操作数栈的第一个元素<strong>所执行的对象的实际类型</strong>，记作 C</p></li><li><p>如果在类型 C 中找到与描述符和名称都相符的方法，则进行访问<strong>权限校验</strong>（私有的），如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</p><p>IllegalAccessError：表示程序试图访问或修改一个属性或调用一个方法，这个属性或方法没有权限访问，一般会引起编译器异常。如果这个错误发生在运行时，就说明一个类发生了不兼容的改变</p></li><li><p>找不到，就会按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程</p></li><li><p>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</p></li></ol><hr><h5 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h5><p>在虚拟机工作过程中会频繁使用到动态绑定，每次动态绑定的过程中都要重新在类的元数据中搜索合适目标，影响到执行效率。为了提高性能，JVM 采取了一种用<strong>空间换取时间</strong>的策略来实现动态绑定，在每个<strong>类的方法区</strong>建立一个虚方法表（virtual method table），实现使用索引表来代替查找，可以快速定位目标方法</p><ul><li>invokevirtual 所使用的虚方法表（virtual method table，vtable），执行流程<ol><li>先通过栈帧中的对象引用找到对象，分析对象头，找到对象的实际 Class</li><li>Class 结构中有 vtable，查表得到方法的具体地址，执行方法的字节码</li></ol></li><li>invokeinterface 所使用的接口方法表（interface method table，itable）</li></ul><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕</p><p>虚方法表的执行过程：</p><ul><li>对于静态绑定的方法调用而言，实际引用将指向具体的目标方法</li><li>对于动态绑定的方法调用而言，实际引用则是方法表的索引值，也就是方法的间接地址。Java 虚拟机获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法内存偏移量（指针）</li></ul><p>为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表。每个类中都有一个虚方法表，本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法</p><p>方法表满足以下的特质：</p><ul><li>其一，子类方法表中包含父类方法表中的<strong>所有方法</strong>，并且在方法表中的索引值与父类方法表种的索引值相同</li><li>其二，<strong>非重写的方法指向父类的方法表项，与父类共享一个方法表项，重写的方法指向本身自己的实现</strong>。所以这就是为什么多态情况下可以访问父类的方法。</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表.png" style="zoom: 80%;" /><p>Passenger 类的方法表包括两个方法，分别对应 0 号和 1 号。方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致，为了保持简洁，这里不考虑 Object 类中的其他方法。</p><p>虚方法表对性能的影响：</p><ul><li>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者、读取调用者的动态类型、读取该类型的方法表、读取方法表中某个索引值所对应的目标方法，但是相对于创建并初始化 Java 栈帧这操作的开销可以忽略不计</li><li>上述优化的效果看上去不错，但实际上<strong>仅存在于解释执行</strong>中，或者即时编译代码的最坏情况。因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a boy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a girl&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%E6%8C%87%E5%90%91.png"></p><p>参考文档：<a href="https://www.cnblogs.com/kaleidoscope/p/9790766.html">https://www.cnblogs.com/kaleidoscope/p/9790766.html</a></p><hr><h5 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h5><p>内联缓存：是一种加快动态绑定的优化技术，能够缓存虚方法调用中<strong>调用者的动态类型以及该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，便会直接调用该类型所对应的目标方法；反之内联缓存则会退化至使用基于方法表的动态绑定</p><p>多态的三个术语：</p><ul><li>单态 (monomorphic)：指的是仅有一种状态的情况</li><li>多态 (polymorphic)：指的是有限数量种状态的情况，二态（bimorphic）是多态的其中一种</li><li>超多态 (megamorphic)：指的是更多种状态的情况，通常用一个具体数值来区分多态和超多态，在这个数值之下，称之为多态，否则称之为超多态</li></ul><p>对于内联缓存来说，有对应的单态内联缓存、多态内联缓存：</p><ul><li>单态内联缓存：只缓存了一种动态类型以及所对应的目标方法，实现简单，比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</li><li>多态内联缓存：缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法</li></ul><p>为了节省内存空间，<strong>Java 虚拟机只采用单态内联缓存</strong>，没有命中的处理方法：</p><ul><li>替换单态内联缓存中的纪录，类似于 CPU 中的数据缓存，对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存</li><li>劣化为超多态状态，这也是 Java 虚拟机的具体实现方式，这种状态实际上放弃了优化的机会，将直接访问方法表来动态绑定目标方法，但是与替换内联缓存纪录相比节省了写缓存的额外开销</li></ul><p>虽然内联缓存附带内联二字，但是并没有内联目标方法</p><p>参考文章：<a href="https://time.geekbang.org/column/intro/100010301">https://time.geekbang.org/column/intro/100010301</a></p><hr><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>语法糖：指 Java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Candy1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;</span></span><br><span class="line">        &lt;init&gt;<span class="string">&quot;:()V</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="拆装箱"><a href="#拆装箱" class="headerlink" title="拆装箱"></a>拆装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br></pre></td></tr></table></figure><p>JDK5 以后编译阶段自动转换成上述片段</p><hr><h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><p>泛型也是在 JDK 5 开始加入的特性，但 Java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都<strong>当做了 Object 类型</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br></pre></td></tr></table></figure><p>编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure><hr><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数 <code>String... args</code> 其实是 <code>String[] args</code> ， Java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]&#123;&#125;)</code> ，创建了一个空的数组，而不会传递 null 进去</p><hr><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>数组的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 数组赋初值的简化写法也是语法糖</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> e : array) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后为循环取数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> array[i];</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后转换为对迭代器的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> (Integer)iter.next();</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：foreach 循环写法，能够配合数组以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器</p><hr><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>switch 可以作用于字符串和枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>switch 配合 String 和枚举使用时，变量不能为 null</strong></p><p>会被编译器转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">99162322</span>: <span class="comment">// hello 的 hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">113318802</span>: <span class="comment">// world 的 hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较</li><li>hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突</li></ul><hr><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>switch 枚举的例子，原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Sex sex)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译转换后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个合成类（仅 jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">* 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">* 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span></span><br><span class="line"><span class="comment">* 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">    <span class="comment">// 数组大小即为枚举元素个数，里面存储 case 用来对比的数字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    map[Sex.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">    map[Sex.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Sex sex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[sex.ordinal()];</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>JDK 7 新增了枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译转换后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = <span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-w-r"><a href="#try-w-r" class="headerlink" title="try-w-r"></a>try-w-r</h4><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code>，格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象)&#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>( ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中资源对象需要实现 <strong>AutoCloseable</strong> 接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources可以不用写 finally 语句块，编译器会帮助生成关闭资源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>)) &#123;</span><br><span class="line">System.out.println(is);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换成：</p><p><code>addSuppressed(Throwable e)</code>：添加被压制异常，是为了防止异常信息的丢失（<strong>fianlly 中如果抛出了异常</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">    <span class="comment">// t 是我们代码出现的异常</span></span><br><span class="line">    t = e1;</span><br><span class="line">    <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 判断了资源不为空</span></span><br><span class="line">        <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">                    <span class="comment">// 如果 close 出现异常，作为被压制异常添加</span></span><br><span class="line">                    t.addSuppressed(e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span></span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Number <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 子类m方法的返回值是Integer是父类m方法返回值Number的子类</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子类，Java 编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 此方法才是真正重写了父类 public Number m() 方法</span></span><br><span class="line"><span class="keyword">public</span> synthetic bridge Number <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 public Integer m()</span></span><br><span class="line">    <span class="keyword">return</span> m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中桥接方法比较特殊，仅对 Java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突</p><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h5 id="无参优化"><a href="#无参优化" class="headerlink" title="无参优化"></a>无参优化</h5><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    Candy11$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="带参优化"><a href="#带参优化" class="headerlink" title="带参优化"></a>带参优化</h5><p>引用局部变量的匿名内部类，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok:&quot;</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> val$x;</span><br><span class="line">    Candy11$<span class="number">1</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="built_in">this</span>.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量在底层创建为内部类的成员变量，必须是 final 的原因：</p><ul><li><p>在 Java 中方法调用是值传递的，在匿名内部类中对变量的操作都是基于原变量的副本，不会影响到原变量的值，所以<strong>原变量的值的改变也无法同步到副本中</strong></p></li><li><p>外部变量为 final 是在编译期以强制手段确保用户不会在内部类中做修改原变量值的操作，也是<strong>防止外部操作修改了变量而内部类无法随之变化</strong>出现的影响</p><p>在创建 <code>Candy11$1 </code> 对象时，将 x 的值赋值给了 <code>Candy11$1</code> 对象的 val 属性，x 不应该再发生变化了，因为发生变化，this.val$x 属性没有机会再跟着变化</p></li></ul><hr><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Reflect1.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">            foo.invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 0 ~ 15 次调用的是 MethodAccessor 的实现类 <code>NativeMethodAccessorImpl.invoke0()</code>，本地方法执行速度慢；当调用到第 16 次时，会采用运行时生成的类 <code>sun.reflect.GeneratedMethodAccessor1</code> 代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// inflationThreshold 膨胀阈值，默认 15</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">        &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【调用本地方法实现】</span></span><br><span class="line">    <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有参数，那么抛非法参数异常</span></span><br><span class="line">    block4 : &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrobject == <span class="literal">null</span> || arrobject.length == <span class="number">0</span>) <span class="keyword">break</span> block4;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【可以看到，已经是直接调用方法】</span></span><br><span class="line">        Reflect1.foo();</span><br><span class="line">        <span class="comment">// 因为没有返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看 ReflectionFactory 源码可知：</p><ul><li>sun.reflect.noInflation 可以用来禁用膨胀，直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算</li><li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li></ul><hr><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>性能指标主要是吞吐量、响应时间、QPS、TPS 等、并发用户数等，而这些性能指标又依赖于系统服务器的资源，如 CPU、内存、磁盘 IO、网络 IO 等，对于这些指标数据的收集，通常可以根据Java本身的工具或指令进行查询</p><p>几个重要的指标：</p><ol><li>停顿时间（响应时间）：提交请求和返回该请求的响应之间使用的时间，比如垃圾回收中 STW 的时间</li><li>吞吐量：对单位时间内完成的工作量（请求）的量度（可以对比 GC 的性能指标）</li><li>并发数：同一时刻，对服务器有实际交互的请求数</li><li>QPS：Queries Per Second，每秒处理的查询量</li><li>TPS：Transactions Per Second，每秒产生的事务数</li><li>内存占用：Java 堆区所占的内存大小</li></ol><hr><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><p>对于一个系统要部署上线时，则一定会对 JVM 进行调整，不经过任何调整直接上线，容易出现线上系统频繁 FullGC 造成系统卡顿、CPU 使用频率过高、系统无反应等问题</p><ol><li><p>性能监控：通过运行日志、堆栈信息、线程快照等信息监控是否出现 GC 频繁、OOM、内存泄漏、死锁、响应时间过长等情况</p></li><li><p>性能分析：</p><ul><li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li></ul><ul><li><p>运用命令行工具、jstack、jmap、jinfo 等</p></li><li><p>dump 出堆文件，使用内存分析工具分析文件</p></li><li><p>使用阿里 Arthas、jconsole、JVisualVM 来<strong>实时查看 JVM 状态</strong></p></li><li><p>jstack 查看堆栈信息</p></li></ul></li><li><p>性能调优：</p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li></ul><ul><li><p>优化代码，控制内存使用</p></li><li><p>增加机器，分散节点压力</p></li><li><p>合理设置线程池线程数量</p></li><li><p>使用中间件提高程序效率，比如缓存、消息队列等</p></li></ul></li></ol><hr><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>对于 JVM 调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p><ul><li><p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure></li><li><p>设置年轻代中 Eden 区和两个 Survivor 区的大小比例。该值如果不设置，则默认比例为 8:1:1。Java 官方通过增大 Eden 区的大小，来减少 YGC 发生的次数，虽然次数减少了，但 Eden 区满的时候，由于占用的空间较大，导致释放缓慢，此时 STW 的时间较长，因此需要按照程序情况去调优</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio</span><br></pre></td></tr></table></figure></li><li><p>年轻代和老年代默认比例为 1:2，可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure></li><li><p>线程堆栈的设置：<strong>每个线程默认会开启 1M 的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般 256K 就够用，通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure></li><li><p>一般一天超过一次 FullGC 就是有问题，首先通过工具查看是否出现内存泄露，如果出现内存泄露则调整代码，没有的话则调整 JVM 参数</p></li><li><p>系统 CPU 持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决</p></li><li><p>如果数据查询性能很低下的话，如果系统并发量并没有多少，则应更加关注数据库的相关问题</p></li><li><p>如果服务器配置还不错，JDK8 开始尽量使用 G1 或者新生代和老年代组合使用并行垃圾回收器</p></li></ul><hr><h3 id="命令行篇"><a href="#命令行篇" class="headerlink" title="命令行篇"></a>命令行篇</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps（Java Process Statu）：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的</p><p>使用语法：<code>jps [options] [hostid]</code></p><p>options 参数：</p><ul><li><p>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id，不显示主类的名称等</p></li><li><p>-l：输出应用程序主类的全类名或如果进程执行的是 jar 包，则输出 jar 完整路径</p></li><li><p>-m：输出虚拟机进程启动时传递给主类 main()的参数</p></li><li><p>-v：列出虚拟机进程启动时的JVM参数，比如 -Xms20m -Xmx50m是启动程序指定的 jvm 参数</p></li></ul><p>ostid 参数：RMI注册表中注册的主机名，如果想要远程监控主机上的 java 程序，需要安装 jstatd</p><hr><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat（JVM Statistics Monitoring Tool）：用于监视 JVM 各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有 GUI 的图形界面，只提供了纯文本控制台环境的服务器上，它是运行期定位虚拟机性能问题的首选工具，常用于检测垃圾回收问题以及内存泄漏问题</p><p>使用语法：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><p>查看命令相关参数：jstat-h 或 jstat-help</p><ul><li><p>vmid 是进程 id 号</p></li><li><p>option 参数：</p><p>类装载相关：</p><ul><li>-class：显示 ClassLoader 的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p>垃圾回收相关：</p><ul><li><p>-gc：显示与GC相关的堆信息，年轻代、老年代、永久代等的容量、已用空间、GC时间合计等信息</p></li><li><p>-gccapacity：显示内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</p></li><li><p>-gcutil：显示内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</p></li><li><p>-gccause：与 -gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因</p></li><li><p>-gcnew：显示新生代 GC 状况</p></li><li><p>-gcnewcapacity：显示内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-geold：显示老年代 GC 状况</p></li><li><p>-gcoldcapacity：显示内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-gcpermcapacity：显示永久代使用到的最大、最小空间</p></li></ul><p>JIT 相关：</p><ul><li><p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被 JIT 编译的方法</p></li></ul></li></ul><hr><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo（Configuration Info for Java）：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数，开发人员可以很方便地找到 Java 虚拟机参数的当前值</p><p>使用语法：<code>jinfo [options] pid</code></p><p>options 参数：</p><ul><li>no option：输出全部的参数和系统属性</li><li>-flag name：输出对应名称的参数</li><li>-flag [+-]name：开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</li><li>-flag name&#x3D;value：设定对应名称的参数</li><li>-flags：输出全部的参数</li><li>-sysprops：输出系统属性</li></ul><hr><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap（JVM Memory Map）：获取 dump 文件，还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等</p><p>使用语法：</p><ul><li><p><code>jmap [options] &lt;pid&gt;</code></p></li><li><p><code>jmap [options] &lt;executable &lt;core&gt;</code></p></li><li><p><code>jmap [options] [server_id@] &lt;remote server IP or hostname&gt;</code></p></li></ul><p>option 参数：</p><ul><li>-dump：生成 dump 文件（Java堆转储快照，二进制文件），-dump:live 只保存堆中的存活对象</li><li>-heap：输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</li><li>-histo：输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</li><li>-J <flag>：传递参数给 jmap 启动的 jvm</li><li>-finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux&#x2F;solaris 平台有效</li><li>-permstat：以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux&#x2F;solaris 平台有效</li><li>-F：当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux&#x2F;solaris 平台有效</li></ul><hr><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>jhat（JVM Heap Analysis Tool）：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于<strong>分析 jmap 生成的 heap dump 文件</strong>（堆转储快照），jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果</p><p>使用语法：<code>jhat &lt;options&gt; &lt;dumpfile&gt;</code></p><p>options 参数：</p><ul><li>-stack false｜true：关闭｜打开对象分配调用栈跟踪</li><li>-refs false｜true：关闭｜打开对象引用跟踪</li><li>-port port-number：设置 jhat HTTP Server 的端口号，默认 7000</li><li>-exclude exclude-file：执行对象查询时需要排除的数据成员</li><li>-baseline exclude-file：指定一个基准堆转储</li><li>-debug int：设置 debug 级别</li><li>-version：启动后显示版本信息就退出</li><li>-J <flag>：传入启动参数，比如 -J-Xmx512m</li></ul><p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替</p><hr><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪），线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p><p>线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题，用 jstack 显示各个线程调用的堆栈情况</p><p>使用语法：<code>jstack [options] pid</code></p><p>options 参数：</p><ul><li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l：除堆栈外，显示关于锁的附加信息</li><li>-m：如果调用本地方法的话，可以显示 C&#x2F;C++ 的堆栈</li></ul><p>在 thread dump 中的几种状态：</p><ul><li><p>死锁：Deadlock</p></li><li><p>等待资源：Waiting on condition</p></li><li><p>等待获取监视器：Waiting on monitor entry</p></li><li><p>阻塞：Blocked</p></li><li><p>执行中：Runnable</p></li><li><p>暂停：Suspended</p></li><li><p>对象等待中：Object.wait() 或 TIMED＿WAITING</p></li><li><p>停止：Parked</p></li></ul><hr><h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p>jcmd 是一个多功能命令行工具，可以用来实现前面除了 jstat 之外所有命令的功能，比如 dump、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等</p><p>jcmd -l：列出所有的JVM进程</p><p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p><ul><li>Thread.print：可以替换 jstack 指令</li></ul><ul><li><p>GC.class_histogram：可以替换 jmap 中的 -histo 操作</p></li><li><p>GC.heap_dump：可以替换 jmap 中的 -dump 操作</p></li><li><p>GC.run：可以查看GC的执行情况</p></li><li><p>VM.uptime：可以查看程序的总执行时间，可以替换 jstat 指令中的 -t  操作</p></li><li><p>VM.system_properties：可以替换 jinfo -sysprops 进程 id</p></li><li><p>VM.flags：可以获取 JVM 的配置参数信息</p></li></ul><hr><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd 是一个 RMI 服务端程序，相当于代理服务器，建立本地计算机与远程监控工具的通信，jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机</p><p>远程主机信息收集，前面的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat），为了启用远程监控，则需要配合使用 jstatd 工具。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-jstatd%E5%9B%BE%E8%A7%A3.png"></p><hr><h3 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h3><p>工具的使用此处不再多言，推荐一个写的非常好的文章，JVM 调优部分的笔记全部参考此文章编写</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=304">https://www.bilibili.com/video/BV1PJ411n7xZ?p=304</a></p><p>文章链接：<a href="https://www.yuque.com/u21195183/jvm/lv1zot">https://www.yuque.com/u21195183/jvm/lv1zot</a></p><hr><h3 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h3><h4 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h4><p>添加 JVM 参数选项：进入 Run&#x2F;Debug Configurations → VM options 设置参数</p><ul><li><p>标准参数选项：<code>java [-options] class [args...]</code> 或 <code>java [-options] -jar jarfile [args...]</code></p><p>命令：<code>-? -help</code> 可以输出此命令的相关选项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Seazean&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_221&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br><span class="line"><span class="comment"># mixed mode 字样，代表当前系统使用的是混合模式</span></span><br></pre></td></tr></table></figure><p>Hotspot JVM 有两种模式，分别是 Server 和 Client，分别通过 -server 和- client 设置模式：</p><ul><li><p>32 位系统上，默认使用 Client 类型的 JVM，要使用 Server 模式，机器配置至少有 2 个以上的内核和 2G 以上的物理内存，Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</p></li><li><p>64 位系统上，只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</p></li></ul></li><li><p>-X 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed           混合模式执行 (默认)</span><br><span class="line">-Xint             仅解释模式执行</span><br><span class="line">-Xbootclasspath:&lt;用;分隔的目录和zip/jar文件&gt;设置搜索路径以引导类和资源</span><br><span class="line">-Xbootclasspath/a:&lt;用;分隔的目录和zip/jar文件&gt;附加在引导类路径末尾</span><br><span class="line">-Xbootclasspath/p:&lt;用;分隔的目录和zip/jar文件&gt;置于引导类路径之前</span><br><span class="line">-Xdiag            显示附加诊断消息</span><br><span class="line">-Xnoclassgc       禁用类垃圾收集</span><br><span class="line">-Xincgc           启用增量垃圾收集</span><br><span class="line">-Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">-Xbatch           禁用后台编译</span><br><span class="line">-Xprof            输出 cpu 配置文件数据</span><br><span class="line">-Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">-Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">-Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">-Xshare:off       不尝试使用共享类数据</span><br><span class="line">-Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">-Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">-XshowSettings    显示所有设置并继续</span><br><span class="line">-XshowSettings:all显示所有设置并继续</span><br><span class="line">-XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">-XshowSettings:properties显示所有属性设置并继续</span><br><span class="line">-XshowSettings:locale显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure></li><li><p>-XX 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Boolean类型格式</span></span><br><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br><span class="line"><span class="comment">#非Boolean类型格式</span></span><br><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></table></figure></li></ul><p>程序运行中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"><span class="comment"># 设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="打印参数"><a href="#打印参数" class="headerlink" title="打印参数"></a>打印参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure><hr><h4 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M（默认为物理内存的1/64）</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M（默认为物理内存的1/4）</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></table></figure><p>说明：参数前面是<code>+</code>号说明是开启，如果是<code>- </code>号说明是关闭</p><hr><h4 id="OOM参数"><a href="#OOM参数" class="headerlink" title="OOM参数"></a>OOM参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure><hr><h4 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintTenuringDistribution打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure><hr><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k] 指定代码缓存大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br></pre></td></tr></table></figure><hr><h4 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h4><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，允许本地或远程监控和管理运行的 Java 虚拟机。ManagementFactory 类较为常用，Runtime 类可获取内存、CPU 核数等相关的数据，通过使用这些方法，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">memorymbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====通过java来获取相关系统状态====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><h4 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h4><p>HotSpot VM 的 GC 按照回收区域分为两类：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为： </p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代（Eden&#x2F;S0、S1）的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集，只有 CMS GC 会有单独收集老年代的行为</li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，只有 G1 GC 会有这种行为 </p></li><li><p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p></li></ul><p>Minor GC&#x2F;Young GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>Full GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><hr><h4 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h4><p>通过日志看垃圾收集器：</p><ul><li><p>Serial 收集器：新生代显示 <code>[DefNew</code>，即 <code>Default New Generation</code></p></li><li><p>ParNew 收集器：新生代显示 <code>[ParNew</code>，即 <code>Parallel New Generation</code></p></li><li><p>Parallel Scavenge 收集器：新生代显示 <code>[PSYoungGen</code>，JDK1.7 使用的 PSYoungGen </p></li><li><p>Parallel Old 收集器：老年代显示 <code>[ParoldGen</code></p></li><li><p>G1 收集器：显示 <code>garbage-first heap</code></p></li></ul><p>通过日志看 GC 原因：</p><ul><li><p>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</p></li><li><p>Metadata GCThreshold：Metaspace 区不足</p></li><li><p>FErgonomics：JVM 自适应调整导致的 GC</p></li><li><p>System：调用了 System.gc() 方法</p></li></ul><p>通过日志看 GC 前后情况：GC 前内存占用 → GC 后内存占用（该区域内存总大小）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K)] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure><ul><li><p>中括号内：GC 回收前年轻代堆大小 → 回收后大小（年轻代堆总大小） </p></li><li><p>括号外：GC 回收前年轻代和老年代大小 → 回收后大小（年轻代和老年代总大小）</p></li></ul><ul><li>Minor GC 堆内存总容量 &#x3D; 9&#x2F;10 年轻代 + 老年代，Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系：Eden:S0:S1&#x3D;8:1:1</li></ul><p>通过日志看 GC 时间：GC 日志中有三个时间 user、sys、real</p><ul><li><p>user：进程执行用户态代码（核心之外）所使用的时间，这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内，在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</p></li><li><p>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</p></li><li><p>real：程序从开始到结束所用的时钟时间，这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成），对于并行 GC，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</p></li></ul><p>由于多核的原因，一般的 GC 事件中，real time 小于 sys time＋user time，因为是多个线程并发的去做 GC。如果 real＞sys＋user 的话，则说明 IO 负载非常重或 CPU 不够用</p><hr><h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的</p><ul><li>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></li></ul><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>，还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等），当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</p><ul><li><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p></li><li><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p></li></ul><p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/ukmb3k">https://www.yuque.com/u21195183/jvm/ukmb3k</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM概述&quot;&gt;&lt;a href=&quot;#JVM概述&quot; class=&quot;headerlink&quot; title=&quot;JVM概述&quot;&gt;&lt;/a&gt;JVM概述&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Java/JVM/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
</feed>
